function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["routing-modules-editor-editor-module"], {
  /***/"./node_modules/brace/ext/language_tools.js":
  /*!**************************************************!*\
    !*** ./node_modules/brace/ext/language_tools.js ***!
    \**************************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceExtLanguage_toolsJs(module, exports) {
    ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/anchor", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/lib/dom", "ace/editor"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var lang = acequire("./lib/lang");
      var Range = acequire("./range").Range;
      var Anchor = acequire("./anchor").Anchor;
      var HashHandler = acequire("./keyboard/hash_handler").HashHandler;
      var Tokenizer = acequire("./tokenizer").Tokenizer;
      var comparePoints = Range.comparePoints;
      var SnippetManager = function SnippetManager() {
        this.snippetMap = {};
        this.snippetNameMap = {};
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.getTokenizer = function () {
          function TabstopToken(str, _, stack) {
            str = str.substr(1);
            if (/^\d+$/.test(str) && !stack.inFormatString) return [{
              tabstopId: parseInt(str, 10)
            }];
            return [{
              text: str
            }];
          }
          function escape(ch) {
            return "(?:[^\\\\" + ch + "]|\\\\.)";
          }
          SnippetManager.$tokenizer = new Tokenizer({
            start: [{
              regex: /:/,
              onMatch: function onMatch(val, state, stack) {
                if (stack.length && stack[0].expectIf) {
                  stack[0].expectIf = false;
                  stack[0].elseBranch = stack[0];
                  return [stack[0]];
                }
                return ":";
              }
            }, {
              regex: /\\./,
              onMatch: function onMatch(val, state, stack) {
                var ch = val[1];
                if (ch == "}" && stack.length) {
                  val = ch;
                } else if ("`$\\".indexOf(ch) != -1) {
                  val = ch;
                } else if (stack.inFormatString) {
                  if (ch == "n") val = "\n";else if (ch == "t") val = "\n";else if ("ulULE".indexOf(ch) != -1) {
                    val = {
                      changeCase: ch,
                      local: ch > "a"
                    };
                  }
                }
                return [val];
              }
            }, {
              regex: /}/,
              onMatch: function onMatch(val, state, stack) {
                return [stack.length ? stack.shift() : val];
              }
            }, {
              regex: /\$(?:\d+|\w+)/,
              onMatch: TabstopToken
            }, {
              regex: /\$\{[\dA-Z_a-z]+/,
              onMatch: function onMatch(str, state, stack) {
                var t = TabstopToken(str.substr(1), state, stack);
                stack.unshift(t[0]);
                return t;
              },
              next: "snippetVar"
            }, {
              regex: /\n/,
              token: "newline",
              merge: false
            }],
            snippetVar: [{
              regex: "\\|" + escape("\\|") + "*\\|",
              onMatch: function onMatch(val, state, stack) {
                stack[0].choices = val.slice(1, -1).split(",");
              },
              next: "start"
            }, {
              regex: "/(" + escape("/") + "+)/(?:(" + escape("/") + "*)/)(\\w*):?",
              onMatch: function onMatch(val, state, stack) {
                var ts = stack[0];
                ts.fmtString = val;
                val = this.splitRegex.exec(val);
                ts.guard = val[1];
                ts.fmt = val[2];
                ts.flag = val[3];
                return "";
              },
              next: "start"
            }, {
              regex: "`" + escape("`") + "*`",
              onMatch: function onMatch(val, state, stack) {
                stack[0].code = val.splice(1, -1);
                return "";
              },
              next: "start"
            }, {
              regex: "\\?",
              onMatch: function onMatch(val, state, stack) {
                if (stack[0]) stack[0].expectIf = true;
              },
              next: "start"
            }, {
              regex: "([^:}\\\\]|\\\\.)*:?",
              token: "",
              next: "start"
            }],
            formatString: [{
              regex: "/(" + escape("/") + "+)/",
              token: "regex"
            }, {
              regex: "",
              onMatch: function onMatch(val, state, stack) {
                stack.inFormatString = true;
              },
              next: "start"
            }]
          });
          SnippetManager.prototype.getTokenizer = function () {
            return SnippetManager.$tokenizer;
          };
          return SnippetManager.$tokenizer;
        };
        this.tokenizeTmSnippet = function (str, startState) {
          return this.getTokenizer().getLineTokens(str, startState).tokens.map(function (x) {
            return x.value || x;
          });
        };
        this.$getDefaultValue = function (editor, name) {
          if (/^[A-Z]\d+$/.test(name)) {
            var i = name.substr(1);
            return (this.variables[name[0] + "__"] || {})[i];
          }
          if (/^\d+$/.test(name)) {
            return (this.variables.__ || {})[name];
          }
          name = name.replace(/^TM_/, "");
          if (!editor) return;
          var s = editor.session;
          switch (name) {
            case "CURRENT_WORD":
              var r = s.getWordRange();
            case "SELECTION":
            case "SELECTED_TEXT":
              return s.getTextRange(r);
            case "CURRENT_LINE":
              return s.getLine(editor.getCursorPosition().row);
            case "PREV_LINE":
              // not possible in textmate
              return s.getLine(editor.getCursorPosition().row - 1);
            case "LINE_INDEX":
              return editor.getCursorPosition().column;
            case "LINE_NUMBER":
              return editor.getCursorPosition().row + 1;
            case "SOFT_TABS":
              return s.getUseSoftTabs() ? "YES" : "NO";
            case "TAB_SIZE":
              return s.getTabSize();
            case "FILENAME":
            case "FILEPATH":
              return "";
            case "FULLNAME":
              return "Ace";
          }
        };
        this.variables = {};
        this.getVariableValue = function (editor, varName) {
          if (this.variables.hasOwnProperty(varName)) return this.variables[varName](editor, varName) || "";
          return this.$getDefaultValue(editor, varName) || "";
        };
        this.tmStrFormat = function (str, ch, editor) {
          var flag = ch.flag || "";
          var re = ch.guard;
          re = new RegExp(re, flag.replace(/[^gi]/, ""));
          var fmtTokens = this.tokenizeTmSnippet(ch.fmt, "formatString");
          var _self = this;
          var formatted = str.replace(re, function () {
            _self.variables.__ = arguments;
            var fmtParts = _self.resolveVariables(fmtTokens, editor);
            var gChangeCase = "E";
            for (var i = 0; i < fmtParts.length; i++) {
              var ch = fmtParts[i];
              if (typeof ch == "object") {
                fmtParts[i] = "";
                if (ch.changeCase && ch.local) {
                  var next = fmtParts[i + 1];
                  if (next && typeof next == "string") {
                    if (ch.changeCase == "u") fmtParts[i] = next[0].toUpperCase();else fmtParts[i] = next[0].toLowerCase();
                    fmtParts[i + 1] = next.substr(1);
                  }
                } else if (ch.changeCase) {
                  gChangeCase = ch.changeCase;
                }
              } else if (gChangeCase == "U") {
                fmtParts[i] = ch.toUpperCase();
              } else if (gChangeCase == "L") {
                fmtParts[i] = ch.toLowerCase();
              }
            }
            return fmtParts.join("");
          });
          this.variables.__ = null;
          return formatted;
        };
        this.resolveVariables = function (snippet, editor) {
          var result = [];
          for (var i = 0; i < snippet.length; i++) {
            var ch = snippet[i];
            if (typeof ch == "string") {
              result.push(ch);
            } else if (typeof ch != "object") {
              continue;
            } else if (ch.skip) {
              gotoNext(ch);
            } else if (ch.processed < i) {
              continue;
            } else if (ch.text) {
              var value = this.getVariableValue(editor, ch.text);
              if (value && ch.fmtString) value = this.tmStrFormat(value, ch);
              ch.processed = i;
              if (ch.expectIf == null) {
                if (value) {
                  result.push(value);
                  gotoNext(ch);
                }
              } else {
                if (value) {
                  ch.skip = ch.elseBranch;
                } else gotoNext(ch);
              }
            } else if (ch.tabstopId != null) {
              result.push(ch);
            } else if (ch.changeCase != null) {
              result.push(ch);
            }
          }
          function gotoNext(ch) {
            var i1 = snippet.indexOf(ch, i + 1);
            if (i1 != -1) i = i1;
          }
          return result;
        };
        this.insertSnippetForSelection = function (editor, snippetText) {
          var cursor = editor.getCursorPosition();
          var line = editor.session.getLine(cursor.row);
          var tabString = editor.session.getTabString();
          var indentString = line.match(/^\s*/)[0];
          if (cursor.column < indentString.length) indentString = indentString.slice(0, cursor.column);
          snippetText = snippetText.replace(/\r/g, "");
          var tokens = this.tokenizeTmSnippet(snippetText);
          tokens = this.resolveVariables(tokens, editor);
          tokens = tokens.map(function (x) {
            if (x == "\n") return x + indentString;
            if (typeof x == "string") return x.replace(/\t/g, tabString);
            return x;
          });
          var tabstops = [];
          tokens.forEach(function (p, i) {
            if (typeof p != "object") return;
            var id = p.tabstopId;
            var ts = tabstops[id];
            if (!ts) {
              ts = tabstops[id] = [];
              ts.index = id;
              ts.value = "";
            }
            if (ts.indexOf(p) !== -1) return;
            ts.push(p);
            var i1 = tokens.indexOf(p, i + 1);
            if (i1 === -1) return;
            var value = tokens.slice(i + 1, i1);
            var isNested = value.some(function (t) {
              return typeof t === "object";
            });
            if (isNested && !ts.value) {
              ts.value = value;
            } else if (value.length && (!ts.value || typeof ts.value !== "string")) {
              ts.value = value.join("");
            }
          });
          tabstops.forEach(function (ts) {
            ts.length = 0;
          });
          var expanding = {};
          function copyValue(val) {
            var copy = [];
            for (var i = 0; i < val.length; i++) {
              var p = val[i];
              if (typeof p == "object") {
                if (expanding[p.tabstopId]) continue;
                var j = val.lastIndexOf(p, i - 1);
                p = copy[j] || {
                  tabstopId: p.tabstopId
                };
              }
              copy[i] = p;
            }
            return copy;
          }
          for (var i = 0; i < tokens.length; i++) {
            var p = tokens[i];
            if (typeof p != "object") continue;
            var id = p.tabstopId;
            var i1 = tokens.indexOf(p, i + 1);
            if (expanding[id]) {
              if (expanding[id] === p) expanding[id] = null;
              continue;
            }
            var ts = tabstops[id];
            var arg = typeof ts.value == "string" ? [ts.value] : copyValue(ts.value);
            arg.unshift(i + 1, Math.max(0, i1 - i));
            arg.push(p);
            expanding[id] = p;
            tokens.splice.apply(tokens, arg);
            if (ts.indexOf(p) === -1) ts.push(p);
          }
          var row = 0,
            column = 0;
          var text = "";
          tokens.forEach(function (t) {
            if (typeof t === "string") {
              var lines = t.split("\n");
              if (lines.length > 1) {
                column = lines[lines.length - 1].length;
                row += lines.length - 1;
              } else column += t.length;
              text += t;
            } else {
              if (!t.start) t.start = {
                row: row,
                column: column
              };else t.end = {
                row: row,
                column: column
              };
            }
          });
          var range = editor.getSelectionRange();
          var end = editor.session.replace(range, text);
          var tabstopManager = new TabstopManager(editor);
          var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
          tabstopManager.addTabstops(tabstops, range.start, end, selectionId);
        };
        this.insertSnippet = function (editor, snippetText) {
          var self = this;
          if (editor.inVirtualSelectionMode) return self.insertSnippetForSelection(editor, snippetText);
          editor.forEachSelection(function () {
            self.insertSnippetForSelection(editor, snippetText);
          }, null, {
            keepOrder: true
          });
          if (editor.tabstopManager) editor.tabstopManager.tabNext();
        };
        this.$getScope = function (editor) {
          var scope = editor.session.$mode.$id || "";
          scope = scope.split("/").pop();
          if (scope === "html" || scope === "php") {
            if (scope === "php" && !editor.session.$mode.inlinePhp) scope = "html";
            var c = editor.getCursorPosition();
            var state = editor.session.getState(c.row);
            if (typeof state === "object") {
              state = state[0];
            }
            if (state.substring) {
              if (state.substring(0, 3) == "js-") scope = "javascript";else if (state.substring(0, 4) == "css-") scope = "css";else if (state.substring(0, 4) == "php-") scope = "php";
            }
          }
          return scope;
        };
        this.getActiveScopes = function (editor) {
          var scope = this.$getScope(editor);
          var scopes = [scope];
          var snippetMap = this.snippetMap;
          if (snippetMap[scope] && snippetMap[scope].includeScopes) {
            scopes.push.apply(scopes, snippetMap[scope].includeScopes);
          }
          scopes.push("_");
          return scopes;
        };
        this.expandWithTab = function (editor, options) {
          var self = this;
          var result = editor.forEachSelection(function () {
            return self.expandSnippetForSelection(editor, options);
          }, null, {
            keepOrder: true
          });
          if (result && editor.tabstopManager) editor.tabstopManager.tabNext();
          return result;
        };
        this.expandSnippetForSelection = function (editor, options) {
          var cursor = editor.getCursorPosition();
          var line = editor.session.getLine(cursor.row);
          var before = line.substring(0, cursor.column);
          var after = line.substr(cursor.column);
          var snippetMap = this.snippetMap;
          var snippet;
          this.getActiveScopes(editor).some(function (scope) {
            var snippets = snippetMap[scope];
            if (snippets) snippet = this.findMatchingSnippet(snippets, before, after);
            return !!snippet;
          }, this);
          if (!snippet) return false;
          if (options && options.dryRun) return true;
          editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
          this.variables.M__ = snippet.matchBefore;
          this.variables.T__ = snippet.matchAfter;
          this.insertSnippetForSelection(editor, snippet.content);
          this.variables.M__ = this.variables.T__ = null;
          return true;
        };
        this.findMatchingSnippet = function (snippetList, before, after) {
          for (var i = snippetList.length; i--;) {
            var s = snippetList[i];
            if (s.startRe && !s.startRe.test(before)) continue;
            if (s.endRe && !s.endRe.test(after)) continue;
            if (!s.startRe && !s.endRe) continue;
            s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
            s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
            return s;
          }
        };
        this.snippetMap = {};
        this.snippetNameMap = {};
        this.register = function (snippets, scope) {
          var snippetMap = this.snippetMap;
          var snippetNameMap = this.snippetNameMap;
          var self = this;
          if (!snippets) snippets = [];
          function wrapRegexp(src) {
            if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src)) src = "(?:" + src + ")";
            return src || "";
          }
          function guardedRegexp(re, guard, opening) {
            re = wrapRegexp(re);
            guard = wrapRegexp(guard);
            if (opening) {
              re = guard + re;
              if (re && re[re.length - 1] != "$") re = re + "$";
            } else {
              re = re + guard;
              if (re && re[0] != "^") re = "^" + re;
            }
            return new RegExp(re);
          }
          function addSnippet(s) {
            if (!s.scope) s.scope = scope || "_";
            scope = s.scope;
            if (!snippetMap[scope]) {
              snippetMap[scope] = [];
              snippetNameMap[scope] = {};
            }
            var map = snippetNameMap[scope];
            if (s.name) {
              var old = map[s.name];
              if (old) self.unregister(old);
              map[s.name] = s;
            }
            snippetMap[scope].push(s);
            if (s.tabTrigger && !s.trigger) {
              if (!s.guard && /^\w/.test(s.tabTrigger)) s.guard = "\\b";
              s.trigger = lang.escapeRegExp(s.tabTrigger);
            }
            if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard) return;
            s.startRe = guardedRegexp(s.trigger, s.guard, true);
            s.triggerRe = new RegExp(s.trigger, "", true);
            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
            s.endTriggerRe = new RegExp(s.endTrigger, "", true);
          }
          if (snippets && snippets.content) addSnippet(snippets);else if (Array.isArray(snippets)) snippets.forEach(addSnippet);
          this._signal("registerSnippets", {
            scope: scope
          });
        };
        this.unregister = function (snippets, scope) {
          var snippetMap = this.snippetMap;
          var snippetNameMap = this.snippetNameMap;
          function removeSnippet(s) {
            var nameMap = snippetNameMap[s.scope || scope];
            if (nameMap && nameMap[s.name]) {
              delete nameMap[s.name];
              var map = snippetMap[s.scope || scope];
              var i = map && map.indexOf(s);
              if (i >= 0) map.splice(i, 1);
            }
          }
          if (snippets.content) removeSnippet(snippets);else if (Array.isArray(snippets)) snippets.forEach(removeSnippet);
        };
        this.parseSnippetFile = function (str) {
          str = str.replace(/\r/g, "");
          var list = [],
            snippet = {};
          var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
          var m;
          while (m = re.exec(str)) {
            if (m[1]) {
              try {
                snippet = JSON.parse(m[1]);
                list.push(snippet);
              } catch (e) {}
            }
            if (m[4]) {
              snippet.content = m[4].replace(/^\t/gm, "");
              list.push(snippet);
              snippet = {};
            } else {
              var key = m[2],
                val = m[3];
              if (key == "regex") {
                var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                snippet.guard = guardRe.exec(val)[1];
                snippet.trigger = guardRe.exec(val)[1];
                snippet.endTrigger = guardRe.exec(val)[1];
                snippet.endGuard = guardRe.exec(val)[1];
              } else if (key == "snippet") {
                snippet.tabTrigger = val.match(/^\S*/)[0];
                if (!snippet.name) snippet.name = val;
              } else {
                snippet[key] = val;
              }
            }
          }
          return list;
        };
        this.getSnippetByName = function (name, editor) {
          var snippetMap = this.snippetNameMap;
          var snippet;
          this.getActiveScopes(editor).some(function (scope) {
            var snippets = snippetMap[scope];
            if (snippets) snippet = snippets[name];
            return !!snippet;
          }, this);
          return snippet;
        };
      }).call(SnippetManager.prototype);
      var TabstopManager = function TabstopManager(editor) {
        if (editor.tabstopManager) return editor.tabstopManager;
        editor.tabstopManager = this;
        this.$onChange = this.onChange.bind(this);
        this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
        this.$onChangeSession = this.onChangeSession.bind(this);
        this.$onAfterExec = this.onAfterExec.bind(this);
        this.attach(editor);
      };
      (function () {
        this.attach = function (editor) {
          this.index = 0;
          this.ranges = [];
          this.tabstops = [];
          this.$openTabstops = null;
          this.selectedTabstop = null;
          this.editor = editor;
          this.editor.on("change", this.$onChange);
          this.editor.on("changeSelection", this.$onChangeSelection);
          this.editor.on("changeSession", this.$onChangeSession);
          this.editor.commands.on("afterExec", this.$onAfterExec);
          this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        };
        this.detach = function () {
          this.tabstops.forEach(this.removeTabstopMarkers, this);
          this.ranges = null;
          this.tabstops = null;
          this.selectedTabstop = null;
          this.editor.removeListener("change", this.$onChange);
          this.editor.removeListener("changeSelection", this.$onChangeSelection);
          this.editor.removeListener("changeSession", this.$onChangeSession);
          this.editor.commands.removeListener("afterExec", this.$onAfterExec);
          this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
          this.editor.tabstopManager = null;
          this.editor = null;
        };
        this.onChange = function (delta) {
          var changeRange = delta;
          var isRemove = delta.action[0] == "r";
          var start = delta.start;
          var end = delta.end;
          var startRow = start.row;
          var endRow = end.row;
          var lineDif = endRow - startRow;
          var colDiff = end.column - start.column;
          if (isRemove) {
            lineDif = -lineDif;
            colDiff = -colDiff;
          }
          if (!this.$inChange && isRemove) {
            var ts = this.selectedTabstop;
            var changedOutside = ts && !ts.some(function (r) {
              return comparePoints(r.start, start) <= 0 && comparePoints(r.end, end) >= 0;
            });
            if (changedOutside) return this.detach();
          }
          var ranges = this.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var r = ranges[i];
            if (r.end.row < start.row) continue;
            if (isRemove && comparePoints(start, r.start) < 0 && comparePoints(end, r.end) > 0) {
              this.removeRange(r);
              i--;
              continue;
            }
            if (r.start.row == startRow && r.start.column > start.column) r.start.column += colDiff;
            if (r.end.row == startRow && r.end.column >= start.column) r.end.column += colDiff;
            if (r.start.row >= startRow) r.start.row += lineDif;
            if (r.end.row >= startRow) r.end.row += lineDif;
            if (comparePoints(r.start, r.end) > 0) this.removeRange(r);
          }
          if (!ranges.length) this.detach();
        };
        this.updateLinkedFields = function () {
          var ts = this.selectedTabstop;
          if (!ts || !ts.hasLinkedRanges) return;
          this.$inChange = true;
          var session = this.editor.session;
          var text = session.getTextRange(ts.firstNonLinked);
          for (var i = ts.length; i--;) {
            var range = ts[i];
            if (!range.linked) continue;
            var fmt = exports.snippetManager.tmStrFormat(text, range.original);
            session.replace(range, fmt);
          }
          this.$inChange = false;
        };
        this.onAfterExec = function (e) {
          if (e.command && !e.command.readOnly) this.updateLinkedFields();
        };
        this.onChangeSelection = function () {
          if (!this.editor) return;
          var lead = this.editor.selection.lead;
          var anchor = this.editor.selection.anchor;
          var isEmpty = this.editor.selection.isEmpty();
          for (var i = this.ranges.length; i--;) {
            if (this.ranges[i].linked) continue;
            var containsLead = this.ranges[i].contains(lead.row, lead.column);
            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
            if (containsLead && containsAnchor) return;
          }
          this.detach();
        };
        this.onChangeSession = function () {
          this.detach();
        };
        this.tabNext = function (dir) {
          var max = this.tabstops.length;
          var index = this.index + (dir || 1);
          index = Math.min(Math.max(index, 1), max);
          if (index == max) index = 0;
          this.selectTabstop(index);
          if (index === 0) this.detach();
        };
        this.selectTabstop = function (index) {
          this.$openTabstops = null;
          var ts = this.tabstops[this.index];
          if (ts) this.addTabstopMarkers(ts);
          this.index = index;
          ts = this.tabstops[this.index];
          if (!ts || !ts.length) return;
          this.selectedTabstop = ts;
          if (!this.editor.inVirtualSelectionMode) {
            var sel = this.editor.multiSelect;
            sel.toSingleRange(ts.firstNonLinked.clone());
            for (var i = ts.length; i--;) {
              if (ts.hasLinkedRanges && ts[i].linked) continue;
              sel.addRange(ts[i].clone(), true);
            }
            if (sel.ranges[0]) sel.addRange(sel.ranges[0].clone());
          } else {
            this.editor.selection.setRange(ts.firstNonLinked);
          }
          this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        };
        this.addTabstops = function (tabstops, start, end) {
          if (!this.$openTabstops) this.$openTabstops = [];
          if (!tabstops[0]) {
            var p = Range.fromPoints(end, end);
            moveRelative(p.start, start);
            moveRelative(p.end, start);
            tabstops[0] = [p];
            tabstops[0].index = 0;
          }
          var i = this.index;
          var arg = [i + 1, 0];
          var ranges = this.ranges;
          tabstops.forEach(function (ts, index) {
            var dest = this.$openTabstops[index] || ts;
            for (var i = ts.length; i--;) {
              var p = ts[i];
              var range = Range.fromPoints(p.start, p.end || p.start);
              movePoint(range.start, start);
              movePoint(range.end, start);
              range.original = p;
              range.tabstop = dest;
              ranges.push(range);
              if (dest != ts) dest.unshift(range);else dest[i] = range;
              if (p.fmtString) {
                range.linked = true;
                dest.hasLinkedRanges = true;
              } else if (!dest.firstNonLinked) dest.firstNonLinked = range;
            }
            if (!dest.firstNonLinked) dest.hasLinkedRanges = false;
            if (dest === ts) {
              arg.push(dest);
              this.$openTabstops[index] = dest;
            }
            this.addTabstopMarkers(dest);
          }, this);
          if (arg.length > 2) {
            if (this.tabstops.length) arg.push(arg.splice(2, 1)[0]);
            this.tabstops.splice.apply(this.tabstops, arg);
          }
        };
        this.addTabstopMarkers = function (ts) {
          var session = this.editor.session;
          ts.forEach(function (range) {
            if (!range.markerId) range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
          });
        };
        this.removeTabstopMarkers = function (ts) {
          var session = this.editor.session;
          ts.forEach(function (range) {
            session.removeMarker(range.markerId);
            range.markerId = null;
          });
        };
        this.removeRange = function (range) {
          var i = range.tabstop.indexOf(range);
          range.tabstop.splice(i, 1);
          i = this.ranges.indexOf(range);
          this.ranges.splice(i, 1);
          this.editor.session.removeMarker(range.markerId);
          if (!range.tabstop.length) {
            i = this.tabstops.indexOf(range.tabstop);
            if (i != -1) this.tabstops.splice(i, 1);
            if (!this.tabstops.length) this.detach();
          }
        };
        this.keyboardHandler = new HashHandler();
        this.keyboardHandler.bindKeys({
          "Tab": function Tab(ed) {
            if (exports.snippetManager && exports.snippetManager.expandWithTab(ed)) {
              return;
            }
            ed.tabstopManager.tabNext(1);
          },
          "Shift-Tab": function ShiftTab(ed) {
            ed.tabstopManager.tabNext(-1);
          },
          "Esc": function Esc(ed) {
            ed.tabstopManager.detach();
          },
          "Return": function Return(ed) {
            return false;
          }
        });
      }).call(TabstopManager.prototype);
      var changeTracker = {};
      changeTracker.onChange = Anchor.prototype.onChange;
      changeTracker.setPosition = function (row, column) {
        this.pos.row = row;
        this.pos.column = column;
      };
      changeTracker.update = function (pos, delta, $insertRight) {
        this.$insertRight = $insertRight;
        this.pos = pos;
        this.onChange(delta);
      };
      var movePoint = function movePoint(point, diff) {
        if (point.row == 0) point.column += diff.column;
        point.row += diff.row;
      };
      var moveRelative = function moveRelative(point, start) {
        if (point.row == start.row) point.column -= start.column;
        point.row -= start.row;
      };
      acequire("./lib/dom").importCssString("\
.ace_snippet-marker {\
    -moz-box-sizing: border-box;\
    box-sizing: border-box;\
    background: rgba(194, 193, 208, 0.09);\
    border: 1px dotted rgba(211, 208, 235, 0.62);\
    position: absolute;\
}");
      exports.snippetManager = new SnippetManager();
      var Editor = acequire("./editor").Editor;
      (function () {
        this.insertSnippet = function (content, options) {
          return exports.snippetManager.insertSnippet(this, content, options);
        };
        this.expandSnippet = function (options) {
          return exports.snippetManager.expandWithTab(this, options);
        };
      }).call(Editor.prototype);
    });
    ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      var Renderer = acequire("../virtual_renderer").VirtualRenderer;
      var Editor = acequire("../editor").Editor;
      var Range = acequire("../range").Range;
      var event = acequire("../lib/event");
      var lang = acequire("../lib/lang");
      var dom = acequire("../lib/dom");
      var $singleLineEditor = function $singleLineEditor(el) {
        var renderer = new Renderer(el);
        renderer.$maxLines = 4;
        var editor = new Editor(renderer);
        editor.setHighlightActiveLine(false);
        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);
        editor.$mouseHandler.$focusWaitTimout = 0;
        editor.$highlightTagPending = true;
        return editor;
      };
      var AcePopup = function AcePopup(parentNode) {
        var el = dom.createElement("div");
        var popup = new $singleLineEditor(el);
        if (parentNode) parentNode.appendChild(el);
        el.style.display = "none";
        popup.renderer.content.style.cursor = "default";
        popup.renderer.setStyle("ace_autocomplete");
        popup.setOption("displayIndentGuides", false);
        popup.setOption("dragDelay", 150);
        var noop = function noop() {};
        popup.focus = noop;
        popup.$isFocused = true;
        popup.renderer.$cursorLayer.restartTimer = noop;
        popup.renderer.$cursorLayer.element.style.opacity = 0;
        popup.renderer.$maxLines = 8;
        popup.renderer.$keepTextAreaAtCursor = false;
        popup.setHighlightActiveLine(false);
        popup.session.highlight("");
        popup.session.$searchHighlight.clazz = "ace_highlight-marker";
        popup.on("mousedown", function (e) {
          var pos = e.getDocumentPosition();
          popup.selection.moveToPosition(pos);
          selectionMarker.start.row = selectionMarker.end.row = pos.row;
          e.stop();
        });
        var lastMouseEvent;
        var hoverMarker = new Range(-1, 0, -1, Infinity);
        var selectionMarker = new Range(-1, 0, -1, Infinity);
        selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
        popup.setSelectOnHover = function (val) {
          if (!val) {
            hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
          } else if (hoverMarker.id) {
            popup.session.removeMarker(hoverMarker.id);
            hoverMarker.id = null;
          }
        };
        popup.setSelectOnHover(false);
        popup.on("mousemove", function (e) {
          if (!lastMouseEvent) {
            lastMouseEvent = e;
            return;
          }
          if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
            return;
          }
          lastMouseEvent = e;
          lastMouseEvent.scrollTop = popup.renderer.scrollTop;
          var row = lastMouseEvent.getDocumentPosition().row;
          if (hoverMarker.start.row != row) {
            if (!hoverMarker.id) popup.setRow(row);
            setHoverMarker(row);
          }
        });
        popup.renderer.on("beforeRender", function () {
          if (lastMouseEvent && hoverMarker.start.row != -1) {
            lastMouseEvent.$pos = null;
            var row = lastMouseEvent.getDocumentPosition().row;
            if (!hoverMarker.id) popup.setRow(row);
            setHoverMarker(row, true);
          }
        });
        popup.renderer.on("afterRender", function () {
          var row = popup.getRow();
          var t = popup.renderer.$textLayer;
          var selected = t.element.childNodes[row - t.config.firstRow];
          if (selected == t.selectedNode) return;
          if (t.selectedNode) dom.removeCssClass(t.selectedNode, "ace_selected");
          t.selectedNode = selected;
          if (selected) dom.addCssClass(selected, "ace_selected");
        });
        var hideHoverMarker = function hideHoverMarker() {
          setHoverMarker(-1);
        };
        var setHoverMarker = function setHoverMarker(row, suppressRedraw) {
          if (row !== hoverMarker.start.row) {
            hoverMarker.start.row = hoverMarker.end.row = row;
            if (!suppressRedraw) popup.session._emit("changeBackMarker");
            popup._emit("changeHoverMarker");
          }
        };
        popup.getHoveredRow = function () {
          return hoverMarker.start.row;
        };
        event.addListener(popup.container, "mouseout", hideHoverMarker);
        popup.on("hide", hideHoverMarker);
        popup.on("changeSelection", hideHoverMarker);
        popup.session.doc.getLength = function () {
          return popup.data.length;
        };
        popup.session.doc.getLine = function (i) {
          var data = popup.data[i];
          if (typeof data == "string") return data;
          return data && data.value || "";
        };
        var bgTokenizer = popup.session.bgTokenizer;
        bgTokenizer.$tokenizeRow = function (row) {
          var data = popup.data[row];
          var tokens = [];
          if (!data) return tokens;
          if (typeof data == "string") data = {
            value: data
          };
          if (!data.caption) data.caption = data.value || data.name;
          var last = -1;
          var flag, c;
          for (var i = 0; i < data.caption.length; i++) {
            c = data.caption[i];
            flag = data.matchMask & 1 << i ? 1 : 0;
            if (last !== flag) {
              tokens.push({
                type: data.className || "" + (flag ? "completion-highlight" : ""),
                value: c
              });
              last = flag;
            } else {
              tokens[tokens.length - 1].value += c;
            }
          }
          if (data.meta) {
            var maxW = popup.renderer.$size.scrollerWidth / popup.renderer.layerConfig.characterWidth;
            var metaData = data.meta;
            if (metaData.length + data.caption.length > maxW - 2) {
              metaData = metaData.substr(0, maxW - data.caption.length - 3) + "\u2026";
            }
            tokens.push({
              type: "rightAlignedText",
              value: metaData
            });
          }
          return tokens;
        };
        bgTokenizer.$updateOnChange = noop;
        bgTokenizer.start = noop;
        popup.session.$computeWidth = function () {
          return this.screenWidth = 0;
        };
        popup.$blockScrolling = Infinity;
        popup.isOpen = false;
        popup.isTopdown = false;
        popup.autoSelect = true;
        popup.data = [];
        popup.setData = function (list) {
          popup.setValue(lang.stringRepeat("\n", list.length), -1);
          popup.data = list || [];
          popup.setRow(0);
        };
        popup.getData = function (row) {
          return popup.data[row];
        };
        popup.getRow = function () {
          return selectionMarker.start.row;
        };
        popup.setRow = function (line) {
          line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length, line));
          if (selectionMarker.start.row != line) {
            popup.selection.clearSelection();
            selectionMarker.start.row = selectionMarker.end.row = line || 0;
            popup.session._emit("changeBackMarker");
            popup.moveCursorTo(line || 0, 0);
            if (popup.isOpen) popup._signal("select");
          }
        };
        popup.on("changeSelection", function () {
          if (popup.isOpen) popup.setRow(popup.selection.lead.row);
          popup.renderer.scrollCursorIntoView();
        });
        popup.hide = function () {
          this.container.style.display = "none";
          this._signal("hide");
          popup.isOpen = false;
        };
        popup.show = function (pos, lineHeight, topdownOnly) {
          var el = this.container;
          var screenHeight = window.innerHeight;
          var screenWidth = window.innerWidth;
          var renderer = this.renderer;
          var maxH = renderer.$maxLines * lineHeight * 1.4;
          var top = pos.top + this.$borderSize;
          var allowTopdown = top > screenHeight / 2 && !topdownOnly;
          if (allowTopdown && top + lineHeight + maxH > screenHeight) {
            renderer.$maxPixelHeight = top - 2 * this.$borderSize;
            el.style.top = "";
            el.style.bottom = screenHeight - top + "px";
            popup.isTopdown = false;
          } else {
            top += lineHeight;
            renderer.$maxPixelHeight = screenHeight - top - 0.2 * lineHeight;
            el.style.top = top + "px";
            el.style.bottom = "";
            popup.isTopdown = true;
          }
          el.style.display = "";
          this.renderer.$textLayer.checkForSizeChanges();
          var left = pos.left;
          if (left + el.offsetWidth > screenWidth) left = screenWidth - el.offsetWidth;
          el.style.left = left + "px";
          this._signal("show");
          lastMouseEvent = null;
          popup.isOpen = true;
        };
        popup.getTextLeftOffset = function () {
          return this.$borderSize + this.renderer.$padding + this.$imageSize;
        };
        popup.$imageSize = 0;
        popup.$borderSize = 1;
        return popup;
      };
      dom.importCssString("\
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\
    background-color: #CAD6FA;\
    z-index: 1;\
}\
.ace_editor.ace_autocomplete .ace_line-hover {\
    border: 1px solid #abbffe;\
    margin-top: -1px;\
    background: rgba(233,233,253,0.4);\
}\
.ace_editor.ace_autocomplete .ace_line-hover {\
    position: absolute;\
    z-index: 2;\
}\
.ace_editor.ace_autocomplete .ace_scroller {\
   background: none;\
   border: none;\
   box-shadow: none;\
}\
.ace_rightAlignedText {\
    color: gray;\
    display: inline-block;\
    position: absolute;\
    right: 4px;\
    text-align: right;\
    z-index: -1;\
}\
.ace_editor.ace_autocomplete .ace_completion-highlight{\
    color: #000;\
    text-shadow: 0 0 0.01em;\
}\
.ace_editor.ace_autocomplete {\
    width: 280px;\
    z-index: 200000;\
    background: #fbfbfb;\
    color: #444;\
    border: 1px lightgray solid;\
    position: fixed;\
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\
    line-height: 1.4;\
}");
      exports.AcePopup = AcePopup;
    });
    ace.define("ace/autocomplete/util", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      exports.parForEach = function (array, fn, callback) {
        var completed = 0;
        var arLength = array.length;
        if (arLength === 0) callback();
        for (var i = 0; i < arLength; i++) {
          fn(array[i], function (result, err) {
            completed++;
            if (completed === arLength) callback(result, err);
          });
        }
      };
      var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\uFFFF]/;
      exports.retrievePrecedingIdentifier = function (text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos - 1; i >= 0; i--) {
          if (regex.test(text[i])) buf.push(text[i]);else break;
        }
        return buf.reverse().join("");
      };
      exports.retrieveFollowingIdentifier = function (text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos; i < text.length; i++) {
          if (regex.test(text[i])) buf.push(text[i]);else break;
        }
        return buf;
      };
      exports.getCompletionPrefix = function (editor) {
        var pos = editor.getCursorPosition();
        var line = editor.session.getLine(pos.row);
        var prefix;
        editor.completers.forEach(function (completer) {
          if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function (identifierRegex) {
              if (!prefix && identifierRegex) prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
          }
        }.bind(this));
        return prefix || this.retrievePrecedingIdentifier(line, pos.column);
      };
    });
    ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/snippets"], function (acequire, exports, module) {
      "use strict";

      var HashHandler = acequire("./keyboard/hash_handler").HashHandler;
      var AcePopup = acequire("./autocomplete/popup").AcePopup;
      var util = acequire("./autocomplete/util");
      var event = acequire("./lib/event");
      var lang = acequire("./lib/lang");
      var dom = acequire("./lib/dom");
      var snippetManager = acequire("./snippets").snippetManager;
      var Autocomplete = function Autocomplete() {
        this.autoInsert = false;
        this.autoSelect = true;
        this.exactMatch = false;
        this.gatherCompletionsId = 0;
        this.keyboardHandler = new HashHandler();
        this.keyboardHandler.bindKeys(this.commands);
        this.blurListener = this.blurListener.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.mousedownListener = this.mousedownListener.bind(this);
        this.mousewheelListener = this.mousewheelListener.bind(this);
        this.changeTimer = lang.delayedCall(function () {
          this.updateCompletions(true);
        }.bind(this));
        this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
      };
      (function () {
        this.$init = function () {
          this.popup = new AcePopup(document.body || document.documentElement);
          this.popup.on("click", function (e) {
            this.insertMatch();
            e.stop();
          }.bind(this));
          this.popup.focus = this.editor.focus.bind(this.editor);
          this.popup.on("show", this.tooltipTimer.bind(null, null));
          this.popup.on("select", this.tooltipTimer.bind(null, null));
          this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
          return this.popup;
        };
        this.getPopup = function () {
          return this.popup || this.$init();
        };
        this.openPopup = function (editor, prefix, keepPopupPosition) {
          if (!this.popup) this.$init();
          this.popup.autoSelect = this.autoSelect;
          this.popup.setData(this.completions.filtered);
          editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
          var renderer = editor.renderer;
          this.popup.setRow(this.autoSelect ? 0 : -1);
          if (!keepPopupPosition) {
            this.popup.setTheme(editor.getTheme());
            this.popup.setFontSize(editor.getFontSize());
            var lineHeight = renderer.layerConfig.lineHeight;
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.gutterWidth;
            this.popup.show(pos, lineHeight);
          } else if (keepPopupPosition && !prefix) {
            this.detach();
          }
        };
        this.detach = function () {
          this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
          this.editor.off("changeSelection", this.changeListener);
          this.editor.off("blur", this.blurListener);
          this.editor.off("mousedown", this.mousedownListener);
          this.editor.off("mousewheel", this.mousewheelListener);
          this.changeTimer.cancel();
          this.hideDocTooltip();
          this.gatherCompletionsId += 1;
          if (this.popup && this.popup.isOpen) this.popup.hide();
          if (this.base) this.base.detach();
          this.activated = false;
          this.completions = this.base = null;
        };
        this.changeListener = function (e) {
          var cursor = this.editor.selection.lead;
          if (cursor.row != this.base.row || cursor.column < this.base.column) {
            this.detach();
          }
          if (this.activated) this.changeTimer.schedule();else this.detach();
        };
        this.blurListener = function (e) {
          var el = document.activeElement;
          var text = this.editor.textInput.getElement();
          var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
          var container = this.popup && this.popup.container;
          if (el != text && el.parentNode != container && !fromTooltip && el != this.tooltipNode && e.relatedTarget != text) {
            this.detach();
          }
        };
        this.mousedownListener = function (e) {
          this.detach();
        };
        this.mousewheelListener = function (e) {
          this.detach();
        };
        this.goTo = function (where) {
          var row = this.popup.getRow();
          var max = this.popup.session.getLength() - 1;
          switch (where) {
            case "up":
              row = row <= 0 ? max : row - 1;
              break;
            case "down":
              row = row >= max ? -1 : row + 1;
              break;
            case "start":
              row = 0;
              break;
            case "end":
              row = max;
              break;
          }
          this.popup.setRow(row);
        };
        this.insertMatch = function (data, options) {
          if (!data) data = this.popup.getData(this.popup.getRow());
          if (!data) return false;
          if (data.completer && data.completer.insertMatch) {
            data.completer.insertMatch(this.editor, data);
          } else {
            if (this.completions.filterText) {
              var ranges = this.editor.selection.getAllRanges();
              for (var i = 0, range; range = ranges[i]; i++) {
                range.start.column -= this.completions.filterText.length;
                this.editor.session.remove(range);
              }
            }
            if (data.snippet) snippetManager.insertSnippet(this.editor, data.snippet);else this.editor.execCommand("insertstring", data.value || data);
          }
          this.detach();
        };
        this.commands = {
          "Up": function Up(editor) {
            editor.completer.goTo("up");
          },
          "Down": function Down(editor) {
            editor.completer.goTo("down");
          },
          "Ctrl-Up|Ctrl-Home": function CtrlUpCtrlHome(editor) {
            editor.completer.goTo("start");
          },
          "Ctrl-Down|Ctrl-End": function CtrlDownCtrlEnd(editor) {
            editor.completer.goTo("end");
          },
          "Esc": function Esc(editor) {
            editor.completer.detach();
          },
          "Return": function Return(editor) {
            return editor.completer.insertMatch();
          },
          "Shift-Return": function ShiftReturn(editor) {
            editor.completer.insertMatch(null, {
              deleteSuffix: true
            });
          },
          "Tab": function Tab(editor) {
            var result = editor.completer.insertMatch();
            if (!result && !editor.tabstopManager) editor.completer.goTo("down");else return result;
          },
          "PageUp": function PageUp(editor) {
            editor.completer.popup.gotoPageUp();
          },
          "PageDown": function PageDown(editor) {
            editor.completer.popup.gotoPageDown();
          }
        };
        this.gatherCompletions = function (editor, callback) {
          var session = editor.getSession();
          var pos = editor.getCursorPosition();
          var prefix = util.getCompletionPrefix(editor);
          this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
          this.base.$insertRight = true;
          var matches = [];
          var total = editor.completers.length;
          editor.completers.forEach(function (completer, i) {
            completer.getCompletions(editor, session, pos, prefix, function (err, results) {
              if (!err && results) matches = matches.concat(results);
              callback(null, {
                prefix: util.getCompletionPrefix(editor),
                matches: matches,
                finished: --total === 0
              });
            });
          });
          return true;
        };
        this.showPopup = function (editor) {
          if (this.editor) this.detach();
          this.activated = true;
          this.editor = editor;
          if (editor.completer != this) {
            if (editor.completer) editor.completer.detach();
            editor.completer = this;
          }
          editor.on("changeSelection", this.changeListener);
          editor.on("blur", this.blurListener);
          editor.on("mousedown", this.mousedownListener);
          editor.on("mousewheel", this.mousewheelListener);
          this.updateCompletions();
        };
        this.updateCompletions = function (keepPopupPosition) {
          if (keepPopupPosition && this.base && this.completions) {
            var pos = this.editor.getCursorPosition();
            var prefix = this.editor.session.getTextRange({
              start: this.base,
              end: pos
            });
            if (prefix == this.completions.filterText) return;
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length) return this.detach();
            if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == prefix && !this.completions.filtered[0].snippet) return this.detach();
            this.openPopup(this.editor, prefix, keepPopupPosition);
            return;
          }
          var _id = this.gatherCompletionsId;
          this.gatherCompletions(this.editor, function (err, results) {
            var detachIfFinished = function () {
              if (!results.finished) return;
              return this.detach();
            }.bind(this);
            var prefix = results.prefix;
            var matches = results && results.matches;
            if (!matches || !matches.length) return detachIfFinished();
            if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId) return;
            this.completions = new FilteredList(matches);
            if (this.exactMatch) this.completions.exactMatch = true;
            this.completions.setFilter(prefix);
            var filtered = this.completions.filtered;
            if (!filtered.length) return detachIfFinished();
            if (filtered.length == 1 && filtered[0].value == prefix && !filtered[0].snippet) return detachIfFinished();
            if (this.autoInsert && filtered.length == 1 && results.finished) return this.insertMatch(filtered[0]);
            this.openPopup(this.editor, prefix, keepPopupPosition);
          }.bind(this));
        };
        this.cancelContextMenu = function () {
          this.editor.$mouseHandler.cancelContextMenu();
        };
        this.updateDocTooltip = function () {
          var popup = this.popup;
          var all = popup.data;
          var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
          var doc = null;
          if (!selected || !this.editor || !this.popup.isOpen) return this.hideDocTooltip();
          this.editor.completers.some(function (completer) {
            if (completer.getDocTooltip) doc = completer.getDocTooltip(selected);
            return doc;
          });
          if (!doc) doc = selected;
          if (typeof doc == "string") doc = {
            docText: doc
          };
          if (!doc || !(doc.docHTML || doc.docText)) return this.hideDocTooltip();
          this.showDocTooltip(doc);
        };
        this.showDocTooltip = function (item) {
          if (!this.tooltipNode) {
            this.tooltipNode = dom.createElement("div");
            this.tooltipNode.className = "ace_tooltip ace_doc-tooltip";
            this.tooltipNode.style.margin = 0;
            this.tooltipNode.style.pointerEvents = "auto";
            this.tooltipNode.tabIndex = -1;
            this.tooltipNode.onblur = this.blurListener.bind(this);
            this.tooltipNode.onclick = this.onTooltipClick.bind(this);
          }
          var tooltipNode = this.tooltipNode;
          if (item.docHTML) {
            tooltipNode.innerHTML = item.docHTML;
          } else if (item.docText) {
            tooltipNode.textContent = item.docText;
          }
          if (!tooltipNode.parentNode) document.body.appendChild(tooltipNode);
          var popup = this.popup;
          var rect = popup.container.getBoundingClientRect();
          tooltipNode.style.top = popup.container.style.top;
          tooltipNode.style.bottom = popup.container.style.bottom;
          if (window.innerWidth - rect.right < 320) {
            tooltipNode.style.right = window.innerWidth - rect.left + "px";
            tooltipNode.style.left = "";
          } else {
            tooltipNode.style.left = rect.right + 1 + "px";
            tooltipNode.style.right = "";
          }
          tooltipNode.style.display = "block";
        };
        this.hideDocTooltip = function () {
          this.tooltipTimer.cancel();
          if (!this.tooltipNode) return;
          var el = this.tooltipNode;
          if (!this.editor.isFocused() && document.activeElement == el) this.editor.focus();
          this.tooltipNode = null;
          if (el.parentNode) el.parentNode.removeChild(el);
        };
        this.onTooltipClick = function (e) {
          var a = e.target;
          while (a && a != this.tooltipNode) {
            if (a.nodeName == "A" && a.href) {
              a.rel = "noreferrer";
              a.target = "_blank";
              break;
            }
            a = a.parentNode;
          }
        };
      }).call(Autocomplete.prototype);
      Autocomplete.startCommand = {
        name: "startAutocomplete",
        exec: function exec(editor) {
          if (!editor.completer) editor.completer = new Autocomplete();
          editor.completer.autoInsert = false;
          editor.completer.autoSelect = true;
          editor.completer.showPopup(editor);
          editor.completer.cancelContextMenu();
        },
        bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
      };
      var FilteredList = function FilteredList(array, filterText) {
        this.all = array;
        this.filtered = array;
        this.filterText = filterText || "";
        this.exactMatch = false;
      };
      (function () {
        this.setFilter = function (str) {
          if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0) var matches = this.filtered;else var matches = this.all;
          this.filterText = str;
          matches = this.filterCompletions(matches, this.filterText);
          matches = matches.sort(function (a, b) {
            return b.exactMatch - a.exactMatch || b.score - a.score;
          });
          var prev = null;
          matches = matches.filter(function (item) {
            var caption = item.snippet || item.caption || item.value;
            if (caption === prev) return false;
            prev = caption;
            return true;
          });
          this.filtered = matches;
        };
        this.filterCompletions = function (items, needle) {
          var results = [];
          var upper = needle.toUpperCase();
          var lower = needle.toLowerCase();
          loop: for (var i = 0, item; item = items[i]; i++) {
            var caption = item.value || item.caption || item.snippet;
            if (!caption) continue;
            var lastIndex = -1;
            var matchMask = 0;
            var penalty = 0;
            var index, distance;
            if (this.exactMatch) {
              if (needle !== caption.substr(0, needle.length)) continue loop;
            } else {
              for (var j = 0; j < needle.length; j++) {
                var i1 = caption.indexOf(lower[j], lastIndex + 1);
                var i2 = caption.indexOf(upper[j], lastIndex + 1);
                index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                if (index < 0) continue loop;
                distance = index - lastIndex - 1;
                if (distance > 0) {
                  if (lastIndex === -1) penalty += 10;
                  penalty += distance;
                }
                matchMask = matchMask | 1 << index;
                lastIndex = index;
              }
            }
            item.matchMask = matchMask;
            item.exactMatch = penalty ? 0 : 1;
            item.score = (item.score || 0) - penalty;
            results.push(item);
          }
          return results;
        };
      }).call(FilteredList.prototype);
      exports.Autocomplete = Autocomplete;
      exports.FilteredList = FilteredList;
    });
    ace.define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      var Range = acequire("../range").Range;
      var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
      function getWordIndex(doc, pos) {
        var textBefore = doc.getTextRange(Range.fromPoints({
          row: 0,
          column: 0
        }, pos));
        return textBefore.split(splitRegex).length - 1;
      }
      function wordDistance(doc, pos) {
        var prefixPos = getWordIndex(doc, pos);
        var words = doc.getValue().split(splitRegex);
        var wordScores = Object.create(null);
        var currentWord = words[prefixPos];
        words.forEach(function (word, idx) {
          if (!word || word === currentWord) return;
          var distance = Math.abs(prefixPos - idx);
          var score = words.length - distance;
          if (wordScores[word]) {
            wordScores[word] = Math.max(score, wordScores[word]);
          } else {
            wordScores[word] = score;
          }
        });
        return wordScores;
      }
      exports.getCompletions = function (editor, session, pos, prefix, callback) {
        var wordScore = wordDistance(session, pos, prefix);
        var wordList = Object.keys(wordScore);
        callback(null, wordList.map(function (word) {
          return {
            caption: word,
            value: word,
            score: wordScore[word],
            meta: "local"
          };
        }));
      };
    });
    ace.define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function (acequire, exports, module) {
      "use strict";

      var snippetManager = acequire("../snippets").snippetManager;
      var Autocomplete = acequire("../autocomplete").Autocomplete;
      var config = acequire("../config");
      var lang = acequire("../lib/lang");
      var util = acequire("../autocomplete/util");
      var textCompleter = acequire("../autocomplete/text_completer");
      var keyWordCompleter = {
        getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
          if (session.$mode.completer) {
            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
          }
          var state = editor.session.getState(pos.row);
          var completions = session.$mode.getCompletions(state, session, pos, prefix);
          callback(null, completions);
        }
      };
      var snippetCompleter = {
        getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
          var snippetMap = snippetManager.snippetMap;
          var completions = [];
          snippetManager.getActiveScopes(editor).forEach(function (scope) {
            var snippets = snippetMap[scope] || [];
            for (var i = snippets.length; i--;) {
              var s = snippets[i];
              var caption = s.name || s.tabTrigger;
              if (!caption) continue;
              completions.push({
                caption: caption,
                snippet: s.content,
                meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet",
                type: "snippet"
              });
            }
          }, this);
          callback(null, completions);
        },
        getDocTooltip: function getDocTooltip(item) {
          if (item.type == "snippet" && !item.docHTML) {
            item.docHTML = ["<b>", lang.escapeHTML(item.caption), "</b>", "<hr></hr>", lang.escapeHTML(item.snippet)].join("");
          }
        }
      };
      var completers = [snippetCompleter, textCompleter, keyWordCompleter];
      exports.setCompleters = function (val) {
        completers.length = 0;
        if (val) completers.push.apply(completers, val);
      };
      exports.addCompleter = function (completer) {
        completers.push(completer);
      };
      exports.textCompleter = textCompleter;
      exports.keyWordCompleter = keyWordCompleter;
      exports.snippetCompleter = snippetCompleter;
      var expandSnippet = {
        name: "expandSnippet",
        exec: function exec(editor) {
          return snippetManager.expandWithTab(editor);
        },
        bindKey: "Tab"
      };
      var onChangeMode = function onChangeMode(e, editor) {
        loadSnippetsForMode(editor.session.$mode);
      };
      var loadSnippetsForMode = function loadSnippetsForMode(mode) {
        var id = mode.$id;
        if (!snippetManager.files) snippetManager.files = {};
        loadSnippetFile(id);
        if (mode.modes) mode.modes.forEach(loadSnippetsForMode);
      };
      var loadSnippetFile = function loadSnippetFile(id) {
        if (!id || snippetManager.files[id]) return;
        var snippetFilePath = id.replace("mode", "snippets");
        snippetManager.files[id] = {};
        config.loadModule(snippetFilePath, function (m) {
          if (m) {
            snippetManager.files[id] = m;
            if (!m.snippets && m.snippetText) m.snippets = snippetManager.parseSnippetFile(m.snippetText);
            snippetManager.register(m.snippets || [], m.scope);
            if (m.includeScopes) {
              snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
              m.includeScopes.forEach(function (x) {
                loadSnippetFile("ace/mode/" + x);
              });
            }
          }
        });
      };
      var doLiveAutocomplete = function doLiveAutocomplete(e) {
        var editor = e.editor;
        var hasCompleter = editor.completer && editor.completer.activated;
        if (e.command.name === "backspace") {
          if (hasCompleter && !util.getCompletionPrefix(editor)) editor.completer.detach();
        } else if (e.command.name === "insertstring") {
          var prefix = util.getCompletionPrefix(editor);
          if (prefix && !hasCompleter) {
            if (!editor.completer) {
              editor.completer = new Autocomplete();
            }
            editor.completer.autoInsert = false;
            editor.completer.showPopup(editor);
          }
        }
      };
      var Editor = acequire("../editor").Editor;
      acequire("../config").defineOptions(Editor.prototype, "editor", {
        enableBasicAutocompletion: {
          set: function set(val) {
            if (val) {
              if (!this.completers) this.completers = Array.isArray(val) ? val : completers;
              this.commands.addCommand(Autocomplete.startCommand);
            } else {
              this.commands.removeCommand(Autocomplete.startCommand);
            }
          },
          value: false
        },
        enableLiveAutocompletion: {
          set: function set(val) {
            if (val) {
              if (!this.completers) this.completers = Array.isArray(val) ? val : completers;
              this.commands.on('afterExec', doLiveAutocomplete);
            } else {
              this.commands.removeListener('afterExec', doLiveAutocomplete);
            }
          },
          value: false
        },
        enableSnippets: {
          set: function set(val) {
            if (val) {
              this.commands.addCommand(expandSnippet);
              this.on("changeMode", onChangeMode);
              onChangeMode(null, this);
            } else {
              this.commands.removeCommand(expandSnippet);
              this.off("changeMode", onChangeMode);
            }
          },
          value: false
        }
      });
    });
    (function () {
      ace.acequire(["ace/ext/language_tools"], function () {});
    })();

    /***/
  },

  /***/"./node_modules/brace/index.js":
  /*!*************************************!*\
    !*** ./node_modules/brace/index.js ***!
    \*************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceIndexJs(module, exports, __webpack_require__) {
    /* ***** BEGIN LICENSE BLOCK *****
     * Distributed under the BSD license:
     *
     * Copyright (c) 2010, Ajax.org B.V.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *     * Redistributions of source code must retain the above copyright
     *       notice, this list of conditions and the following disclaimer.
     *     * Redistributions in binary form must reproduce the above copyright
     *       notice, this list of conditions and the following disclaimer in the
     *       documentation and/or other materials provided with the distribution.
     *     * Neither the name of Ajax.org B.V. nor the
     *       names of its contributors may be used to endorse or promote products
     *       derived from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * ***** END LICENSE BLOCK ***** */

    /**
     * Define a module along with a payload
     * @param module a name for the payload
     * @param payload a function to call with (acequire, exports, module) params
     */

    (function () {
      var ACE_NAMESPACE = "ace";
      var global = function () {
        return this;
      }();
      if (!global && typeof window != "undefined") global = window; // strict mode

      if (!ACE_NAMESPACE && typeof acequirejs !== "undefined") return;
      var define = function define(module, deps, payload) {
        if (typeof module !== "string") {
          if (define.original) define.original.apply(this, arguments);else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2) payload = deps;
        if (!define.modules[module]) {
          define.payloads[module] = payload;
          define.modules[module] = null;
        }
      };
      define.modules = {};
      define.payloads = {};

      /**
       * Get at functionality define()ed using the function above
       */
      var _acequire = function _acequire(parentId, module, callback) {
        if (typeof module === "string") {
          var payload = lookup(parentId, module);
          if (payload != undefined) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module) === "[object Array]") {
          var params = [];
          for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && acequire.original) return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var acequire = function acequire(module, callback) {
        var packagedModule = _acequire("", module, callback);
        if (packagedModule == undefined && acequire.original) return acequire.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function normalizeModule(parentId, moduleName) {
        // normalize plugin acequires
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        // normalize relative acequires
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };

      /**
       * Internal function to lookup moduleNames and resolve them by calling the
       * definition function if needed.
       */
      var lookup = function lookup(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module = define.modules[moduleName];
        if (!module) {
          module = define.payloads[moduleName];
          if (typeof module === 'function') {
            var exports = {};
            var mod = {
              id: moduleName,
              uri: '',
              exports: exports,
              packaged: true
            };
            var req = function req(module, callback) {
              return _acequire(moduleName, module, callback);
            };
            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
          }
          module = define.modules[moduleName] = exports || module;
        }
        return module;
      };
      function exportAce(ns) {
        var root = global;
        if (ns) {
          if (!global[ns]) global[ns] = {};
          root = global[ns];
        }
        if (!root.define || !root.define.packaged) {
          define.original = root.define;
          root.define = define;
          root.define.packaged = true;
        }
        if (!root.acequire || !root.acequire.packaged) {
          acequire.original = root.acequire;
          root.acequire = acequire;
          root.acequire.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/regexp", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var real = {
          exec: RegExp.prototype.exec,
          test: RegExp.prototype.test,
          match: String.prototype.match,
          replace: String.prototype.replace,
          split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined,
        // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
          var x = /^/g;
          real.test.call(x, "");
          return !x.lastIndex;
        }();
      if (compliantLastIndexIncrement && compliantExecNpcg) return;
      RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
          name,
          r2;
        if (typeof str == 'string' && match) {
          if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
            r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
            real.replace.call(str.slice(match.index), r2, function () {
              for (var i = 1; i < arguments.length - 2; i++) {
                if (arguments[i] === undefined) match[i] = undefined;
              }
            });
          }
          if (this._xregexp && this._xregexp.captureNames) {
            for (var i = 1; i < match.length; i++) {
              name = this._xregexp.captureNames[i - 1];
              if (name) match[name] = match[i];
            }
          }
          if (!compliantLastIndexIncrement && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
        }
        return match;
      };
      if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function (str) {
          var match = real.exec.call(this, str);
          if (match && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
          return !!match;
        };
      }
      function getNativeFlags(regex) {
        return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + (
        // Proposed for ES4; included in AS3
        regex.sticky ? "y" : "");
      }
      function indexOf(array, item, from) {
        if (Array.prototype.indexOf)
          // Use the native array method if available
          return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
          if (array[i] === item) return i;
        }
        return -1;
      }
    });
    ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (acequire, exports, module) {
      function Empty() {}
      if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
          // .length is 1
          var target = this;
          if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
          }
          var args = slice.call(arguments, 1); // for normal call
          var bound = function bound() {
            if (this instanceof bound) {
              var result = target.apply(this, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
      }
      var call = Function.prototype.call;
      var prototypeOfArray = Array.prototype;
      var prototypeOfObject = Object.prototype;
      var slice = prototypeOfArray.slice;
      var _toString = call.bind(prototypeOfObject.toString);
      var owns = call.bind(prototypeOfObject.hasOwnProperty);
      var defineGetter;
      var defineSetter;
      var lookupGetter;
      var lookupSetter;
      var supportsAccessors;
      if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
      }
      if ([1, 2].splice(0).length != 2) {
        if (function () {
          // test IE < 9 to splice bug - see issue #138
          function makeArray(l) {
            var a = new Array(l + 2);
            a[0] = a[1] = 0;
            return a;
          }
          var array = [],
            lengthBefore;
          array.splice.apply(array, makeArray(20));
          array.splice.apply(array, makeArray(26));
          lengthBefore = array.length; //46
          array.splice(5, 0, "XXX"); // add one element

          lengthBefore + 1 == array.length;
          if (lengthBefore + 1 == array.length) {
            return true; // has right splice implementation without bugs
          }
        }()) {
          //IE 6/7
          var array_splice = Array.prototype.splice;
          Array.prototype.splice = function (start, deleteCount) {
            if (!arguments.length) {
              return [];
            } else {
              return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? this.length - start : deleteCount].concat(slice.call(arguments, 2)));
            }
          };
        } else {
          //IE8
          Array.prototype.splice = function (pos, removeCount) {
            var length = this.length;
            if (pos > 0) {
              if (pos > length) pos = length;
            } else if (pos == void 0) {
              pos = 0;
            } else if (pos < 0) {
              pos = Math.max(length + pos, 0);
            }
            if (!(pos + removeCount < length)) removeCount = length - pos;
            var removed = this.slice(pos, pos + removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;
            if (pos === length) {
              if (add) {
                this.push.apply(this, insert);
              }
            } else {
              var remove = Math.min(removeCount, length - pos);
              var tailOldPos = pos + remove;
              var tailNewPos = tailOldPos + add - remove;
              var tailCount = length - tailOldPos;
              var lengthAfterRemove = length - remove;
              if (tailNewPos < tailOldPos) {
                // case A
                for (var i = 0; i < tailCount; ++i) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              } else if (tailNewPos > tailOldPos) {
                // case B
                for (i = tailCount; i--;) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              } // else, add == remove (nothing to do)

              if (add && pos === lengthAfterRemove) {
                this.length = lengthAfterRemove; // truncate array
                this.push.apply(this, insert);
              } else {
                this.length = lengthAfterRemove + add; // reserves space
                for (i = 0; i < add; ++i) {
                  this[pos + i] = insert[i];
                }
              }
            }
            return removed;
          };
        }
      }
      if (!Array.isArray) {
        Array.isArray = function isArray(obj) {
          return _toString(obj) == "[object Array]";
        };
      }
      var boxedString = Object("a"),
        splitString = boxedString[0] != "a" || !(0 in boxedString);
      if (!Array.prototype.forEach) {
        Array.prototype.forEach = function forEach(fun /*, thisp*/) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
          }

          while (++i < length) {
            if (i in self) {
              fun.call(thisp, self[i], i, object);
            }
          }
        };
      }
      if (!Array.prototype.map) {
        Array.prototype.map = function map(fun /*, thisp*/) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self) result[i] = fun.call(thisp, self[i], i, object);
          }
          return result;
        };
      }
      if (!Array.prototype.filter) {
        Array.prototype.filter = function filter(fun /*, thisp */) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self) {
              value = self[i];
              if (fun.call(thisp, value, i, object)) {
                result.push(value);
              }
            }
          }
          return result;
        };
      }
      if (!Array.prototype.every) {
        Array.prototype.every = function every(fun /*, thisp */) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            length = self.length >>> 0,
            thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
              return false;
            }
          }
          return true;
        };
      }
      if (!Array.prototype.some) {
        Array.prototype.some = function some(fun /*, thisp */) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            length = self.length >>> 0,
            thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
              return true;
            }
          }
          return false;
        };
      }
      if (!Array.prototype.reduce) {
        Array.prototype.reduce = function reduce(fun /*, initial*/) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
          }
          var i = 0;
          var result;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i++];
                break;
              }
              if (++i >= length) {
                throw new TypeError("reduce of empty array with no initial value");
              }
            } while (true);
          }
          for (; i < length; i++) {
            if (i in self) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          }
          return result;
        };
      }
      if (!Array.prototype.reduceRight) {
        Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
          var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
            length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }
          var result,
            i = length - 1;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i--];
                break;
              }
              if (--i < 0) {
                throw new TypeError("reduceRight of empty array with no initial value");
              }
            } while (true);
          }
          do {
            if (i in this) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          } while (i--);
          return result;
        };
      }
      if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
        Array.prototype.indexOf = function indexOf(sought /*, fromIndex */) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
            length = self.length >>> 0;
          if (!length) {
            return -1;
          }
          var i = 0;
          if (arguments.length > 1) {
            i = toInteger(arguments[1]);
          }
          i = i >= 0 ? i : Math.max(0, length + i);
          for (; i < length; i++) {
            if (i in self && self[i] === sought) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
        Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
            length = self.length >>> 0;
          if (!length) {
            return -1;
          }
          var i = length - 1;
          if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
          }
          i = i >= 0 ? i : length - Math.abs(i);
          for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Object.getPrototypeOf) {
        Object.getPrototypeOf = function getPrototypeOf(object) {
          return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
        };
      }
      if (!Object.getOwnPropertyDescriptor) {
        var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
          if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT + object);
          if (!owns(object, property)) return;
          var descriptor, getter, setter;
          descriptor = {
            enumerable: true,
            configurable: true
          };
          if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;
            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;
            if (getter || setter) {
              if (getter) descriptor.get = getter;
              if (setter) descriptor.set = setter;
              return descriptor;
            }
          }
          descriptor.value = object[property];
          return descriptor;
        };
      }
      if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
          return Object.keys(object);
        };
      }
      if (!Object.create) {
        var createEmpty;
        if (Object.prototype.__proto__ === null) {
          createEmpty = function createEmpty() {
            return {
              "__proto__": null
            };
          };
        } else {
          createEmpty = function createEmpty() {
            var empty = {};
            for (var i in empty) empty[i] = null;
            empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
            return empty;
          };
        }
        Object.create = function create(prototype, properties) {
          var object;
          if (prototype === null) {
            object = createEmpty();
          } else {
            if (typeof prototype != "object") throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
            var Type = function Type() {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
          }
          if (properties !== void 0) Object.defineProperties(object, properties);
          return object;
        };
      }
      function doesDefinePropertyWork(object) {
        try {
          Object.defineProperty(object, "sentinel", {});
          return "sentinel" in object;
        } catch (exception) {}
      }
      if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
          var definePropertyFallback = Object.defineProperty;
        }
      }
      if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
        var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
        var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";
        Object.defineProperty = function defineProperty(object, property, descriptor) {
          if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT_TARGET + object);
          if (typeof descriptor != "object" && typeof descriptor != "function" || descriptor === null) throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
          if (definePropertyFallback) {
            try {
              return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {}
          }
          if (owns(descriptor, "value")) {
            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
              var prototype = object.__proto__;
              object.__proto__ = prototypeOfObject;
              delete object[property];
              object[property] = descriptor.value;
              object.__proto__ = prototype;
            } else {
              object[property] = descriptor.value;
            }
          } else {
            if (!supportsAccessors) throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get")) defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set")) defineSetter(object, property, descriptor.set);
          }
          return object;
        };
      }
      if (!Object.defineProperties) {
        Object.defineProperties = function defineProperties(object, properties) {
          for (var property in properties) {
            if (owns(properties, property)) Object.defineProperty(object, property, properties[property]);
          }
          return object;
        };
      }
      if (!Object.seal) {
        Object.seal = function seal(object) {
          return object;
        };
      }
      if (!Object.freeze) {
        Object.freeze = function freeze(object) {
          return object;
        };
      }
      try {
        Object.freeze(function () {});
      } catch (exception) {
        Object.freeze = function freeze(freezeObject) {
          return function freeze(object) {
            if (typeof object == "function") {
              return object;
            } else {
              return freezeObject(object);
            }
          };
        }(Object.freeze);
      }
      if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
          return object;
        };
      }
      if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
          return false;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
          return false;
        };
      }
      if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
          if (Object(object) === object) {
            throw new TypeError(); // TODO message
          }

          var name = '';
          while (owns(object, name)) {
            name += '?';
          }
          object[name] = true;
          var returnValue = owns(object, name);
          delete object[name];
          return returnValue;
        };
      }
      if (!Object.keys) {
        var hasDontEnumBug = true,
          dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
          dontEnumsLength = dontEnums.length;
        for (var key in {
          "toString": null
        }) {
          hasDontEnumBug = false;
        }
        Object.keys = function keys(object) {
          if (typeof object != "object" && typeof object != "function" || object === null) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var keys = [];
          for (var name in object) {
            if (owns(object, name)) {
              keys.push(name);
            }
          }
          if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
              var dontEnum = dontEnums[i];
              if (owns(object, dontEnum)) {
                keys.push(dontEnum);
              }
            }
          }
          return keys;
        };
      }
      if (!Date.now) {
        Date.now = function now() {
          return new Date().getTime();
        };
      }
      var ws = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
      if (!String.prototype.trim || ws.trim()) {
        ws = "[" + ws + "]";
        var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
          trimEndRegexp = new RegExp(ws + ws + "*$");
        String.prototype.trim = function trim() {
          return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        };
      }
      function toInteger(n) {
        n = +n;
        if (n !== n) {
          // isNaN
          n = 0;
        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
      }
      function isPrimitive(input) {
        var type = typeof input;
        return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
      }
      function toPrimitive(input) {
        var val, valueOf, toString;
        if (isPrimitive(input)) {
          return input;
        }
        valueOf = input.valueOf;
        if (typeof valueOf === "function") {
          val = valueOf.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        toString = input.toString;
        if (typeof toString === "function") {
          val = toString.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        throw new TypeError();
      }
      var toObject = function toObject(o) {
        if (o == null) {
          // this matches both null and undefined
          throw new TypeError("can't convert " + o + " to object");
        }
        return Object(o);
      };
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function (acequire, exports, module) {
      "use strict";

      acequire("./regexp");
      acequire("./es5-shim");
    });
    ace.define("ace/lib/dom", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports.getDocumentHead = function (doc) {
        if (!doc) doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports.createElement = function (tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports.hasCssClass = function (el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports.addCssClass = function (el, name) {
        if (!exports.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports.removeCssClass = function (el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports.toggleCssClass = function (el, name) {
        var classes = el.className.split(/\s+/g),
          add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add) classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports.setCssClass = function (node, className, include) {
        if (include) {
          exports.addCssClass(node, className);
        } else {
          exports.removeCssClass(node, className);
        }
      };
      exports.hasCssString = function (id, doc) {
        var index = 0,
          sheets;
        doc = doc || document;
        if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
          while (index < sheets.length) if (sheets[index++].owningElement.id === id) return true;
        } else if (sheets = doc.getElementsByTagName("style")) {
          while (index < sheets.length) if (sheets[index++].id === id) return true;
        }
        return false;
      };
      exports.importCssString = function importCssString(cssText, id, doc) {
        doc = doc || document;
        if (id && exports.hasCssString(id, doc)) return null;
        var style;
        if (id) cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        if (doc.createStyleSheet) {
          style = doc.createStyleSheet();
          style.cssText = cssText;
          if (id) style.owningElement.id = id;
        } else {
          style = exports.createElement("style");
          style.appendChild(doc.createTextNode(cssText));
          if (id) style.id = id;
          exports.getDocumentHead(doc).appendChild(style);
        }
      };
      exports.importCssStylsheet = function (uri, doc) {
        if (doc.createStyleSheet) {
          doc.createStyleSheet(uri);
        } else {
          var link = exports.createElement('link');
          link.rel = 'stylesheet';
          link.href = uri;
          exports.getDocumentHead(doc).appendChild(link);
        }
      };
      exports.getInnerWidth = function (element) {
        return parseInt(exports.computedStyle(element, "paddingLeft"), 10) + parseInt(exports.computedStyle(element, "paddingRight"), 10) + element.clientWidth;
      };
      exports.getInnerHeight = function (element) {
        return parseInt(exports.computedStyle(element, "paddingTop"), 10) + parseInt(exports.computedStyle(element, "paddingBottom"), 10) + element.clientHeight;
      };
      exports.scrollbarWidth = function (document) {
        var inner = exports.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = document.documentElement;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar == withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      if (typeof document == "undefined") {
        exports.importCssString = function () {};
        return;
      }
      if (window.pageYOffset !== undefined) {
        exports.getPageScrollTop = function () {
          return window.pageYOffset;
        };
        exports.getPageScrollLeft = function () {
          return window.pageXOffset;
        };
      } else {
        exports.getPageScrollTop = function () {
          return document.body.scrollTop;
        };
        exports.getPageScrollLeft = function () {
          return document.body.scrollLeft;
        };
      }
      if (window.getComputedStyle) exports.computedStyle = function (element, style) {
        if (style) return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
      };else exports.computedStyle = function (element, style) {
        if (style) return element.currentStyle[style];
        return element.currentStyle;
      };
      exports.setInnerHtml = function (el, innerHtml) {
        var element = el.cloneNode(false); //document.createElement("div");
        element.innerHTML = innerHtml;
        el.parentNode.replaceChild(element, el);
        return element;
      };
      if ("textContent" in document.documentElement) {
        exports.setInnerText = function (el, innerText) {
          el.textContent = innerText;
        };
        exports.getInnerText = function (el) {
          return el.textContent;
        };
      } else {
        exports.setInnerText = function (el, innerText) {
          el.innerText = innerText;
        };
        exports.getInnerText = function (el) {
          return el.innerText;
        };
      }
      exports.getParentWindow = function (document) {
        return document.defaultView || document.parentWindow;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      exports.inherits = function (ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
      exports.mixin = function (obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports.implement = function (proto, mixin) {
        exports.mixin(proto, mixin);
      };
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function (acequire, exports, module) {
      "use strict";

      acequire("./fixoldbrowsers");
      var oop = acequire("./oop");
      var Keys = function () {
        var ret = {
          MODIFIER_KEYS: {
            16: 'Shift',
            17: 'Ctrl',
            18: 'Alt',
            224: 'Meta'
          },
          KEY_MODS: {
            "ctrl": 1,
            "alt": 2,
            "option": 2,
            "shift": 4,
            "super": 8,
            "meta": 8,
            "command": 8,
            "cmd": 8
          },
          FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            96: "Numpad0",
            97: "Numpad1",
            98: "Numpad2",
            99: "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
          },
          PRINTABLE_KEYS: {
            32: ' ',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            59: ';',
            61: '=',
            65: 'a',
            66: 'b',
            67: 'c',
            68: 'd',
            69: 'e',
            70: 'f',
            71: 'g',
            72: 'h',
            73: 'i',
            74: 'j',
            75: 'k',
            76: 'l',
            77: 'm',
            78: 'n',
            79: 'o',
            80: 'p',
            81: 'q',
            82: 'r',
            83: 's',
            84: 't',
            85: 'u',
            86: 'v',
            87: 'w',
            88: 'x',
            89: 'y',
            90: 'z',
            107: '+',
            109: '-',
            110: '.',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: "'",
            111: '/',
            106: '*'
          }
        };
        var name, i;
        for (i in ret.FUNCTION_KEYS) {
          name = ret.FUNCTION_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        for (i in ret.PRINTABLE_KEYS) {
          name = ret.PRINTABLE_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        ret[173] = '-';
        (function () {
          var mods = ["cmd", "ctrl", "alt", "shift"];
          for (var i = Math.pow(2, mods.length); i--;) {
            ret.KEY_MODS[i] = mods.filter(function (x) {
              return i & ret.KEY_MODS[x];
            }).join("-") + "-";
          }
        })();
        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input-";
        return ret;
      }();
      oop.mixin(exports, Keys);
      exports.keyCodeToString = function (keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string") keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      exports.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports.getOS = function () {
        if (exports.isMac) {
          return exports.OS.MAC;
        } else if (exports.isLinux) {
          return exports.OS.LINUX;
        } else {
          return exports.OS.WINDOWS;
        }
      };
      if (typeof navigator != "object") return;
      var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
      var ua = navigator.userAgent;
      exports.isWin = os == "win";
      exports.isMac = os == "mac";
      exports.isLinux = os == "linux";
      exports.isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie

      exports.isOldIE = exports.isIE && exports.isIE < 9;
      exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
      exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/) || [])[1], 10) < 4;
      exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
      exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
      exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
      exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports.isIPad = ua.indexOf("iPad") >= 0;
      exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
      if (exports.isIOS) exports.isMac = true;
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (acequire, exports, module) {
      "use strict";

      var keys = acequire("./keys");
      var useragent = acequire("./useragent");
      var pressedKeys = null;
      var ts = 0;
      exports.addListener = function (elem, type, callback) {
        if (elem.addEventListener) {
          return elem.addEventListener(type, callback, false);
        }
        if (elem.attachEvent) {
          var wrapper = function wrapper() {
            callback.call(elem, window.event);
          };
          callback._wrapper = wrapper;
          elem.attachEvent("on" + type, wrapper);
        }
      };
      exports.removeListener = function (elem, type, callback) {
        if (elem.removeEventListener) {
          return elem.removeEventListener(type, callback, false);
        }
        if (elem.detachEvent) {
          elem.detachEvent("on" + type, callback._wrapper || callback);
        }
      };
      exports.stopEvent = function (e) {
        exports.stopPropagation(e);
        exports.preventDefault(e);
        return false;
      };
      exports.stopPropagation = function (e) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
      };
      exports.preventDefault = function (e) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      };
      exports.getButton = function (e) {
        if (e.type == "dblclick") return 0;
        if (e.type == "contextmenu" || useragent.isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
        if (e.preventDefault) {
          return e.button;
        } else {
          return {
            1: 0,
            2: 2,
            4: 1
          }[e.button];
        }
      };
      exports.capture = function (el, eventHandler, releaseCaptureHandler) {
        function onMouseUp(e) {
          eventHandler && eventHandler(e);
          releaseCaptureHandler && releaseCaptureHandler(e);
          exports.removeListener(document, "mousemove", eventHandler, true);
          exports.removeListener(document, "mouseup", onMouseUp, true);
          exports.removeListener(document, "dragstart", onMouseUp, true);
        }
        exports.addListener(document, "mousemove", eventHandler, true);
        exports.addListener(document, "mouseup", onMouseUp, true);
        exports.addListener(document, "dragstart", onMouseUp, true);
        return onMouseUp;
      };
      exports.addTouchMoveListener = function (el, callback) {
        var startx, starty;
        exports.addListener(el, "touchstart", function (e) {
          var touches = e.touches;
          var touchObj = touches[0];
          startx = touchObj.clientX;
          starty = touchObj.clientY;
        });
        exports.addListener(el, "touchmove", function (e) {
          var touches = e.touches;
          if (touches.length > 1) return;
          var touchObj = touches[0];
          e.wheelX = startx - touchObj.clientX;
          e.wheelY = starty - touchObj.clientY;
          startx = touchObj.clientX;
          starty = touchObj.clientY;
          callback(e);
        });
      };
      exports.addMouseWheelListener = function (el, callback) {
        if ("onmousewheel" in el) {
          exports.addListener(el, "mousewheel", function (e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
              e.wheelX = -e.wheelDeltaX / factor;
              e.wheelY = -e.wheelDeltaY / factor;
            } else {
              e.wheelX = 0;
              e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
          });
        } else if ("onwheel" in el) {
          exports.addListener(el, "wheel", function (e) {
            var factor = 0.35;
            switch (e.deltaMode) {
              case e.DOM_DELTA_PIXEL:
                e.wheelX = e.deltaX * factor || 0;
                e.wheelY = e.deltaY * factor || 0;
                break;
              case e.DOM_DELTA_LINE:
              case e.DOM_DELTA_PAGE:
                e.wheelX = (e.deltaX || 0) * 5;
                e.wheelY = (e.deltaY || 0) * 5;
                break;
            }
            callback(e);
          });
        } else {
          exports.addListener(el, "DOMMouseScroll", function (e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
              e.wheelX = (e.detail || 0) * 5;
              e.wheelY = 0;
            } else {
              e.wheelX = 0;
              e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
          });
        }
      };
      exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e) {
          if (exports.getButton(e) !== 0) {
            clicks = 0;
          } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4) clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick) clicks = 1;
            if (timer) clearTimeout(timer);
            timer = setTimeout(function () {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e.clientX;
              startY = e.clientY;
            }
          }
          e._clicks = clicks;
          eventHandler[callbackName]("mousedown", e);
          if (clicks > 4) clicks = 0;else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
        }
        function onDblclick(e) {
          clicks = 2;
          if (timer) clearTimeout(timer);
          timer = setTimeout(function () {
            timer = null;
          }, timeouts[clicks - 1] || 600);
          eventHandler[callbackName]("mousedown", e);
          eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements)) elements = [elements];
        elements.forEach(function (el) {
          exports.addListener(el, "mousedown", onMousedown);
          if (useragent.isOldIE) exports.addListener(el, "dblclick", onDblclick);
        });
      };
      var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function (e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
      } : function (e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
      };
      exports.getModifierString = function (e) {
        return keys.KEY_MODS[getModifierHash(e)];
      };
      function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!useragent.isMac && pressedKeys) {
          if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win"))) hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3) pressedKeys.altGr = 0;else return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
              if (pressedKeys[keyCode] == 1) ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
              var dt = e.timeStamp - ts;
              if (dt < 50) pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (hashId & 8 && keyCode >= 91 && keyCode <= 93) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          var location = "location" in e ? e.location : e.keyLocation;
          if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented) return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e, hashId, keyCode);
          if (e.defaultPrevented) return;else hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e, hashId, keyCode);
      }
      exports.addCommandKeyListener = function (el, callback) {
        var addListener = exports.addListener;
        if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
          var lastKeyDownKeyCode = null;
          addListener(el, "keydown", function (e) {
            lastKeyDownKeyCode = e.keyCode;
          });
          addListener(el, "keypress", function (e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
          });
        } else {
          var lastDefaultPrevented = null;
          addListener(el, "keydown", function (e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
          });
          addListener(el, "keypress", function (e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
              exports.stopEvent(e);
              lastDefaultPrevented = null;
            }
          });
          addListener(el, "keyup", function (e) {
            pressedKeys[e.keyCode] = null;
          });
          if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
          }
        }
      };
      function resetPressedKeys() {
        pressedKeys = Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports.nextTick = function (callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId;
          exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
              exports.stopPropagation(e);
              exports.removeListener(win, "message", listener);
              callback();
            }
          });
          win.postMessage(messageName, "*");
        };
      }
      exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
      if (exports.nextFrame) exports.nextFrame = exports.nextFrame.bind(window);else exports.nextFrame = function (callback) {
        setTimeout(callback, 17);
      };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      exports.last = function (a) {
        return a[a.length - 1];
      };
      exports.stringReverse = function (string) {
        return string.split("").reverse().join("");
      };
      exports.stringRepeat = function (string, count) {
        var result = '';
        while (count > 0) {
          if (count & 1) result += string;
          if (count >>= 1) string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports.stringTrimLeft = function (string) {
        return string.replace(trimBeginRegexp, '');
      };
      exports.stringTrimRight = function (string) {
        return string.replace(trimEndRegexp, '');
      };
      exports.copyObject = function (obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports.copyArray = function (array) {
        var copy = [];
        for (var i = 0, l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
        }
        return copy;
      };
      exports.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj) return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;
        copy = {};
        for (var key in obj) copy[key] = deepCopy(obj[key]);
        return copy;
      };
      exports.arrayToMap = function (arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };
      exports.createMap = function (props) {
        var map = Object.create(null);
        for (var i in props) {
          map[i] = props[i];
        }
        return map;
      };
      exports.arrayRemove = function (array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };
      exports.escapeRegExp = function (str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
      };
      exports.escapeHTML = function (str) {
        return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports.getMatchOffsets = function (string, regExp) {
        var matches = [];
        string.replace(regExp, function (str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches;
      };
      exports.deferredCall = function (fcn) {
        var timer = null;
        var callback = function callback() {
          timer = null;
          fcn();
        };
        var deferred = function deferred(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function () {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function () {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function () {
          return timer;
        };
        return deferred;
      };
      exports.delayedCall = function (fcn, defaultTimeout) {
        var timer = null;
        var callback = function callback() {
          timer = null;
          fcn();
        };
        var _self = function _self(timeout) {
          if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function (timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function () {
          this.cancel();
          fcn();
        };
        _self.cancel = function () {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function () {
          return timer;
        };
        return _self;
      };
    });
    ace.define("ace/keyboard/textinput_ios", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/lib/keys"], function (acequire, exports, module) {
      "use strict";

      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var KEYS = acequire("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var TextInput = function TextInput(parentNode, host) {
        var self = this;
        var text = dom.createElement("textarea");
        text.className = useragent.isIOS ? "ace_text-input ace_text-input-ios" : "ace_text-input";
        if (useragent.isTouchPad) text.setAttribute("x-palm-disable-auto-cap", true);
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        var PLACEHOLDER = "\n aaaa a\n";
        var copied = false;
        var cut = false;
        var pasted = false;
        var inComposition = false;
        var tempStyle = '';
        var isSelectionEmpty = true;
        try {
          var isFocused = document.activeElement === text;
        } catch (e) {}
        event.addListener(text, "blur", function (e) {
          host.onBlur(e);
          isFocused = false;
        });
        event.addListener(text, "focus", function (e) {
          isFocused = true;
          host.onFocus(e);
          resetSelection();
        });
        this.focus = function () {
          if (tempStyle) return text.focus();
          text.style.position = "fixed";
          text.focus();
        };
        this.blur = function () {
          text.blur();
        };
        this.isFocused = function () {
          return isFocused;
        };
        var syncSelection = lang.delayedCall(function () {
          isFocused && resetSelection(isSelectionEmpty);
        });
        var syncValue = lang.delayedCall(function () {
          if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
          }
        });
        function resetSelection(isEmpty) {
          if (inComposition) return;
          inComposition = true;
          if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
          } else {
            var selectionStart = 4;
            var selectionEnd = 5;
          }
          try {
            text.setSelectionRange(selectionStart, selectionEnd);
          } catch (e) {}
          inComposition = false;
        }
        function resetValue() {
          if (inComposition) return;
          text.value = PLACEHOLDER;
          if (useragent.isWebKit) syncValue.schedule();
        }
        useragent.isWebKit || host.addEventListener('changeSelection', function () {
          if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
          }
        });
        resetValue();
        if (isFocused) host.onFocus();
        var isAllSelected = function isAllSelected(text) {
          return text.selectionStart === 0 && text.selectionEnd === text.value.length;
        };
        var onSelect = function onSelect(e) {
          if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
          }
        };
        var inputHandler = null;
        this.setInputHandler = function (cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function () {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function sendText(data) {
          if (text.selectionStart === 4 && text.selectionEnd === 5) {
            return;
          }
          if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
          }
          if (pasted) {
            resetSelection();
            if (data) host.onPaste(data);
            pasted = false;
          } else if (data == PLACEHOLDER.substr(0) && text.selectionStart === 4) {
            if (afterContextMenu) host.execCommand("del", {
              source: "ace"
            });else
              // some versions of android do not fire keydown when pressing backspace
              host.execCommand("backspace", {
                source: "ace"
              });
          } else if (!copied) {
            if (data.substring(0, 9) == PLACEHOLDER && data.length > PLACEHOLDER.length) data = data.substr(9);else if (data.substr(0, 4) == PLACEHOLDER.substr(0, 4)) data = data.substr(4, data.length - PLACEHOLDER.length + 1);else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
            if (data == PLACEHOLDER.charAt(0)) {} else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
            if (data) host.onTextInput(data);
          }
          if (copied) {
            copied = false;
          }
          if (afterContextMenu) afterContextMenu = false;
        };
        var onInput = function onInput(e) {
          if (inComposition) return;
          var data = text.value;
          sendText(data);
          resetValue();
        };
        var handleClipboardData = function handleClipboardData(e, data, forceIEMime) {
          var clipboardData = e.clipboardData || window.clipboardData;
          if (!clipboardData || BROKEN_SETDATA) return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e) {
            if (!forceIEMime) return handleClipboardData(e, data, true);
          }
        };
        var doCopy = function doCopy(e, isCut) {
          var data = host.getCopyText();
          if (!data) return event.preventDefault(e);
          if (handleClipboardData(e, data)) {
            if (useragent.isIOS) {
              cut = isCut;
              text.value = "\n aa" + data + "a a\n";
              text.setSelectionRange(4, 4 + data.length);
              copied = {
                value: data
              };
            }
            isCut ? host.onCut() : host.onCopy();
            if (!useragent.isIOS) event.preventDefault(e);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function () {
              copied = false;
              resetValue();
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function onCut(e) {
          doCopy(e, true);
        };
        var onCopy = function onCopy(e) {
          doCopy(e, false);
        };
        var onPaste = function onPaste(e) {
          var data = handleClipboardData(e);
          if (typeof data == "string") {
            if (data) host.onPaste(data, e);
            if (useragent.isIE) setTimeout(resetSelection);
            event.preventDefault(e);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, host.onCommandKey.bind(host));
        event.addListener(text, "select", onSelect);
        event.addListener(text, "input", onInput);
        event.addListener(text, "cut", onCut);
        event.addListener(text, "copy", onCopy);
        event.addListener(text, "paste", onPaste);
        var onCompositionStart = function onCompositionStart(e) {
          if (inComposition || !host.onCompositionStart || host.$readOnly) return;
          inComposition = {};
          inComposition.canUndo = host.session.$undoManager;
          host.onCompositionStart();
          setTimeout(onCompositionUpdate, 0);
          host.on("mousedown", onCompositionEnd);
          if (inComposition.canUndo && !host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
          }
          host.session.markUndoGroup();
        };
        var onCompositionUpdate = function onCompositionUpdate() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
          var val = text.value.replace(/\x01/g, "");
          if (inComposition.lastValue === val) return;
          host.onCompositionUpdate(val);
          if (inComposition.lastValue) host.undo();
          if (inComposition.canUndo) inComposition.lastValue = val;
          if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
          }
        };
        var onCompositionEnd = function onCompositionEnd(e) {
          if (!host.onCompositionEnd || host.$readOnly) return;
          var c = inComposition;
          inComposition = false;
          var timer = setTimeout(function () {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition) return;else if (str == c.lastValue) resetValue();else if (!c.lastValue && str) {
              resetValue();
              sendText(str);
            }
          });
          inputHandler = function compositionInputHandler(str) {
            if (timer) clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue) return "";
            if (c.lastValue && timer) host.undo();
            return str;
          };
          host.onCompositionEnd();
          host.removeListener("mousedown", onCompositionEnd);
          if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
          }
          var needsOnInput = !!useragent.isChrome && useragent.isChrome >= 53 || !!useragent.isWebKit && useragent.isWebKit >= 603;
          if (needsOnInput) {
            onInput();
          }
        };
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
        event.addListener(text, "compositionstart", onCompositionStart);
        if (useragent.isGecko) {
          event.addListener(text, "text", function () {
            syncComposition.schedule();
          });
        } else {
          event.addListener(text, "keyup", function () {
            syncComposition.schedule();
          });
          event.addListener(text, "keydown", function () {
            syncComposition.schedule();
          });
        }
        event.addListener(text, "compositionend", onCompositionEnd);
        this.getElement = function () {
          return text;
        };
        this.setReadOnly = function (readOnly) {
          text.readOnly = readOnly;
        };
        this.onContextMenu = function (e) {
          afterContextMenu = true;
          resetSelection(host.selection.isEmpty());
          host._emit("nativecontextmenu", {
            target: host,
            domEvent: e
          });
          this.moveToMouse(e, true);
        };
        this.moveToMouse = function (e, bringToFront) {
          if (!tempStyle) tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function move(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
          };
          move(e);
          if (e.type != "mousedown") return;
          if (host.renderer.$keepTextAreaAtCursor) host.renderer.$keepTextAreaAtCursor = null;
          clearTimeout(closeTimeout);
          if (useragent.isWin) event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function () {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
              host.renderer.$keepTextAreaAtCursor = true;
              host.renderer.$moveTextAreaToCursor();
            }
          }, 0);
        }
        var onContextMenu = function onContextMenu(e) {
          host.textInput.onContextMenu(e);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu);
        event.addListener(text, "mousedown", function (e) {
          e.preventDefault();
          onContextMenuClose();
        });
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
        event.addListener(text, "contextmenu", onContextMenu);
        if (useragent.isIOS) {
          var typingResetTimeout = null;
          var typing = false;
          parentNode.addEventListener("keydown", function (e) {
            if (typingResetTimeout) clearTimeout(typingResetTimeout);
            typing = true;
          });
          parentNode.addEventListener("keyup", function (e) {
            typingResetTimeout = setTimeout(function () {
              typing = false;
            }, 100);
          });
          var detectArrowKeys = function detectArrowKeys(e) {
            if (document.activeElement !== text) return;
            if (typing) return;
            if (cut) {
              return setTimeout(function () {
                cut = false;
              }, 100);
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            text.setSelectionRange(4, 5);
            if (selectionStart == selectionEnd) {
              switch (selectionStart) {
                case 0:
                  host.onCommandKey(null, 0, KEYS.up);
                  break;
                case 1:
                  host.onCommandKey(null, 0, KEYS.home);
                  break;
                case 2:
                  host.onCommandKey(null, MODS.option, KEYS.left);
                  break;
                case 4:
                  host.onCommandKey(null, 0, KEYS.left);
                  break;
                case 5:
                  host.onCommandKey(null, 0, KEYS.right);
                  break;
                case 7:
                  host.onCommandKey(null, MODS.option, KEYS.right);
                  break;
                case 8:
                  host.onCommandKey(null, 0, KEYS.end);
                  break;
                case 9:
                  host.onCommandKey(null, 0, KEYS.down);
                  break;
              }
            } else {
              switch (selectionEnd) {
                case 6:
                  host.onCommandKey(null, MODS.shift, KEYS.right);
                  break;
                case 7:
                  host.onCommandKey(null, MODS.shift | MODS.option, KEYS.right);
                  break;
                case 8:
                  host.onCommandKey(null, MODS.shift, KEYS.end);
                  break;
                case 9:
                  host.onCommandKey(null, MODS.shift, KEYS.down);
                  break;
              }
              switch (selectionStart) {
                case 0:
                  host.onCommandKey(null, MODS.shift, KEYS.up);
                  break;
                case 1:
                  host.onCommandKey(null, MODS.shift, KEYS.home);
                  break;
                case 2:
                  host.onCommandKey(null, MODS.shift | MODS.option, KEYS.left);
                  break;
                case 3:
                  host.onCommandKey(null, MODS.shift, KEYS.left);
                  break;
              }
            }
          };
          document.addEventListener("selectionchange", detectArrowKeys);
          host.on("destroy", function () {
            document.removeEventListener("selectionchange", detectArrowKeys);
          });
        }
      };
      exports.TextInput = TextInput;
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/keyboard/textinput_ios"], function (acequire, exports, module) {
      "use strict";

      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var TextInputIOS = acequire("./textinput_ios").TextInput;
      var TextInput = function TextInput(parentNode, host) {
        if (useragent.isIOS) return TextInputIOS.call(this, parentNode, host);
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        var PLACEHOLDER = "\u2028\u2028";
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var tempStyle = '';
        var isSelectionEmpty = true;
        try {
          var isFocused = document.activeElement === text;
        } catch (e) {}
        event.addListener(text, "blur", function (e) {
          host.onBlur(e);
          isFocused = false;
        });
        event.addListener(text, "focus", function (e) {
          isFocused = true;
          host.onFocus(e);
          resetSelection();
        });
        this.focus = function () {
          if (tempStyle) return text.focus();
          var top = text.style.top;
          text.style.position = "fixed";
          text.style.top = "0px";
          text.focus();
          setTimeout(function () {
            text.style.position = "";
            if (text.style.top == "0px") text.style.top = top;
          }, 0);
        };
        this.blur = function () {
          text.blur();
        };
        this.isFocused = function () {
          return isFocused;
        };
        var syncSelection = lang.delayedCall(function () {
          isFocused && resetSelection(isSelectionEmpty);
        });
        var syncValue = lang.delayedCall(function () {
          if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
          }
        });
        function resetSelection(isEmpty) {
          if (inComposition) return;
          inComposition = true;
          if (inputHandler) {
            var selectionStart = 0;
            var selectionEnd = isEmpty ? 0 : text.value.length - 1;
          } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
          }
          try {
            text.setSelectionRange(selectionStart, selectionEnd);
          } catch (e) {}
          inComposition = false;
        }
        function resetValue() {
          if (inComposition) return;
          text.value = PLACEHOLDER;
          if (useragent.isWebKit) syncValue.schedule();
        }
        useragent.isWebKit || host.addEventListener('changeSelection', function () {
          if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
          }
        });
        resetValue();
        if (isFocused) host.onFocus();
        var isAllSelected = function isAllSelected(text) {
          return text.selectionStart === 0 && text.selectionEnd === text.value.length;
        };
        var onSelect = function onSelect(e) {
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
          }
        };
        var inputHandler = null;
        this.setInputHandler = function (cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function () {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function sendText(data) {
          if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
          }
          if (pasted) {
            resetSelection();
            if (data) host.onPaste(data);
            pasted = false;
          } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu) host.execCommand("del", {
              source: "ace"
            });else
              // some versions of android do not fire keydown when pressing backspace
              host.execCommand("backspace", {
                source: "ace"
              });
          } else {
            if (data.substring(0, 2) == PLACEHOLDER) data = data.substr(2);else if (data.charAt(0) == PLACEHOLDER.charAt(0)) data = data.substr(1);else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
            if (data) host.onTextInput(data);
          }
          if (afterContextMenu) afterContextMenu = false;
        };
        var onInput = function onInput(e) {
          if (inComposition) return;
          var data = text.value;
          sendText(data);
          resetValue();
        };
        var handleClipboardData = function handleClipboardData(e, data, forceIEMime) {
          var clipboardData = e.clipboardData || window.clipboardData;
          if (!clipboardData || BROKEN_SETDATA) return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e) {
            if (!forceIEMime) return handleClipboardData(e, data, true);
          }
        };
        var doCopy = function doCopy(e, isCut) {
          var data = host.getCopyText();
          if (!data) return event.preventDefault(e);
          if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function () {
              copied = false;
              resetValue();
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function onCut(e) {
          doCopy(e, true);
        };
        var onCopy = function onCopy(e) {
          doCopy(e, false);
        };
        var onPaste = function onPaste(e) {
          var data = handleClipboardData(e);
          if (typeof data == "string") {
            if (data) host.onPaste(data, e);
            if (useragent.isIE) setTimeout(resetSelection);
            event.preventDefault(e);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, host.onCommandKey.bind(host));
        event.addListener(text, "select", onSelect);
        event.addListener(text, "input", onInput);
        event.addListener(text, "cut", onCut);
        event.addListener(text, "copy", onCopy);
        event.addListener(text, "paste", onPaste);
        if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
          event.addListener(parentNode, "keydown", function (e) {
            if (useragent.isMac && !e.metaKey || !e.ctrlKey) return;
            switch (e.keyCode) {
              case 67:
                onCopy(e);
                break;
              case 86:
                onPaste(e);
                break;
              case 88:
                onCut(e);
                break;
            }
          });
        }
        var onCompositionStart = function onCompositionStart(e) {
          if (inComposition || !host.onCompositionStart || host.$readOnly) return;
          inComposition = {};
          inComposition.canUndo = host.session.$undoManager;
          host.onCompositionStart();
          setTimeout(onCompositionUpdate, 0);
          host.on("mousedown", onCompositionEnd);
          if (inComposition.canUndo && !host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
          }
          host.session.markUndoGroup();
        };
        var onCompositionUpdate = function onCompositionUpdate() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
          var val = text.value.replace(/\u2028/g, "");
          if (inComposition.lastValue === val) return;
          host.onCompositionUpdate(val);
          if (inComposition.lastValue) host.undo();
          if (inComposition.canUndo) inComposition.lastValue = val;
          if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
          }
        };
        var onCompositionEnd = function onCompositionEnd(e) {
          if (!host.onCompositionEnd || host.$readOnly) return;
          var c = inComposition;
          inComposition = false;
          var timer = setTimeout(function () {
            timer = null;
            var str = text.value.replace(/\u2028/g, "");
            if (inComposition) return;else if (str == c.lastValue) resetValue();else if (!c.lastValue && str) {
              resetValue();
              sendText(str);
            }
          });
          inputHandler = function compositionInputHandler(str) {
            if (timer) clearTimeout(timer);
            str = str.replace(/\u2028/g, "");
            if (str == c.lastValue) return "";
            if (c.lastValue && timer) host.undo();
            return str;
          };
          host.onCompositionEnd();
          host.removeListener("mousedown", onCompositionEnd);
          if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
          }
          var needsOnInput = !!useragent.isChrome && useragent.isChrome >= 53 || !!useragent.isWebKit && useragent.isWebKit >= 603;
          if (needsOnInput) {
            onInput();
          }
        };
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
        event.addListener(text, "compositionstart", onCompositionStart);
        if (useragent.isGecko) {
          event.addListener(text, "text", function () {
            syncComposition.schedule();
          });
        } else {
          event.addListener(text, "keyup", function () {
            syncComposition.schedule();
          });
          event.addListener(text, "keydown", function () {
            syncComposition.schedule();
          });
        }
        event.addListener(text, "compositionend", onCompositionEnd);
        this.getElement = function () {
          return text;
        };
        this.setReadOnly = function (readOnly) {
          text.readOnly = readOnly;
        };
        this.onContextMenu = function (e) {
          afterContextMenu = true;
          resetSelection(host.selection.isEmpty());
          host._emit("nativecontextmenu", {
            target: host,
            domEvent: e
          });
          this.moveToMouse(e, true);
        };
        this.moveToMouse = function (e, bringToFront) {
          if (!tempStyle) tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function move(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
          };
          move(e);
          if (e.type != "mousedown") return;
          if (host.renderer.$keepTextAreaAtCursor) host.renderer.$keepTextAreaAtCursor = null;
          clearTimeout(closeTimeout);
          if (useragent.isWin) event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function () {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
              host.renderer.$keepTextAreaAtCursor = true;
              host.renderer.$moveTextAreaToCursor();
            }
          }, 0);
        }
        var onContextMenu = function onContextMenu(e) {
          host.textInput.onContextMenu(e);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu);
        event.addListener(text, "mousedown", function (e) {
          e.preventDefault();
          onContextMenuClose();
        });
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
        event.addListener(text, "contextmenu", onContextMenu);
      };
      exports.TextInput = TextInput;
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      "use strict";

      var dom = acequire("../lib/dom");
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var DRAG_OFFSET = 0; // pixels
      var SCROLL_COOLDOWN_T = 250; // milliseconds

      function DefaultHandlers(mouseHandler) {
        mouseHandler.$clickSelection = null;
        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
        editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));
        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
        exports.forEach(function (x) {
          mouseHandler[x] = this[x];
        }, this);
        mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
      }
      (function () {
        this.onMouseDown = function (ev) {
          var inSelection = ev.inSelection();
          var pos = ev.getDocumentPosition();
          this.mousedownEvent = ev;
          var editor = this.editor;
          var button = ev.getButton();
          if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            editor.$blockScrolling++;
            if (selectionEmpty || button == 1) editor.selection.moveToPosition(pos);
            editor.$blockScrolling--;
            if (button == 2) {
              editor.textInput.onContextMenu(ev.domEvent);
              if (!useragent.isMozilla) ev.preventDefault();
            }
            return;
          }
          this.mousedownEvent.time = Date.now();
          if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
              this.setState("focusWait");
              this.captureMouse(ev);
              return;
            }
          }
          this.captureMouse(ev);
          this.startSelect(pos, ev.domEvent._clicks > 1);
          return ev.preventDefault();
        };
        this.startSelect = function (pos, waitForClickSelection) {
          pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
          var editor = this.editor;
          editor.$blockScrolling++;
          if (this.mousedownEvent.getShiftKey()) editor.selection.selectToPosition(pos);else if (!waitForClickSelection) editor.selection.moveToPosition(pos);
          if (!waitForClickSelection) this.select();
          if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
          }
          editor.setStyle("ace_selecting");
          this.setState("select");
          editor.$blockScrolling--;
        };
        this.select = function () {
          var anchor,
            editor = this.editor;
          var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
          editor.$blockScrolling++;
          if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);
            if (cmp == -1) {
              anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
              anchor = this.$clickSelection.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor.selection.selectToPosition(cursor);
          editor.$blockScrolling--;
          editor.renderer.scrollCursorIntoView();
        };
        this.extendSelectionBy = function (unitName) {
          var anchor,
            editor = this.editor;
          var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
          var range = editor.selection[unitName](cursor.row, cursor.column);
          editor.$blockScrolling++;
          if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);
            if (cmpStart == -1 && cmpEnd <= 0) {
              anchor = this.$clickSelection.end;
              if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
              anchor = this.$clickSelection.start;
              if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
              cursor = range.end;
              anchor = range.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor.selection.selectToPosition(cursor);
          editor.$blockScrolling--;
          editor.renderer.scrollCursorIntoView();
        };
        this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function () {
          this.$clickSelection = null;
          this.editor.unsetStyle("ace_selecting");
          if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
          }
        };
        this.focusWait = function () {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          var time = Date.now();
          if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout) this.startSelect(this.mousedownEvent.getDocumentPosition());
        };
        this.onDoubleClick = function (ev) {
          var pos = ev.getDocumentPosition();
          var editor = this.editor;
          var session = editor.session;
          var range = session.getBracketRange(pos);
          if (range) {
            if (range.isEmpty()) {
              range.start.column--;
              range.end.column++;
            }
            this.setState("select");
          } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
          }
          this.$clickSelection = range;
          this.select();
        };
        this.onTripleClick = function (ev) {
          var pos = ev.getDocumentPosition();
          var editor = this.editor;
          this.setState("selectByLines");
          var range = editor.getSelectionRange();
          if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
          } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
          }
          this.select();
        };
        this.onQuadClick = function (ev) {
          var editor = this.editor;
          editor.selectAll();
          this.$clickSelection = editor.getSelectionRange();
          this.setState("selectAll");
        };
        this.onMouseWheel = function (ev) {
          if (ev.getAccelKey()) return;
          if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
          }
          var editor = this.editor;
          if (!this.$lastScroll) this.$lastScroll = {
            t: 0,
            vx: 0,
            vy: 0,
            allowed: 0
          };
          var prevScroll = this.$lastScroll;
          var t = ev.domEvent.timeStamp;
          var dt = t - prevScroll.t;
          var vx = ev.wheelX / dt;
          var vy = ev.wheelY / dt;
          if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
          }
          var direction = Math.abs(vx / vy);
          var canScroll = false;
          if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0)) canScroll = true;
          if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed)) canScroll = true;
          if (canScroll) {
            prevScroll.allowed = t;
          } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.1 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.1 * Math.abs(prevScroll.vy);
            if (isSlower) {
              canScroll = true;
              prevScroll.allowed = t;
            } else {
              prevScroll.allowed = 0;
            }
          }
          prevScroll.t = t;
          prevScroll.vx = vx;
          prevScroll.vy = vy;
          if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
          }
        };
        this.onTouchMove = function (ev) {
          this.editor._emit("mousewheel", ev);
        };
      }).call(DefaultHandlers.prototype);
      exports.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row) var cmp = 2 * cursor.column - range.start.column - range.end.column;else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) var cmp = cursor.column - 4;else var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0) return {
          cursor: range.start,
          anchor: range.end
        };else return {
          cursor: range.end,
          anchor: range.start
        };
      }
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      function Tooltip(parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
      }
      (function () {
        this.$init = function () {
          this.$element = dom.createElement("div");
          this.$element.className = "ace_tooltip";
          this.$element.style.display = "none";
          this.$parentNode.appendChild(this.$element);
          return this.$element;
        };
        this.getElement = function () {
          return this.$element || this.$init();
        };
        this.setText = function (text) {
          dom.setInnerText(this.getElement(), text);
        };
        this.setHtml = function (html) {
          this.getElement().innerHTML = html;
        };
        this.setPosition = function (x, y) {
          this.getElement().style.left = x + "px";
          this.getElement().style.top = y + "px";
        };
        this.setClassName = function (className) {
          dom.addCssClass(this.getElement(), className);
        };
        this.show = function (text, x, y) {
          if (text != null) this.setText(text);
          if (x != null && y != null) this.setPosition(x, y);
          if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
          }
        };
        this.hide = function () {
          if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
          }
        };
        this.getHeight = function () {
          return this.getElement().offsetHeight;
        };
        this.getWidth = function () {
          return this.getElement().offsetWidth;
        };
        this.destroy = function () {
          this.isOpen = false;
          if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
          }
        };
      }).call(Tooltip.prototype);
      exports.Tooltip = Tooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function (acequire, exports, module) {
      "use strict";

      var dom = acequire("../lib/dom");
      var oop = acequire("../lib/oop");
      var event = acequire("../lib/event");
      var Tooltip = acequire("../tooltip").Tooltip;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
          if (!editor.isFocused() || e.getButton() != 0) return;
          var gutterRegion = gutter.getRegion(e);
          if (gutterRegion == "foldWidgets") return;
          var row = e.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e.getShiftKey()) selection.selectTo(row, 0);else {
            if (e.domEvent.detail == 2) {
              editor.selectAll();
              return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e);
          return e.preventDefault();
        });
        var tooltipTimeout, mouseEvent, tooltipAnnotation;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var annotation = gutter.$annotations[row];
          if (!annotation) return hideTooltip();
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column)) return hideTooltip();
          }
          if (tooltipAnnotation == annotation) return;
          tooltipAnnotation = annotation.text.join("<br/>");
          tooltip.setHtml(tooltipAnnotation);
          tooltip.show();
          editor._signal("showGutterTooltip", tooltip);
          editor.on("mousewheel", hideTooltip);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
          }
        }
        function hideTooltip() {
          if (tooltipTimeout) tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor._signal("hideGutterTooltip", tooltip);
            editor.removeEventListener("mousewheel", hideTooltip);
          }
        }
        function moveTooltip(e) {
          tooltip.setPosition(e.x, e.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
          var target = e.domEvent.target || e.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget")) return hideTooltip();
          if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) moveTooltip(e);
          mouseEvent = e;
          if (tooltipTimeout) return;
          tooltipTimeout = setTimeout(function () {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();else hideTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
          mouseEvent = null;
          if (!tooltipAnnotation || tooltipTimeout) return;
          tooltipTimeout = setTimeout(function () {
            tooltipTimeout = null;
            hideTooltip();
          }, 50);
        });
        editor.on("changeSession", hideTooltip);
      }
      function GutterTooltip(parentNode) {
        Tooltip.call(this, parentNode);
      }
      oop.inherits(GutterTooltip, Tooltip);
      (function () {
        this.setPosition = function (x, y) {
          var windowWidth = window.innerWidth || document.documentElement.clientWidth;
          var windowHeight = window.innerHeight || document.documentElement.clientHeight;
          var width = this.getWidth();
          var height = this.getHeight();
          x += 15;
          y += 15;
          if (x + width > windowWidth) {
            x -= x + width - windowWidth;
          }
          if (y + height > windowHeight) {
            y -= 20 + height;
          }
          Tooltip.prototype.setPosition.call(this, x, y);
        };
      }).call(GutterTooltip.prototype);
      exports.GutterHandler = GutterHandler;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      "use strict";

      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
        this.domEvent = domEvent;
        this.editor = editor;
        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;
        this.$pos = null;
        this.$inSelection = null;
        this.propagationStopped = false;
        this.defaultPrevented = false;
      };
      (function () {
        this.stopPropagation = function () {
          event.stopPropagation(this.domEvent);
          this.propagationStopped = true;
        };
        this.preventDefault = function () {
          event.preventDefault(this.domEvent);
          this.defaultPrevented = true;
        };
        this.stop = function () {
          this.stopPropagation();
          this.preventDefault();
        };
        this.getDocumentPosition = function () {
          if (this.$pos) return this.$pos;
          this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
          return this.$pos;
        };
        this.inSelection = function () {
          if (this.$inSelection !== null) return this.$inSelection;
          var editor = this.editor;
          var selectionRange = editor.getSelectionRange();
          if (selectionRange.isEmpty()) this.$inSelection = false;else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
          }
          return this.$inSelection;
        };
        this.getButton = function () {
          return event.getButton(this.domEvent);
        };
        this.getShiftKey = function () {
          return this.domEvent.shiftKey;
        };
        this.getAccelKey = useragent.isMac ? function () {
          return this.domEvent.metaKey;
        } : function () {
          return this.domEvent.ctrlKey;
        };
      }).call(MouseEvent.prototype);
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      "use strict";

      var dom = acequire("../lib/dom");
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var blankImage = dom.createElement("img");
        blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (useragent.isOpera) blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
        var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports.forEach(function (x) {
          mouseHandler[x] = this[x];
        }, this);
        editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker, x, y;
        var timerId, range;
        var dragCursor,
          counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function (e) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function () {
              self.startSelect();
              self.captureMouse(e);
            }, 0);
            return e.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
          }
          dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
          if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
          }
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function (e) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move") editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function (e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker) addDragMarker();
          counter++;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragOver = function (e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null) onMouseMoveTimer = null;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragLeave = function (e) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
          }
        };
        this.onDrop = function (e) {
          if (!dragCursor) return;
          var dataTransfer = e.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData('Text');
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {
              x: x,
              y: y
            };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x - editorRect.left,
              right: editorRect.right - x
            },
            y: {
              top: y - editorRect.top,
              bottom: editorRect.bottom - y
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = {
            row: cursor.row,
            column: cursor.column
          };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : +2;
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : +1;
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || hScroll && !vMovement) {
            if (!autoScrollStartTime) autoScrollStartTime = now;else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY) editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x, y);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused()) editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.$blockScrolling += 1;
          editor.selection.fromOrientedRange(range);
          editor.$blockScrolling -= 1;
          if (editor.isFocused() && !isInternal) editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function () {
              if (onMouseMoveTimer != null && dragSelectionMarker) clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function (type) {
            return type == 'text/plain' || type == 'Text';
          });
        }
        function getDropEffect(e) {
          var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
          var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
          var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
          } catch (e) {}
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";else if (moveAllowed.indexOf(effectAllowed) >= 0) dropEffect = "move";else if (copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";
          return dropEffect;
        }
      }
      (function () {
        this.dragWait = function () {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay()) this.startDrag();
        };
        this.dragWaitEnd = function () {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function (e) {
          this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function () {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function (e) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3) target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function (e) {
          if (!this.$dragEnabled) return;
          this.mousedownEvent = e;
          var editor = this.editor;
          var inSelection = e.inSelection();
          var button = e.getButton();
          var clickCount = e.domEvent.detail || 1;
          if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget) eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      var dom = acequire("./dom");
      exports.get = function (url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports.loadScript = function (path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement('script');
        s.src = path;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function (_, isAbort) {
          if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort) callback();
          }
        };
      };
      exports.qualifyURL = function (url) {
        var a = document.createElement('a');
        a.href = url;
        return a.href;
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var EventEmitter = {};
      var stopPropagation = function stopPropagation() {
        this.propagationStopped = true;
      };
      var preventDefault = function preventDefault() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler) return;
        if (typeof e != "object" || !e) e = {};
        if (!e.type) e.type = eventName;
        if (!e.stopPropagation) e.stopPropagation = stopPropagation;
        if (!e.preventDefault) e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e, this);
          if (e.propagationStopped) break;
        }
        if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
      };
      EventEmitter._signal = function (eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners) return;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) listeners[i](e, this);
      };
      EventEmitter.once = function (eventName, callback) {
        var _self = this;
        callback && this.addEventListener(eventName, function newCallback() {
          _self.removeEventListener(eventName, newCallback);
          callback.apply(null, arguments);
        });
      };
      EventEmitter.setDefaultHandler = function (eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) handlers = this._defaultHandlers = {
          _disabled_: {}
        };
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled) handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1) disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function (eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          var old = handlers[eventName];
          if (disabled) this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1) disabled.splice(i, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners) listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners) return;
        var index = listeners.indexOf(callback);
        if (index !== -1) listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function (eventName) {
        if (this._eventRegistry) this._eventRegistry[eventName] = [];
      };
      exports.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "no use strict";

      var oop = acequire("./oop");
      var EventEmitter = acequire("./event_emitter").EventEmitter;
      var optionsProvider = {
        setOptions: function setOptions(optList) {
          Object.keys(optList).forEach(function (key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function getOptions(optionNames) {
          var result = {};
          if (!optionNames) {
            optionNames = Object.keys(this.$options);
          } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
          }
          optionNames.forEach(function (key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function setOption(name, value) {
          if (this["$" + name] === value) return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet) this["$" + name] = value;
          if (opt && opt.set) opt.set.call(this, value);
        },
        getOption: function getOption(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn) console.warn.apply(console, arguments);
      }
      function reportError(msg, data) {
        var e = new Error(msg);
        e.data = data;
        if (typeof console == "object" && console.error) console.error(e);
        setTimeout(function () {
          throw e;
        });
      }
      var AppConfig = function AppConfig() {
        this.$defaultOptions = {};
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.defineOptions = function (obj, path, options) {
          if (!obj.$options) this.$defaultOptions[path] = obj.$options = {};
          Object.keys(options).forEach(function (key) {
            var opt = options[key];
            if (typeof opt == "string") opt = {
              forwardTo: opt
            };
            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt) obj["$" + opt.name] = opt.initialValue;
          });
          oop.implement(obj, optionsProvider);
          return this;
        };
        this.resetOptions = function (obj) {
          Object.keys(obj.$options).forEach(function (key) {
            var opt = obj.$options[key];
            if ("value" in opt) obj.setOption(key, opt.value);
          });
        };
        this.setDefaultValue = function (path, name, value) {
          var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
          if (opts[name]) {
            if (opts.forwardTo) this.setDefaultValue(opts.forwardTo, name, value);else opts[name].value = value;
          }
        };
        this.setDefaultValues = function (path, optionHash) {
          Object.keys(optionHash).forEach(function (key) {
            this.setDefaultValue(path, key, optionHash[key]);
          }, this);
        };
        this.warn = warn;
        this.reportError = reportError;
      }).call(AppConfig.prototype);
      exports.AppConfig = AppConfig;
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function (acequire, exports, module) {
      "no use strict";

      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var net = acequire("./lib/net");
      var AppConfig = acequire("./lib/app_config").AppConfig;
      module.exports = exports = new AppConfig();
      var global = function () {
        return this || typeof window != "undefined" && window;
      }();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {}
      };
      exports.get = function (key) {
        if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports.set = function (key, value) {
        if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);
        options[key] = value;
      };
      exports.all = function () {
        return lang.copyObject(options);
      };
      exports.moduleUrl = function (name, component) {
        if (options.$moduleUrls[name]) return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1) base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
          path = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path && path.slice(-1) != "/") path += "/";
        return path + component + sep + base + this.get("suffix");
      };
      exports.setModuleUrl = function (name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      exports.$loading = {};
      exports.loadModule = function (moduleName, onLoad) {
        var module, moduleType;
        if (Array.isArray(moduleName)) {
          moduleType = moduleName[0];
          moduleName = moduleName[1];
        }
        try {
          module = acequire(moduleName);
        } catch (e) {}
        if (module && !exports.$loading[moduleName]) return onLoad && onLoad(module);
        if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];
        exports.$loading[moduleName].push(onLoad);
        if (exports.$loading[moduleName].length > 1) return;
        var afterLoad = function afterLoad() {
          acequire([moduleName], function (module) {
            exports._emit("load.module", {
              name: moduleName,
              module: module
            });
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function (onLoad) {
              onLoad && onLoad(module);
            });
          });
        };
        if (!exports.get("packaged")) return afterLoad();
        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
      };
      init(true);
      function init(packaged) {
        if (!global || !global.document) return;
        options.packaged = packaged || acequire.packaged || module.packaged || global.define && __webpack_require__( /*! !webpack amd define */"./node_modules/webpack/buildin/amd-define.js").packaged;
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document.currentScript || document._currentScript; // native or polyfill
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          var src = script.src || script.getAttribute("src");
          if (!src) continue;
          var attributes = script.attributes;
          for (var j = 0, l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
          if (m) scriptUrl = m[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions) if (typeof scriptOptions[key] !== "undefined") exports.set(key, scriptOptions[key]);
      }
      exports.init = init;
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function (m, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function (acequire, exports, module) {
      "use strict";

      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
      var MouseEvent = acequire("./mouse_event").MouseEvent;
      var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
      var config = acequire("../config");
      var MouseHandler = function MouseHandler(editor) {
        var _self = this;
        this.editor = editor;
        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);
        var focusEditor = function focusEditor(e) {
          var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
          if (windowBlurred) window.focus();
          editor.focus();
        };
        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
        event.addMultiMouseDownListener([mouseTarget, editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner, editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner, editor.textInput && editor.textInput.getElement()].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
        event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));
        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
        event.addListener(mouseTarget, "mousedown", focusEditor);
        event.addListener(gutterEl, "mousedown", focusEditor);
        if (useragent.isIE && editor.renderer.scrollBarV) {
          event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
          event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
        }
        editor.on("mousemove", function (e) {
          if (_self.state || _self.$dragDelay || !_self.$dragEnabled) return;
          var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
          var range = editor.session.selection.getRange();
          var renderer = editor.renderer;
          if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
          } else {
            renderer.setCursorStyle("");
          }
        });
      };
      (function () {
        this.onMouseEvent = function (name, e) {
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        this.onMouseMove = function (name, e) {
          var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
          if (!listeners || !listeners.length) return;
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        this.onMouseWheel = function (name, e) {
          var mouseEvent = new MouseEvent(e, this.editor);
          mouseEvent.speed = this.$scrollSpeed * 2;
          mouseEvent.wheelX = e.wheelX;
          mouseEvent.wheelY = e.wheelY;
          this.editor._emit(name, mouseEvent);
        };
        this.onTouchMove = function (name, e) {
          var mouseEvent = new MouseEvent(e, this.editor);
          mouseEvent.speed = 1; //this.$scrollSpeed * 2;
          mouseEvent.wheelX = e.wheelX;
          mouseEvent.wheelY = e.wheelY;
          this.editor._emit(name, mouseEvent);
        };
        this.setState = function (state) {
          this.state = state;
        };
        this.captureMouse = function (ev, mouseMoveHandler) {
          this.x = ev.x;
          this.y = ev.y;
          this.isMousePressed = true;
          var renderer = this.editor.renderer;
          if (renderer.$keepTextAreaAtCursor) renderer.$keepTextAreaAtCursor = null;
          var self = this;
          var onMouseMove = function onMouseMove(e) {
            if (!e) return;
            if (useragent.isWebKit && !e.which && self.releaseMouse) return self.releaseMouse();
            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
          };
          var onCaptureEnd = function onCaptureEnd(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
              renderer.$keepTextAreaAtCursor = true;
              renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
          };
          var onCaptureInterval = function onCaptureInterval() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
          };
          if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function () {
              onCaptureEnd(ev);
            });
          }
          self.$onCaptureMouseMove = onMouseMove;
          self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
          var timerId = setInterval(onCaptureInterval, 20);
        };
        this.releaseMouse = null;
        this.cancelContextMenu = function () {
          var stop = function (e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu") return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent) event.stopEvent(e.domEvent);
          }.bind(this);
          setTimeout(stop, 10);
          this.editor.on("nativecontextmenu", stop);
        };
      }).call(MouseHandler.prototype);
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: {
          initialValue: 2
        },
        dragDelay: {
          initialValue: useragent.isMac ? 150 : 0
        },
        dragEnabled: {
          initialValue: true
        },
        focusTimout: {
          initialValue: 0
        },
        tooltipFollowsMouse: {
          initialValue: true
        }
      });
      exports.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      function FoldHandler(editor) {
        editor.on("click", function (e) {
          var position = e.getDocumentPosition();
          var session = editor.session;
          var fold = session.getFoldAt(position.row, position.column, 1);
          if (fold) {
            if (e.getAccelKey()) session.removeFold(fold);else session.expandFold(fold);
            e.stop();
          }
        });
        editor.on("gutterclick", function (e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row]) editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused()) editor.focus();
            e.stop();
          }
        });
        editor.on("gutterdblclick", function (e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;
            if (range) {
              row = range.start.row;
              var fold = session.getFoldAt(row, session.getLine(row).length, 1);
              if (fold) {
                session.removeFold(fold);
              } else {
                session.addFold("...", range);
                editor.renderer.scrollCursorIntoView({
                  row: range.start.row,
                  column: 0
                });
              }
            }
            e.stop();
          }
        });
      }
      exports.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function (acequire, exports, module) {
      "use strict";

      var keyUtil = acequire("../lib/keys");
      var event = acequire("../lib/event");
      var KeyBinding = function KeyBinding(editor) {
        this.$editor = editor;
        this.$data = {
          editor: editor
        };
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
      };
      (function () {
        this.setDefaultHandler = function (kb) {
          this.removeKeyboardHandler(this.$defaultHandler);
          this.$defaultHandler = kb;
          this.addKeyboardHandler(kb, 0);
        };
        this.setKeyboardHandler = function (kb) {
          var h = this.$handlers;
          if (h[h.length - 1] == kb) return;
          while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler) this.removeKeyboardHandler(h[h.length - 1]);
          this.addKeyboardHandler(kb, 1);
        };
        this.addKeyboardHandler = function (kb, pos) {
          if (!kb) return;
          if (typeof kb == "function" && !kb.handleKeyboard) kb.handleKeyboard = kb;
          var i = this.$handlers.indexOf(kb);
          if (i != -1) this.$handlers.splice(i, 1);
          if (pos == undefined) this.$handlers.push(kb);else this.$handlers.splice(pos, 0, kb);
          if (i == -1 && kb.attach) kb.attach(this.$editor);
        };
        this.removeKeyboardHandler = function (kb) {
          var i = this.$handlers.indexOf(kb);
          if (i == -1) return false;
          this.$handlers.splice(i, 1);
          kb.detach && kb.detach(this.$editor);
          return true;
        };
        this.getKeyboardHandler = function () {
          return this.$handlers[this.$handlers.length - 1];
        };
        this.getStatusText = function () {
          var data = this.$data;
          var editor = data.editor;
          return this.$handlers.map(function (h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
          }).filter(Boolean).join(" ");
        };
        this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
          var toExecute;
          var success = false;
          var commands = this.$editor.commands;
          for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
            if (!toExecute || !toExecute.command) continue;
            if (toExecute.command == "null") {
              success = true;
            } else {
              success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
              event.stopEvent(e);
            }
            if (success) break;
          }
          if (!success && hashId == -1) {
            toExecute = {
              command: "insertstring"
            };
            success = commands.exec("insertstring", this.$editor, keyString);
          }
          if (success && this.$editor._signal) this.$editor._signal("keyboardActivity", toExecute);
          return success;
        };
        this.onCommandKey = function (e, hashId, keyCode) {
          var keyString = keyUtil.keyCodeToString(keyCode);
          this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };
        this.onTextInput = function (text) {
          this.$callKeyboardHandlers(-1, text);
        };
      }).call(KeyBinding.prototype);
      exports.KeyBinding = KeyBinding;
    });
    ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var ArabicAlefBetIntervalsBegine = ["\u0621", "\u0641"];
      var ArabicAlefBetIntervalsEnd = ["\u063A", "\u064A"];
      var dir = 0,
        hiLevel = 0;
      var lastArabic = false,
        hasUBAT_AL = false,
        hasUBAT_B = false,
        hasUBAT_S = false,
        hasBlockSep = false,
        hasSegSep = false;
      var impTab_LTR = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]];
      var impTab_RTL = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]];
      var LTR = 0,
        RTL = 1;
      var L = 0;
      var R = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B = 5;
      var S = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN = 18;
      var UnicodeTBL00 = [BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S, WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON, ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON, ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN, BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON, ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON];
      var UnicodeTBL20 = [WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS, ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS];
      function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR,
          prevState = null,
          newClass = null,
          newLevel = null,
          newState = 0,
          action = null,
          cond = null,
          condPos = -1,
          i = null,
          ix = null,
          classes = [];
        if (!charTypes) {
          for (i = 0, charTypes = []; i < len; i++) {
            charTypes[i] = _getCharacterType(chars[i]);
          }
        }
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_AL = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for (ix = 0; ix < len; ix++) {
          prevState = newState;
          classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
          newState = impTab[prevState][newClass];
          action = newState & 0xF0;
          newState &= 0x0F;
          levels[ix] = newLevel = impTab[newState][5];
          if (action > 0) {
            if (action == 0x10) {
              for (i = condPos; i < ix; i++) {
                levels[i] = 1;
              }
              condPos = -1;
            } else {
              condPos = -1;
            }
          }
          cond = impTab[newState][6];
          if (cond) {
            if (condPos == -1) {
              condPos = ix;
            }
          } else {
            if (condPos > -1) {
              for (i = condPos; i < ix; i++) {
                levels[i] = newLevel;
              }
              condPos = -1;
            }
          }
          if (charTypes[ix] == B) {
            levels[ix] = 0;
          }
          hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
          for (i = 0; i < len; i++) {
            if (charTypes[i] == S) {
              levels[i] = dir;
              for (var j = i - 1; j >= 0; j--) {
                if (charTypes[j] == WS) {
                  levels[j] = dir;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
      function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) {
          return;
        }
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
          _array.reverse();
          return;
        }
        var len = _array.length,
          start = 0,
          end,
          lo,
          hi,
          tmp;
        while (start < len) {
          if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
              end++;
            }
            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
              tmp = _array[lo];
              _array[lo] = _array[hi];
              _array[hi] = tmp;
            }
            start = end;
          }
          start++;
        }
      }
      function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix],
          wType,
          nType,
          len,
          i;
        switch (cType) {
          case L:
          case R:
            lastArabic = false;
          case ON:
          case AN:
            return cType;
          case EN:
            return lastArabic ? AN : EN;
          case AL:
            lastArabic = true;
            hasUBAT_AL = true;
            return R;
          case WS:
            return ON;
          case CS:
            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
              return ON;
            }
            if (lastArabic) {
              nType = AN;
            }
            return nType == wType ? nType : ON;
          case ES:
            wType = ix > 0 ? classes[ix - 1] : B;
            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
              return EN;
            }
            return ON;
          case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
              return EN;
            }
            if (lastArabic) {
              return ON;
            }
            i = ix + 1;
            len = types.length;
            while (i < len && types[i] == ET) {
              i++;
            }
            if (i < len && types[i] == EN) {
              return EN;
            }
            return ON;
          case NSM:
            len = types.length;
            i = ix + 1;
            while (i < len && types[i] == NSM) {
              i++;
            }
            if (i < len) {
              var c = chars[ix],
                rtlCandidate = c >= 0x0591 && c <= 0x08FF || c == 0xFB1E;
              wType = types[i];
              if (rtlCandidate && (wType == R || wType == AL)) {
                return R;
              }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B) {
              return ON;
            }
            return classes[ix - 1];
          case B:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
          case S:
            hasUBAT_S = true;
            return ON;
          case LRE:
          case RLE:
          case LRO:
          case RLO:
          case PDF:
            lastArabic = false;
          case BN:
            return ON;
        }
      }
      function _getCharacterType(ch) {
        var uc = ch.charCodeAt(0),
          hi = uc >> 8;
        if (hi == 0) {
          return uc > 0x00BF ? L : UnicodeTBL00[uc];
        } else if (hi == 5) {
          return /[\u0591-\u05f4]/.test(ch) ? R : L;
        } else if (hi == 6) {
          if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch)) return NSM;else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch)) return AN;else if (uc == 0x066A) return ET;else if (/[\u06f0-\u06f9]/.test(ch)) return EN;else return AL;
        } else if (hi == 0x20 && uc <= 0x205F) {
          return UnicodeTBL20[uc & 0xFF];
        } else if (hi == 0xFE) {
          return uc >= 0xFE70 ? AL : ON;
        }
        return ON;
      }
      function _isArabicDiacritics(ch) {
        return ch >= "\u064B" && ch <= "\u0655";
      }
      exports.L = L;
      exports.R = R;
      exports.EN = EN;
      exports.ON_R = 3;
      exports.AN = 4;
      exports.R_H = 5;
      exports.B = 6;
      exports.DOT = "\xB7";
      exports.doBidiReorder = function (text, textCharTypes, isRtl) {
        if (text.length < 2) return {};
        var chars = text.split(""),
          logicalFromVisual = new Array(chars.length),
          bidiLevels = new Array(chars.length),
          levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for (var i = 0; i < logicalFromVisual.length - 1; i++) {
          //fix levels to reflect character width
          if (textCharTypes[i] === AN) {
            levels[i] = exports.AN;
          } else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
            levels[i] = exports.ON_R;
          } else if (i > 0 && chars[i - 1] === "\u0644" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
            levels[i - 1] = levels[i] = exports.R_H;
            i++;
          }
        }
        if (chars[chars.length - 1] === exports.DOT) levels[chars.length - 1] = exports.B;
        for (var i = 0; i < logicalFromVisual.length; i++) {
          bidiLevels[i] = levels[logicalFromVisual[i]];
        }
        return {
          'logicalFromVisual': logicalFromVisual,
          'bidiLevels': bidiLevels
        };
      };
      exports.hasBidiCharacters = function (text, textCharTypes) {
        var ret = false;
        for (var i = 0; i < text.length; i++) {
          textCharTypes[i] = _getCharacterType(text.charAt(i));
          if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL)) ret = true;
        }
        return ret;
      };
      exports.getVisualFromLogicalIdx = function (logIdx, rowMap) {
        for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
          if (rowMap.logicalFromVisual[i] == logIdx) return i;
        }
        return 0;
      };
    });
    ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang", "ace/lib/useragent"], function (acequire, exports, module) {
      "use strict";

      var bidiUtil = acequire("./lib/bidiutil");
      var lang = acequire("./lib/lang");
      var useragent = acequire("./lib/useragent");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var BidiHandler = function BidiHandler(session) {
        this.session = session;
        this.bidiMap = {};
        this.currentRow = null;
        this.bidiUtil = bidiUtil;
        this.charWidths = [];
        this.EOL = "\xAC";
        this.showInvisibles = true;
        this.isRtlDir = false;
        this.line = "";
        this.wrapIndent = 0;
        this.isLastRow = false;
        this.EOF = "\xB6";
        this.seenBidi = false;
      };
      (function () {
        this.isBidiRow = function (screenRow, docRow, splitIndex) {
          if (!this.seenBidi) return false;
          if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
          }
          return this.bidiMap.bidiLevels;
        };
        this.onChange = function (delta) {
          if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
              this.seenBidi = true;
              this.currentRow = null;
            }
          } else {
            this.currentRow = null;
          }
        };
        this.getDocumentRow = function () {
          var docRow = 0;
          var rowCache = this.session.$screenRowCache;
          if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index >= 0) docRow = this.session.$docRowCache[index];
          }
          return docRow;
        };
        this.getSplitIndex = function () {
          var splitIndex = 0;
          var rowCache = this.session.$screenRowCache;
          if (rowCache.length) {
            var currentIndex,
              prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
              currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
              if (currentIndex !== prevIndex) break;
              prevIndex = currentIndex;
              splitIndex++;
            }
          }
          return splitIndex;
        };
        this.updateRowLine = function (docRow, splitIndex) {
          if (docRow === undefined) docRow = this.getDocumentRow();
          this.wrapIndent = 0;
          this.isLastRow = docRow === this.session.getLength() - 1;
          this.line = this.session.getLine(docRow);
          if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
              if (splitIndex === undefined) splitIndex = this.getSplitIndex();
              if (splitIndex > 0 && splits.length) {
                this.wrapIndent = splits.indent;
                this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splits.length - 1]) : this.line.substring(splits[splits.length - 1]);
              } else {
                this.line = this.line.substring(0, splits[splitIndex]);
              }
            }
          }
          var session = this.session,
            shift = 0,
            size;
          this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function (ch, i) {
            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
              size = ch === '\t' ? session.getScreenTabSize(i + shift) : 2;
              shift += size - 1;
              return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
          });
        };
        this.updateBidiMap = function () {
          var textCharTypes = [],
            endOfLine = this.isLastRow ? this.EOF : this.EOL;
          var line = this.line + (this.showInvisibles ? endOfLine : bidiUtil.DOT);
          if (bidiUtil.hasBidiCharacters(line, textCharTypes)) {
            this.bidiMap = bidiUtil.doBidiReorder(line, textCharTypes, this.isRtlDir);
          } else {
            this.bidiMap = {};
          }
        };
        this.markAsDirty = function () {
          this.currentRow = null;
        };
        this.updateCharacterWidths = function (fontMetrics) {
          if (!this.seenBidi) return;
          if (this.characterWidth === fontMetrics.$characterSize.width) return;
          var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
          var bidiCharWidth = fontMetrics.$measureCharWidth("\u05D4");
          this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
          this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
          this.charWidths[bidiUtil.R_H] = useragent.isChrome ? bidiCharWidth : bidiCharWidth * 0.45;
          this.charWidths[bidiUtil.B] = 0;
          this.currentRow = null;
        };
        this.getShowInvisibles = function () {
          return this.showInvisibles;
        };
        this.setShowInvisibles = function (showInvisibles) {
          this.showInvisibles = showInvisibles;
          this.currentRow = null;
        };
        this.setEolChar = function (eolChar) {
          this.EOL = eolChar;
        };
        this.setTextDir = function (isRtlDir) {
          this.isRtlDir = isRtlDir;
        };
        this.getPosLeft = function (col) {
          col -= this.wrapIndent;
          var visualIdx = bidiUtil.getVisualFromLogicalIdx(col > 0 ? col - 1 : 0, this.bidiMap),
            levels = this.bidiMap.bidiLevels,
            left = 0;
          if (col === 0 && levels[visualIdx] % 2 !== 0) visualIdx++;
          for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
          }
          if (col !== 0 && levels[visualIdx] % 2 === 0) left += this.charWidths[levels[visualIdx]];
          if (this.wrapIndent) left += this.wrapIndent * this.charWidths[bidiUtil.L];
          return left;
        };
        this.getSelections = function (startCol, endCol) {
          var map = this.bidiMap,
            levels = map.bidiLevels,
            level,
            offset = this.wrapIndent * this.charWidths[bidiUtil.L],
            selections = [],
            selColMin = Math.min(startCol, endCol) - this.wrapIndent,
            selColMax = Math.max(startCol, endCol) - this.wrapIndent,
            isSelected = false,
            isSelectedPrev = false,
            selectionStart = 0;
          for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = logIdx >= selColMin && logIdx < selColMax;
            if (isSelected && !isSelectedPrev) {
              selectionStart = offset;
            } else if (!isSelected && isSelectedPrev) {
              selections.push({
                left: selectionStart,
                width: offset - selectionStart
              });
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
          }
          if (isSelected && visIdx === levels.length) {
            selections.push({
              left: selectionStart,
              width: offset - selectionStart
            });
          }
          return selections;
        };
        this.offsetToCol = function (posX) {
          var logicalIdx = 0,
            posX = Math.max(posX, 0),
            offset = 0,
            visualIdx = 0,
            levels = this.bidiMap.bidiLevels,
            charWidth = this.charWidths[levels[visualIdx]];
          if (this.wrapIndent) {
            posX -= this.wrapIndent * this.charWidths[bidiUtil.L];
          }
          while (posX > offset + charWidth / 2) {
            offset += charWidth;
            if (visualIdx === levels.length - 1) {
              charWidth = 0;
              break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
          }
          if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
            if (posX < offset) visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
          } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
            logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
          } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
          } else {
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0) visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
          }
          return logicalIdx + this.wrapIndent;
        };
      }).call(BidiHandler.prototype);
      exports.BidiHandler = BidiHandler;
    });
    ace.define("ace/range", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var comparePoints = function comparePoints(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = function Range(startRow, startColumn, endRow, endColumn) {
        this.start = {
          row: startRow,
          column: startColumn
        };
        this.end = {
          row: endRow,
          column: endColumn
        };
      };
      (function () {
        this.isEqual = function (range) {
          return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
        };
        this.toString = function () {
          return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
        };
        this.contains = function (row, column) {
          return this.compare(row, column) == 0;
        };
        this.compareRange = function (range) {
          var cmp,
            end = range.end,
            start = range.start;
          cmp = this.compare(end.row, end.column);
          if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
              return 2;
            } else if (cmp == 0) {
              return 1;
            } else {
              return 0;
            }
          } else if (cmp == -1) {
            return -2;
          } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
              return -1;
            } else if (cmp == 1) {
              return 42;
            } else {
              return 0;
            }
          }
        };
        this.comparePoint = function (p) {
          return this.compare(p.row, p.column);
        };
        this.containsRange = function (range) {
          return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        this.intersects = function (range) {
          var cmp = this.compareRange(range);
          return cmp == -1 || cmp == 0 || cmp == 1;
        };
        this.isEnd = function (row, column) {
          return this.end.row == row && this.end.column == column;
        };
        this.isStart = function (row, column) {
          return this.start.row == row && this.start.column == column;
        };
        this.setStart = function (row, column) {
          if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
          } else {
            this.start.row = row;
            this.start.column = column;
          }
        };
        this.setEnd = function (row, column) {
          if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
          } else {
            this.end.row = row;
            this.end.column = column;
          }
        };
        this.inside = function (row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideStart = function (row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideEnd = function (row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.compare = function (row, column) {
          if (!this.isMultiLine()) {
            if (row === this.start.row) {
              return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
            }
          }
          if (row < this.start.row) return -1;
          if (row > this.end.row) return 1;
          if (this.start.row === row) return column >= this.start.column ? 0 : -1;
          if (this.end.row === row) return column <= this.end.column ? 0 : 1;
          return 0;
        };
        this.compareStart = function (row, column) {
          if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareEnd = function (row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareInside = function (row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.clipRows = function (firstRow, lastRow) {
          if (this.end.row > lastRow) var end = {
            row: lastRow + 1,
            column: 0
          };else if (this.end.row < firstRow) var end = {
            row: firstRow,
            column: 0
          };
          if (this.start.row > lastRow) var start = {
            row: lastRow + 1,
            column: 0
          };else if (this.start.row < firstRow) var start = {
            row: firstRow,
            column: 0
          };
          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.extend = function (row, column) {
          var cmp = this.compare(row, column);
          if (cmp == 0) return this;else if (cmp == -1) var start = {
            row: row,
            column: column
          };else var end = {
            row: row,
            column: column
          };
          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.isEmpty = function () {
          return this.start.row === this.end.row && this.start.column === this.end.column;
        };
        this.isMultiLine = function () {
          return this.start.row !== this.end.row;
        };
        this.clone = function () {
          return Range.fromPoints(this.start, this.end);
        };
        this.collapseRows = function () {
          if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
        };
        this.toScreenRange = function (session) {
          var screenPosStart = session.documentToScreenPosition(this.start);
          var screenPosEnd = session.documentToScreenPosition(this.end);
          return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
        };
        this.moveBy = function (row, column) {
          this.start.row += row;
          this.start.column += column;
          this.end.row += row;
          this.end.column += column;
        };
      }).call(Range.prototype);
      Range.fromPoints = function (start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;
      Range.comparePoints = function (p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports.Range = Range;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var lang = acequire("./lib/lang");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Range = acequire("./range").Range;
      var Selection = function Selection(session) {
        this.session = session;
        this.doc = session.getDocument();
        this.clearSelection();
        this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
        this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
        var self = this;
        this.lead.on("change", function (e) {
          self._emit("changeCursor");
          if (!self.$isEmpty) self._emit("changeSelection");
          if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column) self.$desiredColumn = null;
        });
        this.selectionAnchor.on("change", function () {
          if (!self.$isEmpty) self._emit("changeSelection");
        });
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.isEmpty = function () {
          return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
        };
        this.isMultiLine = function () {
          if (this.isEmpty()) {
            return false;
          }
          return this.getRange().isMultiLine();
        };
        this.getCursor = function () {
          return this.lead.getPosition();
        };
        this.setSelectionAnchor = function (row, column) {
          this.anchor.setPosition(row, column);
          if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
          }
        };
        this.getSelectionAnchor = function () {
          if (this.$isEmpty) return this.getSelectionLead();else return this.anchor.getPosition();
        };
        this.getSelectionLead = function () {
          return this.lead.getPosition();
        };
        this.shiftSelection = function (columns) {
          if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
          }
          var anchor = this.getSelectionAnchor();
          var lead = this.getSelectionLead();
          var isBackwards = this.isBackwards();
          if (!isBackwards || anchor.column !== 0) this.setSelectionAnchor(anchor.row, anchor.column + columns);
          if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function () {
              this.moveCursorTo(lead.row, lead.column + columns);
            });
          }
        };
        this.isBackwards = function () {
          var anchor = this.anchor;
          var lead = this.lead;
          return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
        };
        this.getRange = function () {
          var anchor = this.anchor;
          var lead = this.lead;
          if (this.isEmpty()) return Range.fromPoints(lead, lead);
          if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
          } else {
            return Range.fromPoints(anchor, lead);
          }
        };
        this.clearSelection = function () {
          if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
          }
        };
        this.selectAll = function () {
          var lastRow = this.doc.getLength() - 1;
          this.setSelectionAnchor(0, 0);
          this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
        };
        this.setRange = this.setSelectionRange = function (range, reverse) {
          if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
          } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
          }
          if (this.getRange().isEmpty()) this.$isEmpty = true;
          this.$desiredColumn = null;
        };
        this.$moveSelection = function (mover) {
          var lead = this.lead;
          if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);
          mover.call(this);
        };
        this.selectTo = function (row, column) {
          this.$moveSelection(function () {
            this.moveCursorTo(row, column);
          });
        };
        this.selectToPosition = function (pos) {
          this.$moveSelection(function () {
            this.moveCursorToPosition(pos);
          });
        };
        this.moveTo = function (row, column) {
          this.clearSelection();
          this.moveCursorTo(row, column);
        };
        this.moveToPosition = function (pos) {
          this.clearSelection();
          this.moveCursorToPosition(pos);
        };
        this.selectUp = function () {
          this.$moveSelection(this.moveCursorUp);
        };
        this.selectDown = function () {
          this.$moveSelection(this.moveCursorDown);
        };
        this.selectRight = function () {
          this.$moveSelection(this.moveCursorRight);
        };
        this.selectLeft = function () {
          this.$moveSelection(this.moveCursorLeft);
        };
        this.selectLineStart = function () {
          this.$moveSelection(this.moveCursorLineStart);
        };
        this.selectLineEnd = function () {
          this.$moveSelection(this.moveCursorLineEnd);
        };
        this.selectFileEnd = function () {
          this.$moveSelection(this.moveCursorFileEnd);
        };
        this.selectFileStart = function () {
          this.$moveSelection(this.moveCursorFileStart);
        };
        this.selectWordRight = function () {
          this.$moveSelection(this.moveCursorWordRight);
        };
        this.selectWordLeft = function () {
          this.$moveSelection(this.moveCursorWordLeft);
        };
        this.getWordRange = function (row, column) {
          if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
          }
          return this.session.getWordRange(row, column);
        };
        this.selectWord = function () {
          this.setSelectionRange(this.getWordRange());
        };
        this.selectAWord = function () {
          var cursor = this.getCursor();
          var range = this.session.getAWordRange(cursor.row, cursor.column);
          this.setSelectionRange(range);
        };
        this.getLineRange = function (row, excludeLastChar) {
          var rowStart = typeof row == "number" ? row : this.lead.row;
          var rowEnd;
          var foldLine = this.session.getFoldLine(rowStart);
          if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
          } else {
            rowEnd = rowStart;
          }
          if (excludeLastChar === true) return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);else return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        this.selectLine = function () {
          this.setSelectionRange(this.getLineRange());
        };
        this.moveCursorUp = function () {
          this.moveCursorBy(-1, 0);
        };
        this.moveCursorDown = function () {
          this.moveCursorBy(1, 0);
        };
        this.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {
          var start = cursor.column;
          var end = cursor.column + tabSize;
          if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
          }
          return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
        };
        this.moveCursorLeft = function () {
          var cursor = this.lead.getPosition(),
            fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
          } else if (cursor.column === 0) {
            if (cursor.row > 0) {
              this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
          } else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
              this.moveCursorBy(0, -tabSize);
            } else {
              this.moveCursorBy(0, -1);
            }
          }
        };
        this.moveCursorRight = function () {
          var cursor = this.lead.getPosition(),
            fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
          } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
              this.moveCursorTo(this.lead.row + 1, 0);
            }
          } else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
              this.moveCursorBy(0, tabSize);
            } else {
              this.moveCursorBy(0, 1);
            }
          }
        };
        this.moveCursorLineStart = function () {
          var row = this.lead.row;
          var column = this.lead.column;
          var screenRow = this.session.documentToScreenRow(row, column);
          var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
          var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
          var leadingSpace = beforeCursor.match(/^\s*/);
          if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart) firstColumnPosition.column += leadingSpace[0].length;
          this.moveCursorToPosition(firstColumnPosition);
        };
        this.moveCursorLineEnd = function () {
          var lead = this.lead;
          var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
          if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
              var textEnd = line.search(/\s+$/);
              if (textEnd > 0) lineEnd.column = textEnd;
            }
          }
          this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        this.moveCursorFileEnd = function () {
          var row = this.doc.getLength() - 1;
          var column = this.doc.getLine(row).length;
          this.moveCursorTo(row, column);
        };
        this.moveCursorFileStart = function () {
          this.moveCursorTo(0, 0);
        };
        this.moveCursorLongWordRight = function () {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var match;
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
          }
          if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
          }
          if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
            return;
          }
          if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.moveCursorLongWordLeft = function () {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
          }
          var str = this.session.getFoldStringAt(row, column, -1);
          if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
          }
          var leftOfCursor = lang.stringReverse(str);
          var match;
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
          }
          if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0) this.moveCursorWordLeft();
            return;
          }
          if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.$shortWordEndIndex = function (rightOfCursor) {
          var match,
            index = 0,
            ch;
          var whitespaceRe = /\s/;
          var tokenRe = this.session.tokenRe;
          tokenRe.lastIndex = 0;
          if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
          } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
            if (index < 1) {
              tokenRe.lastIndex = 0;
              while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                tokenRe.lastIndex = 0;
                index++;
                if (whitespaceRe.test(ch)) {
                  if (index > 2) {
                    index--;
                    break;
                  } else {
                    while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
                    if (index > 2) break;
                  }
                }
              }
            }
          }
          tokenRe.lastIndex = 0;
          return index;
        };
        this.moveCursorShortWordRight = function () {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);
          if (column == line.length) {
            var l = this.doc.getLength();
            do {
              row++;
              rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
            column = 0;
          }
          var index = this.$shortWordEndIndex(rightOfCursor);
          this.moveCursorTo(row, column + index);
        };
        this.moveCursorShortWordLeft = function () {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);
          var line = this.session.getLine(row).substring(0, column);
          if (column === 0) {
            do {
              row--;
              line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line)) line = "";
          }
          var leftOfCursor = lang.stringReverse(line);
          var index = this.$shortWordEndIndex(leftOfCursor);
          return this.moveCursorTo(row, column - index);
        };
        this.moveCursorWordRight = function () {
          if (this.session.$selectLongWords) this.moveCursorLongWordRight();else this.moveCursorShortWordRight();
        };
        this.moveCursorWordLeft = function () {
          if (this.session.$selectLongWords) this.moveCursorLongWordLeft();else this.moveCursorShortWordLeft();
        };
        this.moveCursorBy = function (rows, chars) {
          var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
          var offsetX;
          if (chars === 0) {
            if (rows !== 0) {
              if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
              } else {
                offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
              }
            }
            if (this.$desiredColumn) screenPos.column = this.$desiredColumn;else this.$desiredColumn = screenPos.column;
          }
          var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
          if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
              if (docPos.row > 0 || rows > 0) docPos.row++;
            }
          }
          this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        this.moveCursorToPosition = function (position) {
          this.moveCursorTo(position.row, position.column);
        };
        this.moveCursorTo = function (row, column, keepDesiredColumn) {
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            row = fold.start.row;
            column = fold.start.column;
          }
          this.$keepDesiredColumnOnChange = true;
          var line = this.session.getLine(row);
          if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1) column = column - 1;else column = column + 1;
          }
          this.lead.setPosition(row, column);
          this.$keepDesiredColumnOnChange = false;
          if (!keepDesiredColumn) this.$desiredColumn = null;
        };
        this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
          var pos = this.session.screenToDocumentPosition(row, column);
          this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        this.detach = function () {
          this.lead.detach();
          this.anchor.detach();
          this.session = this.doc = null;
        };
        this.fromOrientedRange = function (range) {
          this.setSelectionRange(range, range.cursor == range.start);
          this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };
        this.toOrientedRange = function (range) {
          var r = this.getRange();
          if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
          } else {
            range = r;
          }
          range.cursor = this.isBackwards() ? range.start : range.end;
          range.desiredColumn = this.$desiredColumn;
          return range;
        };
        this.getRangeOfMovements = function (func) {
          var start = this.getCursor();
          try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
          } catch (e) {
            return Range.fromPoints(start, start);
          } finally {
            this.moveCursorToPosition(start);
          }
        };
        this.toJSON = function () {
          if (this.rangeCount) {
            var data = this.ranges.map(function (r) {
              var r1 = r.clone();
              r1.isBackwards = r.cursor == r.start;
              return r1;
            });
          } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
          }
          return data;
        };
        this.fromJSON = function (data) {
          if (data.start == undefined) {
            if (this.rangeList) {
              this.toSingleRange(data[0]);
              for (var i = data.length; i--;) {
                var r = Range.fromPoints(data[i].start, data[i].end);
                if (data[i].isBackwards) r.cursor = r.start;
                this.addRange(r, true);
              }
              return;
            } else data = data[0];
          }
          if (this.rangeList) this.toSingleRange(data);
          this.setSelectionRange(data, data.isBackwards);
        };
        this.isEqual = function (data) {
          if ((data.length || this.rangeCount) && data.length != this.rangeCount) return false;
          if (!data.length || !this.ranges) return this.getRange().isEqual(data);
          for (var i = this.ranges.length; i--;) {
            if (!this.ranges[i].isEqual(data[i])) return false;
          }
          return true;
        };
      }).call(Selection.prototype);
      exports.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function (acequire, exports, module) {
      "use strict";

      var config = acequire("./config");
      var MAX_TOKEN_COUNT = 2000;
      var Tokenizer = function Tokenizer(rules) {
        this.states = rules;
        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
          var state = this.states[key];
          var ruleRegExps = [];
          var matchTotal = 0;
          var mapping = this.matchMappings[key] = {
            defaultToken: "text"
          };
          var flag = "g";
          var splitterRurles = [];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive) flag = "gi";
            if (rule.regex == null) continue;
            if (rule.regex instanceof RegExp) rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
              if (rule.token.length == 1 || matchcount == 1) {
                rule.token = rule.token[0];
              } else if (matchcount - 1 != rule.token.length) {
                this.reportError("number of classes and regexp groups doesn't match", {
                  rule: rule,
                  groupCount: matchcount - 1
                });
                rule.token = rule.token[0];
              } else {
                rule.tokenArray = rule.token;
                rule.token = null;
                rule.onMatch = this.$arrayTokens;
              }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
              if (matchcount > 1) rule.onMatch = this.$applyToken;else rule.onMatch = rule.token;
            }
            if (matchcount > 1) {
              if (/\\\d/.test(rule.regex)) {
                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                  return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                });
              } else {
                matchcount = 1;
                adjustedregex = this.removeCapturingGroups(rule.regex);
              }
              if (!rule.splitRegex && typeof rule.token != "string") splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;
            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch) rule.onMatch = null;
          }
          if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
          }
          splitterRurles.forEach(function (rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
          }, this);
          this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
      };
      (function () {
        this.$setMaxTokenCount = function (m) {
          MAX_TOKEN_COUNT = m | 0;
        };
        this.$applyToken = function (str) {
          var values = this.splitRegex.exec(str).slice(1);
          var types = this.token.apply(this, values);
          if (typeof types === "string") return [{
            type: types,
            value: str
          }];
          var tokens = [];
          for (var i = 0, l = types.length; i < l; i++) {
            if (values[i]) tokens[tokens.length] = {
              type: types[i],
              value: values[i]
            };
          }
          return tokens;
        };
        this.$arrayTokens = function (str) {
          if (!str) return [];
          var values = this.splitRegex.exec(str);
          if (!values) return "text";
          var tokens = [];
          var types = this.tokenArray;
          for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1]) tokens[tokens.length] = {
              type: types[i],
              value: values[i + 1]
            };
          }
          return tokens;
        };
        this.removeCapturingGroups = function (src) {
          var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) {
            return y ? "(?:" : x;
          });
          return r;
        };
        this.createSplitterRegexp = function (src, flag) {
          if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
              if (inChClass) {
                inChClass = square != "]";
              } else if (square) {
                inChClass = true;
              } else if (parenClose) {
                if (stack == lastCapture.stack) {
                  lastCapture.end = index + 1;
                  lastCapture.stack = -1;
                }
                stack--;
              } else if (parenOpen) {
                stack++;
                if (parenOpen.length != 1) {
                  lastCapture.stack = stack;
                  lastCapture.start = index;
                }
              }
              return m;
            });
            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
          }
          if (src.charAt(0) != "^") src = "^" + src;
          if (src.charAt(src.length - 1) != "$") src += "$";
          return new RegExp(src, (flag || "").replace("g", ""));
        };
        this.getLineTokens = function (line, startState) {
          if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
              stack.shift();
              startState = stack.shift();
            }
          } else var stack = [];
          var currentState = startState || "start";
          var state = this.states[currentState];
          if (!state) {
            currentState = "start";
            state = this.states[currentState];
          }
          var mapping = this.matchMappings[currentState];
          var re = this.regExps[currentState];
          re.lastIndex = 0;
          var match,
            tokens = [];
          var lastIndex = 0;
          var matchAttempts = 0;
          var token = {
            type: null,
            value: ""
          };
          while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;
            if (index - value.length > lastIndex) {
              var skipped = line.substring(lastIndex, index - value.length);
              if (token.type == type) {
                token.value += skipped;
              } else {
                if (token.type) tokens.push(token);
                token = {
                  type: type,
                  value: skipped
                };
              }
            }
            for (var i = 0; i < match.length - 2; i++) {
              if (match[i + 1] === undefined) continue;
              rule = state[mapping[i]];
              if (rule.onMatch) type = rule.onMatch(value, currentState, stack, line);else type = rule.token;
              if (rule.next) {
                if (typeof rule.next == "string") {
                  currentState = rule.next;
                } else {
                  currentState = rule.next(currentState, stack);
                }
                state = this.states[currentState];
                if (!state) {
                  this.reportError("state doesn't exist", currentState);
                  currentState = "start";
                  state = this.states[currentState];
                }
                mapping = this.matchMappings[currentState];
                lastIndex = index;
                re = this.regExps[currentState];
                re.lastIndex = index;
              }
              if (rule.consumeLineEnd) lastIndex = index;
              break;
            }
            if (value) {
              if (typeof type === "string") {
                if ((!rule || rule.merge !== false) && token.type === type) {
                  token.value += value;
                } else {
                  if (token.type) tokens.push(token);
                  token = {
                    type: type,
                    value: value
                  };
                }
              } else if (type) {
                if (token.type) tokens.push(token);
                token = {
                  type: null,
                  value: ""
                };
                for (var i = 0; i < type.length; i++) tokens.push(type[i]);
              }
            }
            if (lastIndex == line.length) break;
            lastIndex = index;
            if (matchAttempts++ > MAX_TOKEN_COUNT) {
              if (matchAttempts > 2 * line.length) {
                this.reportError("infinite loop with in ace tokenizer", {
                  startState: startState,
                  line: line
                });
              }
              while (lastIndex < line.length) {
                if (token.type) tokens.push(token);
                token = {
                  value: line.substring(lastIndex, lastIndex += 2000),
                  type: "overflow"
                };
              }
              currentState = "start";
              stack = [];
              break;
            }
          }
          if (token.type) tokens.push(token);
          if (stack.length > 1) {
            if (stack[0] !== currentState) stack.unshift("#tmp", currentState);
          }
          return {
            tokens: tokens,
            state: stack.length ? stack : currentState
          };
        };
        this.reportError = config.reportError;
      }).call(Tokenizer.prototype);
      exports.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function (acequire, exports, module) {
      "use strict";

      var lang = acequire("../lib/lang");
      var TextHighlightRules = function TextHighlightRules() {
        this.$rules = {
          "start": [{
            token: "empty_line",
            regex: '^$'
          }, {
            defaultToken: "text"
          }]
        };
      };
      (function () {
        this.addRules = function (rules, prefix) {
          if (!prefix) {
            for (var key in rules) this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function () {
          return this.$rules;
        };
        this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i = 0; i < states.length; i++) states[i] = prefix + states[i];
          } else {
            states = [];
            for (var key in embedRules) states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++) addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
          }
          if (!this.$embeds) this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function () {
          return this.$embeds;
        };
        var pushState = function pushState(currentState, stack) {
          if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function popState(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function () {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              var toInsert = null;
              if (Array.isArray(rule)) {
                toInsert = rule;
                rule = {};
              }
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next) rule.next = [];
                rule.next.push({
                  defaultToken: rule.token
                }, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string") stateName = stateName[0] || "";
                  if (rules[stateName]) stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              var includeName = typeof rule == "string" ? rule : rule.include;
              if (includeName) {
                if (Array.isArray(includeName)) toInsert = includeName.map(function (x) {
                  return rules[x];
                });else toInsert = rules[includeName];
              }
              if (toInsert) {
                var args = [i, 1].concat(toInsert);
                if (rule.noEscape) args = args.filter(function (x) {
                  return !x.next;
                });
                state.splice.apply(state, args);
                i--;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
          var keywords = Object.create(null);
          Object.keys(map).forEach(function (className) {
            var a = map[className];
            if (ignoreCase) a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--;) keywords[list[i]] = className;
          });
          if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
          }
          this.$keywordList = Object.keys(keywords);
          map = null;
          return ignoreCase ? function (value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function (value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function () {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var Behaviour = function Behaviour() {
        this.$behaviours = {};
      };
      (function () {
        this.add = function (name, action, callback) {
          switch (undefined) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function (behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function (name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function (mode, filter) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
          } else {
            var behaviours = mode.getBehaviours(filter);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function (filter) {
          if (!filter) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
              if (this.$behaviours[filter[i]]) {
                ret[filter[i]] = this.$behaviours[filter[i]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports.Behaviour = Behaviour;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("./range").Range;
      var TokenIterator = function TokenIterator(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);
        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
      };
      (function () {
        this.stepBackward = function () {
          this.$tokenIndex -= 1;
          while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
              this.$row = 0;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        this.stepForward = function () {
          this.$tokenIndex += 1;
          var rowCount;
          while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount) rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
              this.$row = rowCount - 1;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        this.getCurrentToken = function () {
          return this.$rowTokens[this.$tokenIndex];
        };
        this.getCurrentTokenRow = function () {
          return this.$row;
        };
        this.getCurrentTokenColumn = function () {
          var rowTokens = this.$rowTokens;
          var tokenIndex = this.$tokenIndex;
          var column = rowTokens[tokenIndex].start;
          if (column !== undefined) return column;
          column = 0;
          while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
          }
          return column;
        };
        this.getCurrentTokenPosition = function () {
          return {
            row: this.$row,
            column: this.getCurrentTokenColumn()
          };
        };
        this.getCurrentTokenRange = function () {
          var token = this.$rowTokens[this.$tokenIndex];
          var column = this.getCurrentTokenColumn();
          return new Range(this.$row, column, this.$row, column + token.value.length);
        };
      }).call(TokenIterator.prototype);
      exports.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../../lib/oop");
      var Behaviour = acequire("../behaviour").Behaviour;
      var TokenIterator = acequire("../../token_iterator").TokenIterator;
      var lang = acequire("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = {
        '"': '"',
        "'": "'"
      };
      var initContext = function initContext(editor) {
        var id = -1;
        if (editor.multiSelect) {
          id = editor.selection.index;
          if (contextCache.rangeCount != editor.multiSelect.rangeCount) contextCache = {
            rangeCount: editor.multiSelect.rangeCount
          };
        }
        if (contextCache[id]) return context = contextCache[id];
        context = contextCache[id] = {
          autoInsertedBrackets: 0,
          autoInsertedRow: -1,
          autoInsertedLineEnd: "",
          maybeInsertedBrackets: 0,
          maybeInsertedRow: -1,
          maybeInsertedLineStart: "",
          maybeInsertedLineEnd: ""
        };
      };
      var getWrapped = function getWrapped(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
          text: opening + selected + closing,
          selection: [0, selection.start.column + 1, rowDiff, selection.end.column + (rowDiff ? 0 : 1)]
        };
      };
      var CstyleBehaviour = function CstyleBehaviour(options) {
        this.add("braces", "insertion", function (state, action, editor, session, text) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, '{', '}');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                  text: '{}',
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                return {
                  text: '{',
                  selection: [1, 1]
                };
              }
            }
          } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
              var matching = session.$findOpeningBracket('}', {
                column: cursor.column + 1,
                row: cursor.row
              });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
              var openBracePos = session.findMatchingBracket({
                row: cursor.row,
                column: cursor.column + 1
              }, '}');
              if (!openBracePos) return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: '\n' + indent + '\n' + next_indent + closing,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function (state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function (state, action, editor, session, text) {
          if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, ")");
              return {
                text: '()',
                selection: [1, 1]
              };
            }
          } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
              var matching = session.$findOpeningBracket(')', {
                column: cursor.column + 1,
                row: cursor.row
              });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function (state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function (state, action, editor, session, text) {
          if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, "]");
              return {
                text: '[]',
                selection: [1, 1]
              };
            }
          } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
              var matching = session.$findOpeningBracket(']', {
                column: cursor.column + 1,
                row: cursor.row
              });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function (state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var token = session.getTokenAt(cursor.row, cursor.column);
              var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
              if (leftChar == "\\" && token && /escape/.test(token.type)) return null;
              var stringBefore = token && /string|escape/.test(token.type);
              var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
              var pair;
              if (rightChar == quote) {
                pair = stringBefore !== stringAfter;
                if (pair && /string\.end/.test(rightToken.type)) pair = false;
              } else {
                if (stringBefore && !stringAfter) return null; // wrap string with different quote
                if (stringBefore && stringAfter) return null; // do not pair quotes inside strings
                var wordRe = session.$mode.tokenRe;
                wordRe.lastIndex = 0;
                var isWordBefore = wordRe.test(leftChar);
                wordRe.lastIndex = 0;
                var isWordAfter = wordRe.test(leftChar);
                if (isWordBefore || isWordAfter) return null; // before or after alphanumeric
                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar)) return null; // there is rightChar and it isn't closing
                pair = true;
              }
              return {
                text: pair ? quote + quote : "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
      };
      CstyleBehaviour.isSaneInsertion = function (editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour.$matchTokenType = function (token, types) {
        return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line)) context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour.popAutoInsertedClosing = function () {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour.clearMaybeInsertedClosing = function () {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports.CstyleBehaviour = CstyleBehaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      exports.packages = {};
      addUnicodePackage({
        L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
        Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
        Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
        Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
        Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
        Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
        M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
        Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
        Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
        Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
        N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
        Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
        Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
        No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
        P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
        Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
        Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
        Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
        Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
        Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
        Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
        Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
        S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
        Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
        Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
        Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
        So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
        Z: "002000A01680180E2000-200A20282029202F205F3000",
        Zs: "002000A01680180E2000-200A202F205F3000",
        Zl: "2028",
        Zp: "2029",
        C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
        Cc: "0000-001F007F-009F",
        Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
        Co: "E000-F8FF",
        Cs: "D800-DFFF",
        Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
      });
      function addUnicodePackage(pack) {
        var codePoint = /\w{4}/g;
        for (var name in pack) exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
      }
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var Tokenizer = acequire("../tokenizer").Tokenizer;
      var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
      var unicode = acequire("../unicode");
      var lang = acequire("../lib/lang");
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      var Range = acequire("../range").Range;
      var Mode = function Mode() {
        this.HighlightRules = TextHighlightRules;
      };
      (function () {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+", "g");
        this.getTokenizer = function () {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function (state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment) return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function comment(line, i) {
              if (testRemove(line, i)) return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({
                  row: i,
                  column: line.length
                }, lineCommentEnd);
                doc.insertInLine({
                  row: i,
                  column: minIndent
                }, lineCommentStart);
              }
            };
            var uncomment = function uncomment(line, i) {
              var m;
              if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
              if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function testRemove(line, row) {
              if (regexpStart.test(line)) return true;
              var tokens = session.getTokens(row);
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].type === "comment") return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function uncomment(line, i) {
              var m = line.match(regexpStart);
              if (!m) return;
              var start = m[1].length,
                end = m[0].length;
              if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
              doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function comment(line, i) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({
                  row: i,
                  column: minIndent
                }, commentWithSpace);else doc.insertInLine({
                  row: i,
                  column: minIndent
                }, lineCommentStart);
              }
            };
            var testRemove = function testRemove(line, i) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function shouldInsertSpace(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ") spaces++;
              if (spaces % tabSize != 0) return false;
              var spaces = 0;
              while (line.charAt(after++) == " ") spaces++;
              if (tabSize > 2) return spaces % tabSize != tabSize - 1;else return spaces % tabSize == 0;
              return true;
            };
          }
          function iter(fun) {
            for (var i = startRow; i <= endRow; i++) fun(doc.getLine(i), i);
          }
          var minEmptyLength = Infinity;
          iter(function (line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent) minIndent = indent;
              if (shouldRemove && !testRemove(line, i)) shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function (state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment) return;
          if (!comment.start && comment[0]) comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          var sel = session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow, colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.start);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.end);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange) session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function (state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function (state, line, input) {
          return false;
        };
        this.autoOutdent = function (state, doc, row) {};
        this.$getIndent = function (line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function (session) {
          return null;
        };
        this.createModeDelegates = function (mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i in mapping) {
            if (mapping[i]) {
              this.$embeds.push(i);
              this.$modes[i] = new mapping[i]();
            }
          }
          var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
          for (var i = 0; i < delegations.length; i++) {
            (function (scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function () {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            })(this);
          }
        };
        this.$delegator = function (method, args, defaultHandler) {
          var state = args[0];
          if (typeof state != "string") state = state[0];
          for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
              args[0] = split[1];
              var mode = this.$modes[this.$embeds[i]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : undefined;
        };
        this.transformAction = function (state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function (append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0, l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append) return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function () {
          if (!this.$highlightRules) this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function (state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function (word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports.Mode = Mode;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
      }
      function positionInDocument(docLines, position) {
        return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
      }
      function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
      }
      exports.applyDelta = function (docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Anchor = exports.Anchor = function (doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);
        if (typeof column == "undefined") this.setPosition(row.row, row.column);else this.setPosition(row, column);
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.getPosition = function () {
          return this.$clipPositionToDocument(this.row, this.column);
        };
        this.getDocument = function () {
          return this.document;
        };
        this.$insertRight = false;
        this.onChange = function (delta) {
          if (delta.start.row == delta.end.row && delta.start.row != this.row) return;
          if (delta.start.row > this.row) return;
          var point = $getTransformedPoint(delta, {
            row: this.row,
            column: this.column
          }, this.$insertRight);
          this.setPosition(point.row, point.column, true);
        };
        function $pointsInOrder(point1, point2, equalPointsInOrder) {
          var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
          return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
        }
        function $getTransformedPoint(delta, point, moveIfEqual) {
          var deltaIsInsert = delta.action == "insert";
          var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
          var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
          var deltaStart = delta.start;
          var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
          if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
              row: point.row,
              column: point.column
            };
          }
          if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
              row: point.row + deltaRowShift,
              column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
          }
          return {
            row: deltaStart.row,
            column: deltaStart.column
          };
        }
        this.setPosition = function (row, column, noClip) {
          var pos;
          if (noClip) {
            pos = {
              row: row,
              column: column
            };
          } else {
            pos = this.$clipPositionToDocument(row, column);
          }
          if (this.row == pos.row && this.column == pos.column) return;
          var old = {
            row: this.row,
            column: this.column
          };
          this.row = pos.row;
          this.column = pos.column;
          this._signal("change", {
            old: old,
            value: pos
          });
        };
        this.detach = function () {
          this.document.removeEventListener("change", this.$onChange);
        };
        this.attach = function (doc) {
          this.document = doc || this.document;
          this.document.on("change", this.$onChange);
        };
        this.$clipPositionToDocument = function (row, column) {
          var pos = {};
          if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
          } else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
          } else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
          }
          if (column < 0) pos.column = 0;
          return pos;
        };
      }).call(Anchor.prototype);
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var applyDelta = acequire("./apply_delta").applyDelta;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Range = acequire("./range").Range;
      var Anchor = acequire("./anchor").Anchor;
      var Document = function Document(textOrLines) {
        this.$lines = [""];
        if (textOrLines.length === 0) {
          this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
          this.insertMergedLines({
            row: 0,
            column: 0
          }, textOrLines);
        } else {
          this.insert({
            row: 0,
            column: 0
          }, textOrLines);
        }
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.setValue = function (text) {
          var len = this.getLength() - 1;
          this.remove(new Range(0, 0, len, this.getLine(len).length));
          this.insert({
            row: 0,
            column: 0
          }, text);
        };
        this.getValue = function () {
          return this.getAllLines().join(this.getNewLineCharacter());
        };
        this.createAnchor = function (row, column) {
          return new Anchor(this, row, column);
        };
        if ("aaa".split(/a/).length === 0) {
          this.$split = function (text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
          };
        } else {
          this.$split = function (text) {
            return text.split(/\r\n|\r|\n/);
          };
        }
        this.$detectNewLine = function (text) {
          var match = text.match(/^.*?(\r\n|\r|\n)/m);
          this.$autoNewLine = match ? match[1] : "\n";
          this._signal("changeNewLineMode");
        };
        this.getNewLineCharacter = function () {
          switch (this.$newLineMode) {
            case "windows":
              return "\r\n";
            case "unix":
              return "\n";
            default:
              return this.$autoNewLine || "\n";
          }
        };
        this.$autoNewLine = "";
        this.$newLineMode = "auto";
        this.setNewLineMode = function (newLineMode) {
          if (this.$newLineMode === newLineMode) return;
          this.$newLineMode = newLineMode;
          this._signal("changeNewLineMode");
        };
        this.getNewLineMode = function () {
          return this.$newLineMode;
        };
        this.isNewLine = function (text) {
          return text == "\r\n" || text == "\r" || text == "\n";
        };
        this.getLine = function (row) {
          return this.$lines[row] || "";
        };
        this.getLines = function (firstRow, lastRow) {
          return this.$lines.slice(firstRow, lastRow + 1);
        };
        this.getAllLines = function () {
          return this.getLines(0, this.getLength());
        };
        this.getLength = function () {
          return this.$lines.length;
        };
        this.getTextRange = function (range) {
          return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        this.getLinesForRange = function (range) {
          var lines;
          if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
          } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
          }
          return lines;
        };
        this.insertLines = function (row, lines) {
          console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
          return this.insertFullLines(row, lines);
        };
        this.removeLines = function (firstRow, lastRow) {
          console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
          return this.removeFullLines(firstRow, lastRow);
        };
        this.insertNewLine = function (position) {
          console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
          return this.insertMergedLines(position, ["", ""]);
        };
        this.insert = function (position, text) {
          if (this.getLength() <= 1) this.$detectNewLine(text);
          return this.insertMergedLines(position, this.$split(text));
        };
        this.insertInLine = function (position, text) {
          var start = this.clippedPos(position.row, position.column);
          var end = this.pos(position.row, position.column + text.length);
          this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
          }, true);
          return this.clonePos(end);
        };
        this.clippedPos = function (row, column) {
          var length = this.getLength();
          if (row === undefined) {
            row = length;
          } else if (row < 0) {
            row = 0;
          } else if (row >= length) {
            row = length - 1;
            column = undefined;
          }
          var line = this.getLine(row);
          if (column == undefined) column = line.length;
          column = Math.min(Math.max(column, 0), line.length);
          return {
            row: row,
            column: column
          };
        };
        this.clonePos = function (pos) {
          return {
            row: pos.row,
            column: pos.column
          };
        };
        this.pos = function (row, column) {
          return {
            row: row,
            column: column
          };
        };
        this.$clipPosition = function (position) {
          var length = this.getLength();
          if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
          } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
          }
          return position;
        };
        this.insertFullLines = function (row, lines) {
          row = Math.min(Math.max(row, 0), this.getLength());
          var column = 0;
          if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
          } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
          }
          this.insertMergedLines({
            row: row,
            column: column
          }, lines);
        };
        this.insertMergedLines = function (position, lines) {
          var start = this.clippedPos(position.row, position.column);
          var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
          };
          this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
          });
          return this.clonePos(end);
        };
        this.remove = function (range) {
          var start = this.clippedPos(range.start.row, range.start.column);
          var end = this.clippedPos(range.end.row, range.end.column);
          this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({
              start: start,
              end: end
            })
          });
          return this.clonePos(start);
        };
        this.removeInLine = function (row, startColumn, endColumn) {
          var start = this.clippedPos(row, startColumn);
          var end = this.clippedPos(row, endColumn);
          this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({
              start: start,
              end: end
            })
          }, true);
          return this.clonePos(start);
        };
        this.removeFullLines = function (firstRow, lastRow) {
          firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
          lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
          var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
          var deleteLastNewLine = lastRow < this.getLength() - 1;
          var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
          var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
          var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
          var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
          var range = new Range(startRow, startCol, endRow, endCol);
          var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
          this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
          });
          return deletedLines;
        };
        this.removeNewLine = function (row) {
          if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
              start: this.pos(row, this.getLine(row).length),
              end: this.pos(row + 1, 0),
              action: "remove",
              lines: ["", ""]
            });
          }
        };
        this.replace = function (range, text) {
          if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
          if (text.length === 0 && range.isEmpty()) return range.start;
          if (text == this.getTextRange(range)) return range.end;
          this.remove(range);
          var end;
          if (text) {
            end = this.insert(range.start, text);
          } else {
            end = range.start;
          }
          return end;
        };
        this.applyDeltas = function (deltas) {
          for (var i = 0; i < deltas.length; i++) {
            this.applyDelta(deltas[i]);
          }
        };
        this.revertDeltas = function (deltas) {
          for (var i = deltas.length - 1; i >= 0; i--) {
            this.revertDelta(deltas[i]);
          }
        };
        this.applyDelta = function (delta, doNotValidate) {
          var isInsert = delta.action == "insert";
          if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
            return;
          }
          if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
          applyDelta(this.$lines, delta, doNotValidate);
          this._signal("change", delta);
        };
        this.$splitAndapplyLargeDelta = function (delta, MAX) {
          var lines = delta.lines;
          var l = lines.length;
          var row = delta.start.row;
          var column = delta.start.column;
          var from = 0,
            to = 0;
          do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
              delta.lines = chunk;
              delta.start.row = row + from;
              delta.start.column = column;
              break;
            }
            chunk.push("");
            this.applyDelta({
              start: this.pos(row + from, column),
              end: this.pos(row + to, column = 0),
              action: delta.action,
              lines: chunk
            }, true);
          } while (true);
        };
        this.revertDelta = function (delta) {
          this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: delta.action == "insert" ? "remove" : "insert",
            lines: delta.lines.slice()
          });
        };
        this.indexToPosition = function (index, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0) return {
              row: i,
              column: index + lines[i].length + newlineLength
            };
          }
          return {
            row: l - 1,
            column: lines[l - 1].length
          };
        };
        this.positionToIndex = function (pos, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          var index = 0;
          var row = Math.min(pos.row, lines.length);
          for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;
          return index + pos.column;
        };
      }).call(Document.prototype);
      exports.Document = Document;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = function BackgroundTokenizer(tokenizer, editor) {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;
        var self = this;
        this.$worker = function () {
          if (!self.running) {
            return;
          }
          var workerStart = new Date();
          var currentLine = self.currentLine;
          var endLine = -1;
          var doc = self.doc;
          var startLine = currentLine;
          while (self.lines[currentLine]) currentLine++;
          var len = doc.getLength();
          var processedLines = 0;
          self.running = false;
          while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
              currentLine++;
            } while (self.lines[currentLine]);
            processedLines++;
            if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
              self.running = setTimeout(self.$worker, 20);
              break;
            }
          }
          self.currentLine = currentLine;
          if (endLine == -1) endLine = currentLine;
          if (startLine <= endLine) self.fireUpdateEvent(startLine, endLine);
        };
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.setTokenizer = function (tokenizer) {
          this.tokenizer = tokenizer;
          this.lines = [];
          this.states = [];
          this.start(0);
        };
        this.setDocument = function (doc) {
          this.doc = doc;
          this.lines = [];
          this.states = [];
          this.stop();
        };
        this.fireUpdateEvent = function (firstRow, lastRow) {
          var data = {
            first: firstRow,
            last: lastRow
          };
          this._signal("update", {
            data: data
          });
        };
        this.start = function (startRow) {
          this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
          this.lines.splice(this.currentLine, this.lines.length);
          this.states.splice(this.currentLine, this.states.length);
          this.stop();
          this.running = setTimeout(this.$worker, 700);
        };
        this.scheduleStart = function () {
          if (!this.running) this.running = setTimeout(this.$worker, 700);
        };
        this.$updateOnChange = function (delta) {
          var startRow = delta.start.row;
          var len = delta.end.row - startRow;
          if (len === 0) {
            this.lines[startRow] = null;
          } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
          }
          this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
          this.stop();
        };
        this.stop = function () {
          if (this.running) clearTimeout(this.running);
          this.running = false;
        };
        this.getTokens = function (row) {
          return this.lines[row] || this.$tokenizeRow(row);
        };
        this.getState = function (row) {
          if (this.currentLine == row) this.$tokenizeRow(row);
          return this.states[row] || "start";
        };
        this.$tokenizeRow = function (row) {
          var line = this.doc.getLine(row);
          var state = this.states[row - 1];
          var data = this.tokenizer.getLineTokens(line, state, row);
          if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1) this.currentLine = row + 1;
          } else if (this.currentLine == row) {
            this.currentLine = row + 1;
          }
          return this.lines[row] = data.tokens;
        };
      }).call(BackgroundTokenizer.prototype);
      exports.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var Range = acequire("./range").Range;
      var SearchHighlight = function SearchHighlight(regExp, clazz, type) {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type || "text";
      };
      (function () {
        this.MAX_RANGES = 500;
        this.setRegexp = function (regExp) {
          if (this.regExp + "" == regExp + "") return;
          this.regExp = regExp;
          this.cache = [];
        };
        this.update = function (html, markerLayer, session, config) {
          if (!this.regExp) return;
          var start = config.firstRow,
            end = config.lastRow;
          for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
              ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
              if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
              ranges = ranges.map(function (match) {
                return new Range(i, match.offset, i, match.offset + match.length);
              });
              this.cache[i] = ranges.length ? ranges : "";
            }
            for (var j = ranges.length; j--;) {
              markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
            }
          }
        };
      }).call(SearchHighlight.prototype);
      exports.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("../range").Range;
      function FoldLine(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
          this.folds = folds;
        } else {
          folds = this.folds = [folds];
        }
        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
        this.start = this.range.start;
        this.end = this.range.end;
        this.folds.forEach(function (fold) {
          fold.setFoldLine(this);
        }, this);
      }
      (function () {
        this.shiftRow = function (shift) {
          this.start.row += shift;
          this.end.row += shift;
          this.folds.forEach(function (fold) {
            fold.start.row += shift;
            fold.end.row += shift;
          });
        };
        this.addFold = function (fold) {
          if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
              throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function (a, b) {
              return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            }
          } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
          } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
          } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
          }
          fold.foldLine = this;
        };
        this.containsRow = function (row) {
          return row >= this.start.row && row <= this.end.row;
        };
        this.walk = function (callback, endRow, endColumn) {
          var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp,
            stop,
            isNewRow = true;
          if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
          }
          for (var i = 0; i < folds.length; i++) {
            fold = folds[i];
            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
              callback(null, endRow, endColumn, lastEnd, isNewRow);
              return;
            }
            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
              return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
          }
          callback(null, endRow, endColumn, lastEnd, isNewRow);
        };
        this.getNextFoldTo = function (row, column) {
          var fold, cmp;
          for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              return {
                fold: fold,
                kind: "after"
              };
            } else if (cmp === 0) {
              return {
                fold: fold,
                kind: "inside"
              };
            }
          }
          return null;
        };
        this.addRemoveChars = function (row, column, len) {
          var ret = this.getNextFoldTo(row, column),
            fold,
            folds;
          if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
              window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
              folds = this.folds;
              var i = folds.indexOf(fold);
              if (i === 0) {
                this.start.column += len;
              }
              for (i; i < folds.length; i++) {
                fold = folds[i];
                fold.start.column += len;
                if (!fold.sameRow) {
                  return;
                }
                fold.end.column += len;
              }
              this.end.column += len;
            }
          }
        };
        this.split = function (row, column) {
          var pos = this.getNextFoldTo(row, column);
          if (!pos || pos.kind == "inside") return null;
          var fold = pos.fold;
          var folds = this.folds;
          var foldData = this.foldData;
          var i = folds.indexOf(fold);
          var foldBefore = folds[i - 1];
          this.end.row = foldBefore.end.row;
          this.end.column = foldBefore.end.column;
          folds = folds.splice(i, folds.length - i);
          var newFoldLine = new FoldLine(foldData, folds);
          foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
          return newFoldLine;
        };
        this.merge = function (foldLineNext) {
          var folds = foldLineNext.folds;
          for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
          }
          var foldData = this.foldData;
          foldData.splice(foldData.indexOf(foldLineNext), 1);
        };
        this.toString = function () {
          var ret = [this.range.toString() + ": ["];
          this.folds.forEach(function (fold) {
            ret.push("  " + fold.toString());
          });
          ret.push("]");
          return ret.join("\n");
        };
        this.idxToPosition = function (idx) {
          var lastFoldEndColumn = 0;
          for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];
            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
              return {
                row: fold.start.row,
                column: fold.start.column + idx
              };
            }
            idx -= fold.placeholder.length;
            if (idx < 0) {
              return fold.start;
            }
            lastFoldEndColumn = fold.end.column;
          }
          return {
            row: this.end.row,
            column: this.end.column + idx
          };
        };
      }).call(FoldLine.prototype);
      exports.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = function RangeList() {
        this.ranges = [];
      };
      (function () {
        this.comparePoints = comparePoints;
        this.pointIndex = function (pos, excludeEdges, startIndex) {
          var list = this.ranges;
          for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0) continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0) return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
            if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) return i;
            return -i - 1;
          }
          return -i - 1;
        };
        this.add = function (range) {
          var excludeEdges = !range.isEmpty();
          var startIndex = this.pointIndex(range.start, excludeEdges);
          if (startIndex < 0) startIndex = -startIndex - 1;
          var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
          if (endIndex < 0) endIndex = -endIndex - 1;else endIndex++;
          return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };
        this.addList = function (list) {
          var removed = [];
          for (var i = list.length; i--;) {
            removed.push.apply(removed, this.add(list[i]));
          }
          return removed;
        };
        this.substractPoint = function (pos) {
          var i = this.pointIndex(pos);
          if (i >= 0) return this.ranges.splice(i, 1);
        };
        this.merge = function () {
          var removed = [];
          var list = this.ranges;
          list = list.sort(function (a, b) {
            return comparePoints(a.start, b.start);
          });
          var next = list[0],
            range;
          for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0) continue;
            if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
            if (comparePoints(range.end, next.end) < 0) {
              range.end.row = next.end.row;
              range.end.column = next.end.column;
            }
            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
          }
          this.ranges = list;
          return removed;
        };
        this.contains = function (row, column) {
          return this.pointIndex({
            row: row,
            column: column
          }) >= 0;
        };
        this.containsPoint = function (pos) {
          return this.pointIndex(pos) >= 0;
        };
        this.rangeAtPoint = function (pos) {
          var i = this.pointIndex(pos);
          if (i >= 0) return this.ranges[i];
        };
        this.clipRows = function (startRow, endRow) {
          var list = this.ranges;
          if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) return [];
          var startIndex = this.pointIndex({
            row: startRow,
            column: 0
          });
          if (startIndex < 0) startIndex = -startIndex - 1;
          var endIndex = this.pointIndex({
            row: endRow,
            column: 0
          }, startIndex);
          if (endIndex < 0) endIndex = -endIndex - 1;
          var clipped = [];
          for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
          }
          return clipped;
        };
        this.removeAll = function () {
          return this.ranges.splice(0, this.ranges.length);
        };
        this.attach = function (session) {
          if (this.session) this.detach();
          this.session = session;
          this.onChange = this.$onChange.bind(this);
          this.session.on('change', this.onChange);
        };
        this.detach = function () {
          if (!this.session) return;
          this.session.removeListener('change', this.onChange);
          this.session = null;
        };
        this.$onChange = function (delta) {
          if (delta.action == "insert") {
            var start = delta.start;
            var end = delta.end;
          } else {
            var end = delta.start;
            var start = delta.end;
          }
          var startRow = start.row;
          var endRow = end.row;
          var lineDif = endRow - startRow;
          var colDiff = -start.column + end.column;
          var ranges = this.ranges;
          for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow) continue;
            if (r.start.row > startRow) break;
            if (r.start.row == startRow && r.start.column >= start.column) {
              if (r.start.column == start.column && this.$insertRight) {} else {
                r.start.column += colDiff;
                r.start.row += lineDif;
              }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
              if (r.end.column == start.column && this.$insertRight) {
                continue;
              }
              if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) r.end.column -= colDiff;
              }
              r.end.column += colDiff;
              r.end.row += lineDif;
            }
          }
          if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
              var r = ranges[i];
              r.start.row += lineDif;
              r.end.row += lineDif;
            }
          }
        };
      }).call(RangeList.prototype);
      exports.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("../range").Range;
      var RangeList = acequire("../range_list").RangeList;
      var oop = acequire("../lib/oop");
      var Fold = exports.Fold = function (range, placeholder) {
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;
        this.sameRow = range.start.row == range.end.row;
        this.subFolds = this.ranges = [];
      };
      oop.inherits(Fold, RangeList);
      (function () {
        this.toString = function () {
          return '"' + this.placeholder + '" ' + this.range.toString();
        };
        this.setFoldLine = function (foldLine) {
          this.foldLine = foldLine;
          this.subFolds.forEach(function (fold) {
            fold.setFoldLine(foldLine);
          });
        };
        this.clone = function () {
          var range = this.range.clone();
          var fold = new Fold(range, this.placeholder);
          this.subFolds.forEach(function (subFold) {
            fold.subFolds.push(subFold.clone());
          });
          fold.collapseChildren = this.collapseChildren;
          return fold;
        };
        this.addSubFold = function (fold) {
          if (this.range.isEqual(fold)) return;
          if (!this.range.containsRange(fold)) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
          consumeRange(fold, this.start);
          var row = fold.start.row,
            column = fold.start.column;
          for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1) break;
          }
          var afterStart = this.subFolds[i];
          if (cmp == 0) return afterStart.addSubFold(fold);
          var row = fold.range.end.row,
            column = fold.range.end.column;
          for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1) break;
          }
          var afterEnd = this.subFolds[j];
          if (cmp == 0) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
          var consumedFolds = this.subFolds.splice(i, j - i, fold);
          fold.setFoldLine(this.foldLine);
          return fold;
        };
        this.restoreRange = function (range) {
          return restoreRange(range, this.start);
        };
      }).call(Fold.prototype);
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0) point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0) point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("../range").Range;
      var FoldLine = acequire("./fold_line").FoldLine;
      var Fold = acequire("./fold").Fold;
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      function Folding() {
        this.getFoldAt = function (row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) return null;
          var folds = foldLine.folds;
          for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
              if (side == 1 && fold.range.isEnd(row, column)) {
                continue;
              } else if (side == -1 && fold.range.isStart(row, column)) {
                continue;
              }
              return fold;
            }
          }
        };
        this.getFoldsInRange = function (range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold = folds[j];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function (ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function (range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function () {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i = 0; i < foldLines.length; i++) for (var j = 0; j < foldLines[i].folds.length; j++) folds.push(foldLines[i].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function (row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine) return null;
          var lastFold = {
            end: {
              column: 0
            }
          };
          var str, fold;
          for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1) return str.substring(0, column - lastFold.end.column);else if (trim == 1) return str.substring(column - lastFold.end.column);else return str;
        };
        this.getFoldLine = function (docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine) i = foldData.indexOf(startFoldLine);
          if (i == -1) i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function (docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine) i = foldData.indexOf(startFoldLine);
          if (i == -1) i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function (first, last) {
          var foldData = this.$foldData,
            rowCount = last - first + 1;
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
              end = foldLine.end.row,
              start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first) rowCount -= last - start;else rowCount = 0; // in one fold
              }

              break;
            } else if (end >= first) {
              if (start >= first)
                // fold inside range
                rowCount -= end - start;else rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function (foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function (a, b) {
            return a.start.row - b.start.row;
          });
          return foldLine;
        };
        this.addFold = function (placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold) fold = placeholder;else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2)) throw new Error("The range has to be at least 2 characters width");
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold) return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn)) this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn)) this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function (subFold) {
              fold.addSubFold(subFold);
            });
          }
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", {
            data: fold,
            action: "add"
          });
          return fold;
        };
        this.addFolds = function (folds) {
          folds.forEach(function (fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function (fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);else this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", {
            data: fold,
            action: "remove"
          });
        };
        this.removeFolds = function (folds) {
          var cloneFolds = [];
          for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
          }
          cloneFolds.forEach(function (fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function (fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function (subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function (folds) {
          folds.forEach(function (fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function (location, expandInner) {
          var range, folds;
          if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
          } else if (typeof location == "number") range = new Range(location, 0, location, this.getLine(location).length);else if ("row" in location) range = Range.fromPoints(location, location);else range = location;
          folds = this.getFoldsInRangeList(range);
          if (expandInner) {
            this.removeFolds(folds);
          } else {
            var subFolds = folds;
            while (subFolds.length) {
              this.expandFolds(subFolds);
              subFolds = this.getFoldsInRangeList(range);
            }
          }
          if (folds.length) return folds;
        };
        this.isRowFolded = function (docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function (docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function (docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null) startRow = foldLine.start.row;
          if (startColumn == null) startColumn = 0;
          if (endRow == null) endRow = foldLine.end.row;
          if (endColumn == null) endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function (placeholder, row, column, lastColumn) {
            if (row < startRow) return;
            if (row == startRow) {
              if (column < startColumn) return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function () {
          var fd = [];
          fd = this.$foldData.map(function (foldLine) {
            var folds = foldLine.folds.map(function (fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function (tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({
              row: cursor.row,
              column: cursor.column + 1
            })) {
              if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;else range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4) return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function (row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          var type = token.type;
          if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment") type += "|doc-start";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re.test(token.type));
              iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
              var lastRow = -1;
              do {
                token = iterator.stepForward();
                if (lastRow == -1) {
                  var state = this.getState(iterator.$row);
                  if (!re.test(state)) lastRow = iterator.$row;
                } else if (iterator.$row > lastRow) {
                  break;
                }
              } while (token && re.test(token.type));
              token = iterator.stepBackward();
            } else token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
          }
        };
        this.foldAll = function (startRow, endRow, depth) {
          if (depth == undefined) depth = 100000; // JSON.stringify doesn't hanle Infinity
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets) return; // mode doesn't support folding
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start") continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              try {
                var fold = this.addFold("...", range);
                if (fold) fold.collapseChildren = depth;
              } catch (e) {}
            }
          }
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function (style) {
          if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style) return;
          this.$foldStyle = style;
          if (style == "manual") this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function (foldMode) {
          if (this.$foldMode == foldMode) return;
          this.$foldMode = foldMode;
          this.off('change', this.$updateFoldWidgets);
          this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on('change', this.$updateFoldWidgets);
          this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function (row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || ignoreCurrent && fw[row]) return {};
          var i = row - 1,
            firstRange;
          while (i >= 0) {
            var c = fw[i];
            if (c == null) c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
              var range = this.getFoldWidgetRange(i);
              if (!firstRange) firstRange = range;
              if (range && range.end.row >= row) break;
            }
            i--;
          }
          return {
            range: i !== -1 && range,
            firstRange: firstRange
          };
        };
        this.onFoldWidgetClick = function (row, e) {
          e = e.domEvent;
          var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = e.target || e.srcElement;
            if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function (row, options) {
          if (!this.getFoldWidget) return;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all) this.removeFold(fold);else this.expandFold(fold);
            return fold;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return fold;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
          } else if (range) {
            if (options.all) range.collapseChildren = 10000;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function (toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range) return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function (delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function (e) {
          var rows = e.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first) this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var TokenIterator = acequire("../token_iterator").TokenIterator;
      var Range = acequire("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function (position, chr) {
          if (position.column == 0) return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "") return null;
          var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match) return null;
          if (match[1]) return this.$findClosingBracket(match[1], position);else return this.$findOpeningBracket(match[2], position);
        };
        this.getBracketRange = function (pos) {
          var line = this.getLine(pos.row);
          var before = true,
            range;
          var chr = line.charAt(pos.column - 1);
          var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match) {
            chr = line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match) return null;
          if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos) return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos) return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{"
        };
        this.$findOpeningBracket = function (bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token) token = iterator.stepForward();
          if (!token) return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null) break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function (bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token) token = iterator.stepForward();
          if (!token) return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null) break;
            valueIndex = 0;
          }
          return null;
        };
      }
      exports.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var lang = acequire("./lib/lang");
      var BidiHandler = acequire("./bidihandler").BidiHandler;
      var config = acequire("./config");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Selection = acequire("./selection").Selection;
      var TextMode = acequire("./mode/text").Mode;
      var Range = acequire("./range").Range;
      var Document = acequire("./document").Document;
      var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = acequire("./search_highlight").SearchHighlight;
      var EditSession = function EditSession(text, mode) {
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;
        this.$foldData = [];
        this.id = "session" + ++EditSession.$uid;
        this.$foldData.toString = function () {
          return this.join("\n");
        };
        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);
        if (typeof text != "object" || !text.getLine) text = new Document(text);
        this.$bidiHandler = new BidiHandler(this);
        this.setDocument(text);
        this.selection = new Selection(this);
        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);
      };
      EditSession.$uid = 0;
      (function () {
        oop.implement(this, EventEmitter);
        this.setDocument = function (doc) {
          if (this.doc) this.doc.removeListener("change", this.$onChange);
          this.doc = doc;
          doc.on("change", this.$onChange);
          if (this.bgTokenizer) this.bgTokenizer.setDocument(this.getDocument());
          this.resetCaches();
        };
        this.getDocument = function () {
          return this.doc;
        };
        this.$resetRowCache = function (docRow) {
          if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
          }
          var l = this.$docRowCache.length;
          var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
          if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
          }
        };
        this.$getRowCacheIndex = function (cacheArray, val) {
          var low = 0;
          var hi = cacheArray.length - 1;
          while (low <= hi) {
            var mid = low + hi >> 1;
            var c = cacheArray[mid];
            if (val > c) low = mid + 1;else if (val < c) hi = mid - 1;else return mid;
          }
          return low - 1;
        };
        this.resetCaches = function () {
          this.$modified = true;
          this.$wrapData = [];
          this.$rowLengthCache = [];
          this.$resetRowCache(0);
          if (this.bgTokenizer) this.bgTokenizer.start(0);
        };
        this.onChangeFold = function (e) {
          var fold = e.data;
          this.$resetRowCache(fold.start.row);
        };
        this.onChange = function (delta) {
          this.$modified = true;
          this.$bidiHandler.onChange(delta);
          this.$resetRowCache(delta.start.row);
          var removedFolds = this.$updateInternalDataOnChange(delta);
          if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
              this.$deltasFold.push({
                action: "removeFolds",
                folds: removedFolds
              });
            }
            this.$informUndoManager.schedule();
          }
          this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
          this._signal("change", delta);
        };
        this.setValue = function (text) {
          this.doc.setValue(text);
          this.selection.moveTo(0, 0);
          this.$resetRowCache(0);
          this.$deltas = [];
          this.$deltasDoc = [];
          this.$deltasFold = [];
          this.setUndoManager(this.$undoManager);
          this.getUndoManager().reset();
        };
        this.getValue = this.toString = function () {
          return this.doc.getValue();
        };
        this.getSelection = function () {
          return this.selection;
        };
        this.getState = function (row) {
          return this.bgTokenizer.getState(row);
        };
        this.getTokens = function (row) {
          return this.bgTokenizer.getTokens(row);
        };
        this.getTokenAt = function (row, column) {
          var tokens = this.bgTokenizer.getTokens(row);
          var token,
            c = 0;
          if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
          } else {
            for (var i = 0; i < tokens.length; i++) {
              c += tokens[i].value.length;
              if (c >= column) break;
            }
          }
          token = tokens[i];
          if (!token) return null;
          token.index = i;
          token.start = c - token.value.length;
          return token;
        };
        this.setUndoManager = function (undoManager) {
          this.$undoManager = undoManager;
          this.$deltas = [];
          this.$deltasDoc = [];
          this.$deltasFold = [];
          if (this.$informUndoManager) this.$informUndoManager.cancel();
          if (undoManager) {
            var self = this;
            this.$syncInformUndoManager = function () {
              self.$informUndoManager.cancel();
              if (self.$deltasFold.length) {
                self.$deltas.push({
                  group: "fold",
                  deltas: self.$deltasFold
                });
                self.$deltasFold = [];
              }
              if (self.$deltasDoc.length) {
                self.$deltas.push({
                  group: "doc",
                  deltas: self.$deltasDoc
                });
                self.$deltasDoc = [];
              }
              if (self.$deltas.length > 0) {
                undoManager.execute({
                  action: "aceupdate",
                  args: [self.$deltas, self],
                  merge: self.mergeUndoDeltas
                });
              }
              self.mergeUndoDeltas = false;
              self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
          }
        };
        this.markUndoGroup = function () {
          if (this.$syncInformUndoManager) this.$syncInformUndoManager();
        };
        this.$defaultUndoManager = {
          undo: function undo() {},
          redo: function redo() {},
          reset: function reset() {}
        };
        this.getUndoManager = function () {
          return this.$undoManager || this.$defaultUndoManager;
        };
        this.getTabString = function () {
          if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
          } else {
            return "\t";
          }
        };
        this.setUseSoftTabs = function (val) {
          this.setOption("useSoftTabs", val);
        };
        this.getUseSoftTabs = function () {
          return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        this.setTabSize = function (tabSize) {
          this.setOption("tabSize", tabSize);
        };
        this.getTabSize = function () {
          return this.$tabSize;
        };
        this.isTabStop = function (position) {
          return this.$useSoftTabs && position.column % this.$tabSize === 0;
        };
        this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
          this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
        };
        this.getNavigateWithinSoftTabs = function () {
          return this.$navigateWithinSoftTabs;
        };
        this.$overwrite = false;
        this.setOverwrite = function (overwrite) {
          this.setOption("overwrite", overwrite);
        };
        this.getOverwrite = function () {
          return this.$overwrite;
        };
        this.toggleOverwrite = function () {
          this.setOverwrite(!this.$overwrite);
        };
        this.addGutterDecoration = function (row, className) {
          if (!this.$decorations[row]) this.$decorations[row] = "";
          this.$decorations[row] += " " + className;
          this._signal("changeBreakpoint", {});
        };
        this.removeGutterDecoration = function (row, className) {
          this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
          this._signal("changeBreakpoint", {});
        };
        this.getBreakpoints = function () {
          return this.$breakpoints;
        };
        this.setBreakpoints = function (rows) {
          this.$breakpoints = [];
          for (var i = 0; i < rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
          }
          this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoints = function () {
          this.$breakpoints = [];
          this._signal("changeBreakpoint", {});
        };
        this.setBreakpoint = function (row, className) {
          if (className === undefined) className = "ace_breakpoint";
          if (className) this.$breakpoints[row] = className;else delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoint = function (row) {
          delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        this.addMarker = function (range, clazz, type, inFront) {
          var id = this.$markerId++;
          var marker = {
            range: range,
            type: type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz: clazz,
            inFront: !!inFront,
            id: id
          };
          if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
          }
          return id;
        };
        this.addDynamicMarker = function (marker, inFront) {
          if (!marker.update) return;
          var id = this.$markerId++;
          marker.id = id;
          marker.inFront = !!inFront;
          if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
          }
          return marker;
        };
        this.removeMarker = function (markerId) {
          var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
          if (!marker) return;
          var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
          if (marker) {
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          }
        };
        this.getMarkers = function (inFront) {
          return inFront ? this.$frontMarkers : this.$backMarkers;
        };
        this.highlight = function (re) {
          if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
          }
          this.$searchHighlight.setRegexp(re);
        };
        this.highlightLines = function (startRow, endRow, clazz, inFront) {
          if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
          }
          if (!clazz) clazz = "ace_step";
          var range = new Range(startRow, 0, endRow, Infinity);
          range.id = this.addMarker(range, clazz, "fullLine", inFront);
          return range;
        };
        this.setAnnotations = function (annotations) {
          this.$annotations = annotations;
          this._signal("changeAnnotation", {});
        };
        this.getAnnotations = function () {
          return this.$annotations || [];
        };
        this.clearAnnotations = function () {
          this.setAnnotations([]);
        };
        this.$detectNewLine = function (text) {
          var match = text.match(/^.*?(\r?\n)/m);
          if (match) {
            this.$autoNewLine = match[1];
          } else {
            this.$autoNewLine = "\n";
          }
        };
        this.getWordRange = function (row, column) {
          var line = this.getLine(row);
          var inToken = false;
          if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);
          if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);
          if (inToken) var re = this.tokenRe;else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;else var re = this.nonTokenRe;
          var start = column;
          if (start > 0) {
            do {
              start--;
            } while (start >= 0 && line.charAt(start).match(re));
            start++;
          }
          var end = column;
          while (end < line.length && line.charAt(end).match(re)) {
            end++;
          }
          return new Range(row, start, row, end);
        };
        this.getAWordRange = function (row, column) {
          var wordRange = this.getWordRange(row, column);
          var line = this.getLine(wordRange.end.row);
          while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
          }
          return wordRange;
        };
        this.setNewLineMode = function (newLineMode) {
          this.doc.setNewLineMode(newLineMode);
        };
        this.getNewLineMode = function () {
          return this.doc.getNewLineMode();
        };
        this.setUseWorker = function (useWorker) {
          this.setOption("useWorker", useWorker);
        };
        this.getUseWorker = function () {
          return this.$useWorker;
        };
        this.onReloadTokenizer = function (e) {
          var rows = e.data;
          this.bgTokenizer.start(rows.first);
          this._signal("tokenizerUpdate", e);
        };
        this.$modes = {};
        this.$mode = null;
        this.$modeId = null;
        this.setMode = function (mode, cb) {
          if (mode && typeof mode === "object") {
            if (mode.getTokenizer) return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
          } else {
            path = mode || "ace/mode/text";
          }
          if (!this.$modes["ace/mode/text"]) this.$modes["ace/mode/text"] = new TextMode();
          if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
          }
          this.$modeId = path;
          config.loadModule(["mode", path], function (m) {
            if (this.$modeId !== path) return cb && cb();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
              m = new m.Mode(options);
              if (!options) {
                this.$modes[path] = m;
                m.$id = path;
              }
              this.$onChangeMode(m);
            }
            cb && cb();
          }.bind(this));
          if (!this.$mode) this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };
        this.$onChangeMode = function (mode, $isPlaceholder) {
          if (!$isPlaceholder) this.$modeId = mode.$id;
          if (this.$mode === mode) return;
          this.$mode = mode;
          this.$stopWorker();
          if (this.$useWorker) this.$startWorker();
          var tokenizer = mode.getTokenizer();
          if (tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
          }
          if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function (e) {
              _self._signal("tokenizerUpdate", e);
            });
          } else {
            this.bgTokenizer.setTokenizer(tokenizer);
          }
          this.bgTokenizer.setDocument(this.getDocument());
          this.tokenRe = mode.tokenRe;
          this.nonTokenRe = mode.nonTokenRe;
          if (!$isPlaceholder) {
            if (mode.attachToSession) mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
          }
        };
        this.$stopWorker = function () {
          if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
          }
        };
        this.$startWorker = function () {
          try {
            this.$worker = this.$mode.createWorker(this);
          } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
          }
        };
        this.getMode = function () {
          return this.$mode;
        };
        this.$scrollTop = 0;
        this.setScrollTop = function (scrollTop) {
          if (this.$scrollTop === scrollTop || isNaN(scrollTop)) return;
          this.$scrollTop = scrollTop;
          this._signal("changeScrollTop", scrollTop);
        };
        this.getScrollTop = function () {
          return this.$scrollTop;
        };
        this.$scrollLeft = 0;
        this.setScrollLeft = function (scrollLeft) {
          if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;
          this.$scrollLeft = scrollLeft;
          this._signal("changeScrollLeft", scrollLeft);
        };
        this.getScrollLeft = function () {
          return this.$scrollLeft;
        };
        this.getScreenWidth = function () {
          this.$computeWidth();
          if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
          return this.screenWidth;
        };
        this.getLineWidgetMaxWidth = function () {
          if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
          var width = 0;
          this.lineWidgets.forEach(function (w) {
            if (w && w.screenWidth > width) width = w.screenWidth;
          });
          return this.lineWidgetWidth = width;
        };
        this.$computeWidth = function (force) {
          if (this.$modified || force) {
            this.$modified = false;
            if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;
            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;
            for (var i = 0; i < len; i++) {
              if (i > foldStart) {
                i = foldLine.end.row + 1;
                if (i >= len) break;
                foldLine = this.$foldData[foldIndex++];
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];
              if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
          }
        };
        this.getLine = function (row) {
          return this.doc.getLine(row);
        };
        this.getLines = function (firstRow, lastRow) {
          return this.doc.getLines(firstRow, lastRow);
        };
        this.getLength = function () {
          return this.doc.getLength();
        };
        this.getTextRange = function (range) {
          return this.doc.getTextRange(range || this.selection.getRange());
        };
        this.insert = function (position, text) {
          return this.doc.insert(position, text);
        };
        this.remove = function (range) {
          return this.doc.remove(range);
        };
        this.removeFullLines = function (firstRow, lastRow) {
          return this.doc.removeFullLines(firstRow, lastRow);
        };
        this.undoChanges = function (deltas, dontSelect) {
          if (!deltas.length) return;
          this.$fromUndo = true;
          var lastUndoRange = null;
          for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
              this.doc.revertDeltas(delta.deltas);
              lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
              delta.deltas.forEach(function (foldDelta) {
                this.addFolds(foldDelta.folds);
              }, this);
            }
          }
          this.$fromUndo = false;
          lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
          return lastUndoRange;
        };
        this.redoChanges = function (deltas, dontSelect) {
          if (!deltas.length) return;
          this.$fromUndo = true;
          var lastUndoRange = null;
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
              this.doc.applyDeltas(delta.deltas);
              lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
          }
          this.$fromUndo = false;
          lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
          return lastUndoRange;
        };
        this.setUndoSelect = function (enable) {
          this.$undoSelect = enable;
        };
        this.$getUndoSelection = function (deltas, isUndo, lastUndoRange) {
          function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
          }
          var delta = deltas[0];
          var range, point;
          var lastDeltaIsInsert = false;
          if (isInsert(delta)) {
            range = Range.fromPoints(delta.start, delta.end);
            lastDeltaIsInsert = true;
          } else {
            range = Range.fromPoints(delta.start, delta.start);
            lastDeltaIsInsert = false;
          }
          for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
              point = delta.start;
              if (range.compare(point.row, point.column) == -1) {
                range.setStart(point);
              }
              point = delta.end;
              if (range.compare(point.row, point.column) == 1) {
                range.setEnd(point);
              }
              lastDeltaIsInsert = true;
            } else {
              point = delta.start;
              if (range.compare(point.row, point.column) == -1) {
                range = Range.fromPoints(delta.start, delta.start);
              }
              lastDeltaIsInsert = false;
            }
          }
          if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
              lastUndoRange.start.column += range.end.column - range.start.column;
              lastUndoRange.end.column += range.end.column - range.start.column;
            }
            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
              range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
              range.setEnd(lastUndoRange.end);
            }
          }
          return range;
        };
        this.replace = function (range, text) {
          return this.doc.replace(range, text);
        };
        this.moveText = function (fromRange, toPosition, copy) {
          var text = this.getTextRange(fromRange);
          var folds = this.getFoldsInRange(fromRange);
          var toRange = Range.fromPoints(toPosition, toPosition);
          if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
              if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) toRange.start.column += collDiff;
              if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
              toRange.start.row += rowDiff;
              toRange.end.row += rowDiff;
            }
          }
          toRange.end = this.insert(toRange.start, text);
          if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function (x) {
              x = x.clone();
              if (x.start.row == oldStart.row) x.start.column += collDiff;
              if (x.end.row == oldStart.row) x.end.column += collDiff;
              x.start.row += rowDiff;
              x.end.row += rowDiff;
              return x;
            }));
          }
          return toRange;
        };
        this.indentRows = function (startRow, endRow, indentString) {
          indentString = indentString.replace(/\t/g, this.getTabString());
          for (var row = startRow; row <= endRow; row++) this.doc.insertInLine({
            row: row,
            column: 0
          }, indentString);
        };
        this.outdentRows = function (range) {
          var rowRange = range.collapseRows();
          var deleteRange = new Range(0, 0, 0, 0);
          var size = this.getTabSize();
          for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j) if (line.charAt(j) != ' ') break;
            if (j < size && line.charAt(j) == '\t') {
              deleteRange.start.column = j;
              deleteRange.end.column = j + 1;
            } else {
              deleteRange.start.column = 0;
              deleteRange.end.column = j;
            }
            this.remove(deleteRange);
          }
        };
        this.$moveLines = function (firstRow, lastRow, dir) {
          firstRow = this.getRowFoldStart(firstRow);
          lastRow = this.getRowFoldEnd(lastRow);
          if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row - firstRow;
          } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength() - 1) return 0;
            var diff = row - lastRow;
          } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
          }
          var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
          var folds = this.getFoldsInRange(range).map(function (x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
          });
          var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
          this.doc.insertFullLines(firstRow + diff, lines);
          folds.length && this.addFolds(folds);
          return diff;
        };
        this.moveLinesUp = function (firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, -1);
        };
        this.moveLinesDown = function (firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 1);
        };
        this.duplicateLines = function (firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 0);
        };
        this.$clipRowToDocument = function (row) {
          return Math.max(0, Math.min(row, this.doc.getLength() - 1));
        };
        this.$clipColumnToRow = function (row, column) {
          if (column < 0) return 0;
          return Math.min(this.doc.getLine(row).length, column);
        };
        this.$clipPositionToDocument = function (row, column) {
          column = Math.max(0, column);
          if (row < 0) {
            row = 0;
            column = 0;
          } else {
            var len = this.doc.getLength();
            if (row >= len) {
              row = len - 1;
              column = this.doc.getLine(len - 1).length;
            } else {
              column = Math.min(this.doc.getLine(row).length, column);
            }
          }
          return {
            row: row,
            column: column
          };
        };
        this.$clipRangeToDocument = function (range) {
          if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
          } else {
            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
          }
          var len = this.doc.getLength() - 1;
          if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
          } else {
            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
          }
          return range;
        };
        this.$wrapLimit = 80;
        this.$useWrapMode = false;
        this.$wrapLimitRange = {
          min: null,
          max: null
        };
        this.setUseWrapMode = function (useWrapMode) {
          if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
              var len = this.getLength();
              this.$wrapData = Array(len);
              this.$updateWrapData(0, len - 1);
            }
            this._signal("changeWrapMode");
          }
        };
        this.getUseWrapMode = function () {
          return this.$useWrapMode;
        };
        this.setWrapLimitRange = function (min, max) {
          if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = {
              min: min,
              max: max
            };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();
            if (this.$useWrapMode) this._signal("changeWrapMode");
          }
        };
        this.adjustWrapLimit = function (desiredLimit, $printMargin) {
          var limits = this.$wrapLimitRange;
          if (limits.max < 0) limits = {
            min: $printMargin,
            max: $printMargin
          };
          var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
          if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
              this.$updateWrapData(0, this.getLength() - 1);
              this.$resetRowCache(0);
              this._signal("changeWrapLimit");
            }
            return true;
          }
          return false;
        };
        this.$constrainWrapLimit = function (wrapLimit, min, max) {
          if (min) wrapLimit = Math.max(min, wrapLimit);
          if (max) wrapLimit = Math.min(max, wrapLimit);
          return wrapLimit;
        };
        this.getWrapLimit = function () {
          return this.$wrapLimit;
        };
        this.setWrapLimit = function (limit) {
          this.setWrapLimitRange(limit, limit);
        };
        this.getWrapLimitRange = function () {
          return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
          };
        };
        this.$updateInternalDataOnChange = function (delta) {
          var useWrapMode = this.$useWrapMode;
          var action = delta.action;
          var start = delta.start;
          var end = delta.end;
          var firstRow = start.row;
          var lastRow = end.row;
          var len = lastRow - firstRow;
          var removedFolds = null;
          this.$updating = true;
          if (len != 0) {
            if (action === "remove") {
              this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
              var foldLines = this.$foldData;
              removedFolds = this.getFoldsInRange(delta);
              this.removeFolds(removedFolds);
              var foldLine = this.getFoldLine(end.row);
              var idx = 0;
              if (foldLine) {
                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                foldLine.shiftRow(-len);
                var foldLineBefore = this.getFoldLine(firstRow);
                if (foldLineBefore && foldLineBefore !== foldLine) {
                  foldLineBefore.merge(foldLine);
                  foldLine = foldLineBefore;
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= end.row) {
                  foldLine.shiftRow(-len);
                }
              }
              lastRow = firstRow;
            } else {
              var args = Array(len);
              args.unshift(firstRow, 0);
              var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
              arr.splice.apply(arr, args);
              var foldLines = this.$foldData;
              var foldLine = this.getFoldLine(firstRow);
              var idx = 0;
              if (foldLine) {
                var cmp = foldLine.range.compareInside(start.row, start.column);
                if (cmp == 0) {
                  foldLine = foldLine.split(start.row, start.column);
                  if (foldLine) {
                    foldLine.shiftRow(len);
                    foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                  }
                } else if (cmp == -1) {
                  foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                  foldLine.shiftRow(len);
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= firstRow) {
                  foldLine.shiftRow(len);
                }
              }
            }
          } else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
              removedFolds = this.getFoldsInRange(delta);
              this.removeFolds(removedFolds);
              len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
              foldLine.addRemoveChars(firstRow, start.column, len);
            }
          }
          if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
          }
          this.$updating = false;
          if (useWrapMode) this.$updateWrapData(firstRow, lastRow);else this.$updateRowLengthCache(firstRow, lastRow);
          return removedFolds;
        };
        this.$updateRowLengthCache = function (firstRow, lastRow, b) {
          this.$rowLengthCache[firstRow] = null;
          this.$rowLengthCache[lastRow] = null;
        };
        this.$updateWrapData = function (firstRow, lastRow) {
          var lines = this.doc.getAllLines();
          var tabSize = this.getTabSize();
          var wrapData = this.$wrapData;
          var wrapLimit = this.$wrapLimit;
          var tokens;
          var foldLine;
          var row = firstRow;
          lastRow = Math.min(lastRow, lines.length - 1);
          while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
              tokens = this.$getDisplayTokens(lines[row]);
              wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row++;
            } else {
              tokens = [];
              foldLine.walk(function (placeholder, row, column, lastColumn) {
                var walkTokens;
                if (placeholder != null) {
                  walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                  walkTokens[0] = PLACEHOLDER_START;
                  for (var i = 1; i < walkTokens.length; i++) {
                    walkTokens[i] = PLACEHOLDER_BODY;
                  }
                } else {
                  walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                }
                tokens = tokens.concat(walkTokens);
              }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
              wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row = foldLine.end.row + 1;
            }
          }
        };
        var CHAR = 1,
          CHAR_EXT = 2,
          PLACEHOLDER_START = 3,
          PLACEHOLDER_BODY = 4,
          PUNCTUATION = 9,
          SPACE = 10,
          TAB = 11,
          TAB_SPACE = 12;
        this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
          if (tokens.length == 0) {
            return [];
          }
          var splits = [];
          var displayLength = tokens.length;
          var lastSplit = 0,
            lastDocSplit = 0;
          var isCode = this.$wrapAsCode;
          var indentedSoftWrap = this.$indentedSoftWrap;
          var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
          function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0) return indentation;
            if (indentedSoftWrap) {
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token == SPACE) indentation += 1;else if (token == TAB) indentation += tabSize;else if (token == TAB_SPACE) continue;else break;
              }
            }
            if (isCode && indentedSoftWrap !== false) indentation += tabSize;
            return Math.min(indentation, maxIndent);
          }
          function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("").replace(/12/g, function () {
              len -= 1;
            }).replace(/2/g, function () {
              len -= 1;
            });
            if (!splits.length) {
              indent = getWrapIndent();
              splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
          }
          var indent = 0;
          while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
              addSplit(split);
              continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
              for (split; split != lastSplit - 1; split--) {
                if (tokens[split] == PLACEHOLDER_START) {
                  break;
                }
              }
              if (split > lastSplit) {
                addSplit(split);
                continue;
              }
              split = lastSplit + wrapLimit;
              for (split; split < tokens.length; split++) {
                if (tokens[split] != PLACEHOLDER_BODY) {
                  break;
                }
              }
              if (split == tokens.length) {
                break; // Breaks the while-loop.
              }

              addSplit(split);
              continue;
            }
            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
              split--;
            }
            if (isCode) {
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              while (split > minSplit && tokens[split] == PUNCTUATION) {
                split--;
              }
            } else {
              while (split > minSplit && tokens[split] < SPACE) {
                split--;
              }
            }
            if (split > minSplit) {
              addSplit(++split);
              continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT) split--;
            addSplit(split - indent);
          }
          return splits;
        };
        this.$getDisplayTokens = function (str, offset) {
          var arr = [];
          var tabSize;
          offset = offset || 0;
          for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
              tabSize = this.getScreenTabSize(arr.length + offset);
              arr.push(TAB);
              for (var n = 1; n < tabSize; n++) {
                arr.push(TAB_SPACE);
              }
            } else if (c == 32) {
              arr.push(SPACE);
            } else if (c > 39 && c < 48 || c > 57 && c < 64) {
              arr.push(PUNCTUATION);
            } else if (c >= 0x1100 && isFullWidth(c)) {
              arr.push(CHAR, CHAR_EXT);
            } else {
              arr.push(CHAR);
            }
          }
          return arr;
        };
        this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
          if (maxScreenColumn == 0) return [0, 0];
          if (maxScreenColumn == null) maxScreenColumn = Infinity;
          screenColumn = screenColumn || 0;
          var c, column;
          for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
              screenColumn += this.getScreenTabSize(screenColumn);
            } else if (c >= 0x1100 && isFullWidth(c)) {
              screenColumn += 2;
            } else {
              screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
              break;
            }
          }
          return [screenColumn, column];
        };
        this.lineWidgets = null;
        this.getRowLength = function (row) {
          if (this.lineWidgets) var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
          } else {
            return this.$wrapData[row].length + 1 + h;
          }
        };
        this.getRowLineCount = function (row) {
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
          } else {
            return this.$wrapData[row].length + 1;
          }
        };
        this.getRowWrapIndent = function (screenRow) {
          if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
          } else {
            return 0;
          }
        };
        this.getScreenLastRowColumn = function (screenRow) {
          var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
          return this.documentToScreenColumn(pos.row, pos.column);
        };
        this.getDocumentLastRowColumn = function (docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.getScreenLastRowColumn(screenRow);
        };
        this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        this.getRowSplitData = function (row) {
          if (!this.$useWrapMode) {
            return undefined;
          } else {
            return this.$wrapData[row];
          }
        };
        this.getScreenTabSize = function (screenColumn) {
          return this.$tabSize - screenColumn % this.$tabSize;
        };
        this.screenToDocumentRow = function (screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };
        this.screenToDocumentColumn = function (screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        this.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {
          if (screenRow < 0) return {
            row: 0,
            column: 0
          };
          var line;
          var docRow = 0;
          var docColumn = 0;
          var column;
          var row = 0;
          var rowLength = 0;
          var rowCache = this.$screenRowCache;
          var i = this.$getRowCacheIndex(rowCache, screenRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var maxRow = this.getLength() - 1;
          var foldLine = this.getNextFoldLine(docRow);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
              break;
            } else {
              row += rowLength;
              docRow++;
              if (docRow > foldStart) {
                docRow = foldLine.end.row + 1;
                foldLine = this.getNextFoldLine(docRow, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
            }
            if (doCache) {
              this.$docRowCache.push(docRow);
              this.$screenRowCache.push(row);
            }
          }
          if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
          } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
              row: maxRow,
              column: this.getLine(maxRow).length
            };
          } else {
            line = this.getLine(docRow);
            foldLine = null;
          }
          var wrapIndent = 0,
            splitIndex = Math.floor(screenRow - row);
          if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
              column = splits[splitIndex];
              if (splitIndex > 0 && splits.length) {
                wrapIndent = splits.indent;
                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                line = line.substring(docColumn);
              }
            }
          }
          if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex)) screenColumn = this.$bidiHandler.offsetToCol(offsetX);
          docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
          if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;
          if (foldLine) return foldLine.idxToPosition(docColumn);
          return {
            row: docRow,
            column: docColumn
          };
        };
        this.documentToScreenPosition = function (docRow, docColumn) {
          if (typeof docColumn === "undefined") var pos = this.$clipPositionToDocument(docRow.row, docRow.column);else pos = this.$clipPositionToDocument(docRow, docColumn);
          docRow = pos.row;
          docColumn = pos.column;
          var screenRow = 0;
          var foldStartRow = null;
          var fold = null;
          fold = this.getFoldAt(docRow, docColumn, 1);
          if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
          }
          var rowEnd,
            row = 0;
          var rowCache = this.$docRowCache;
          var i = this.$getRowCacheIndex(rowCache, docRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var foldLine = this.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row < docRow) {
            if (row >= foldStart) {
              rowEnd = foldLine.end.row + 1;
              if (rowEnd > docRow) break;
              foldLine = this.getNextFoldLine(rowEnd, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            } else {
              rowEnd = row + 1;
            }
            screenRow += this.getRowLength(row);
            row = rowEnd;
            if (doCache) {
              this.$docRowCache.push(row);
              this.$screenRowCache.push(screenRow);
            }
          }
          var textLine = "";
          if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
          } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
          }
          var wrapIndent = 0;
          if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
              var screenRowOffset = 0;
              while (textLine.length >= wrapRow[screenRowOffset]) {
                screenRow++;
                screenRowOffset++;
              }
              textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
              wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
          }
          return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
          };
        };
        this.documentToScreenColumn = function (row, docColumn) {
          return this.documentToScreenPosition(row, docColumn).column;
        };
        this.documentToScreenRow = function (docRow, docColumn) {
          return this.documentToScreenPosition(docRow, docColumn).row;
        };
        this.getScreenLength = function () {
          var screenRows = 0;
          var fold = null;
          if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
              fold = foldData[i];
              screenRows -= fold.end.row - fold.start.row;
            }
          } else {
            var lastRow = this.$wrapData.length;
            var row = 0,
              i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;
            while (row < lastRow) {
              var splits = this.$wrapData[row];
              screenRows += splits ? splits.length + 1 : 1;
              row++;
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = this.$foldData[i++];
                foldStart = fold ? fold.start.row : Infinity;
              }
            }
          }
          if (this.lineWidgets) screenRows += this.$getWidgetScreenLength();
          return screenRows;
        };
        this.$setFontMetrics = function (fm) {
          if (!this.$enableVarChar) return;
          this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0) return [0, 0];
            if (!maxScreenColumn) maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
              c = str.charAt(column);
              if (c === "\t") {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else {
                screenColumn += fm.getCharacterWidth(c);
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
        };
        this.destroy = function () {
          if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
          }
          this.$stopWorker();
        };
        this.isFullWidth = isFullWidth;
        function isFullWidth(c) {
          if (c < 0x1100) return false;
          return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
        }
      }).call(EditSession.prototype);
      acequire("./edit_session/folding").Folding.call(EditSession.prototype);
      acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function set(value) {
            if (!value || value == "off") value = false;else if (value == "free") value = true;else if (value == "printMargin") value = -1;else if (typeof value == "string") value = parseInt(value, 10) || false;
            if (this.$wrap == value) return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function get() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1) return "printMargin";
              if (!this.getWrapLimitRange().min) return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function set(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$modified = true;
                this.$resetRowCache(0);
                this.$updateWrapData(0, this.getLength() - 1);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {
          initialValue: true
        },
        firstLineNumber: {
          set: function set() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function set(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker) this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: {
          initialValue: true
        },
        tabSize: {
          set: function set(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;
            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
          },
          initialValue: 4,
          handlesSet: true
        },
        navigateWithinSoftTabs: {
          initialValue: false
        },
        overwrite: {
          set: function set(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function set(val) {
            this.doc.setNewLineMode(val);
          },
          get: function get() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function set(val) {
            this.setMode(val);
          },
          get: function get() {
            return this.$modeId;
          }
        }
      });
      exports.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var Range = acequire("./range").Range;
      var Search = function Search() {
        this.$options = {};
      };
      (function () {
        this.set = function (options) {
          oop.mixin(this.$options, options);
          return this;
        };
        this.getOptions = function () {
          return lang.copyObject(this.$options);
        };
        this.setOptions = function (options) {
          this.$options = options;
        };
        this.find = function (session) {
          var options = this.$options;
          var iterator = this.$matchIterator(session, options);
          if (!iterator) return false;
          var firstRange = null;
          iterator.forEach(function (sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
              firstRange = null;
              return false;
            }
            return true;
          });
          return firstRange;
        };
        this.findAll = function (session) {
          var options = this.$options;
          if (!options.needle) return [];
          this.$assembleRegExp(options);
          var range = options.range;
          var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
          var ranges = [];
          var re = options.re;
          if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
              for (var j = 0; j < len; j++) if (lines[row + j].search(re[j]) == -1) continue outer;
              var startLine = lines[row];
              var line = lines[row + len - 1];
              var startIndex = startLine.length - startLine.match(re[0])[0].length;
              var endIndex = line.match(re[len - 1])[0].length;
              if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                continue;
              }
              ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
              if (len > 2) row = row + len - 2;
            }
          } else {
            for (var i = 0; i < lines.length; i++) {
              var matches = lang.getMatchOffsets(lines[i], re);
              for (var j = 0; j < matches.length; j++) {
                var match = matches[j];
                ranges.push(new Range(i, match.offset, i, match.offset + match.length));
              }
            }
          }
          if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0,
              j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row) i++;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row) j--;
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
              ranges[i].start.row += range.start.row;
              ranges[i].end.row += range.start.row;
            }
          }
          return ranges;
        };
        this.replace = function (input, replacement) {
          var options = this.$options;
          var re = this.$assembleRegExp(options);
          if (options.$isMultiLine) return replacement;
          if (!re) return;
          var match = re.exec(input);
          if (!match || match[0].length != input.length) return null;
          replacement = input.replace(re, replacement);
          if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--;) {
              var ch = input[i];
              if (ch && ch.toLowerCase() != ch) replacement[i] = replacement[i].toUpperCase();else replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
          }
          return replacement;
        };
        this.$assembleRegExp = function (options, $disableFakeMultiline) {
          if (options.needle instanceof RegExp) return options.re = options.needle;
          var needle = options.needle;
          if (!options.needle) return options.re = false;
          if (!options.regExp) needle = lang.escapeRegExp(needle);
          if (options.wholeWord) needle = addWordBoundary(needle, options);
          var modifier = options.caseSensitive ? "gm" : "gmi";
          options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
          if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needle, modifier);
          try {
            var re = new RegExp(needle, modifier);
          } catch (e) {
            re = false;
          }
          return options.re = re;
        };
        this.$assembleMultilineRegExp = function (needle, modifier) {
          var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
          var re = [];
          for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
          } catch (e) {
            return false;
          }
          return re;
        };
        this.$matchIterator = function (session, options) {
          var re = this.$assembleRegExp(options);
          if (!re) return false;
          var backwards = options.backwards == true;
          var skipCurrent = options.skipCurrent != false;
          var range = options.range;
          var start = options.start;
          if (!start) start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
          if (start.start) start = start[skipCurrent != backwards ? "end" : "start"];
          var firstRow = range ? range.start.row : 0;
          var lastRow = range ? range.end.row : session.getLength() - 1;
          if (backwards) {
            var forEach = function forEach(callback) {
              var row = start.row;
              if (forEachInLine(row, start.column, callback)) return;
              for (row--; row >= firstRow; row--) if (forEachInLine(row, Number.MAX_VALUE, callback)) return;
              if (options.wrap == false) return;
              for (row = lastRow, firstRow = start.row; row >= firstRow; row--) if (forEachInLine(row, Number.MAX_VALUE, callback)) return;
            };
          } else {
            var forEach = function forEach(callback) {
              var row = start.row;
              if (forEachInLine(row, start.column, callback)) return;
              for (row = row + 1; row <= lastRow; row++) if (forEachInLine(row, 0, callback)) return;
              if (options.wrap == false) return;
              for (row = firstRow, lastRow = start.row; row <= lastRow; row++) if (forEachInLine(row, 0, callback)) return;
            };
          }
          if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function forEachInLine(row, offset, callback) {
              var startRow = backwards ? row - len + 1 : row;
              if (startRow < 0) return;
              var line = session.getLine(startRow);
              var startIndex = line.search(re[0]);
              if (!backwards && startIndex < offset || startIndex === -1) return;
              for (var i = 1; i < len; i++) {
                line = session.getLine(startRow + i);
                if (line.search(re[i]) == -1) return;
              }
              var endIndex = line.match(re[len - 1])[0].length;
              if (backwards && endIndex > offset) return;
              if (callback(startRow, startIndex, startRow + len - 1, endIndex)) return true;
            };
          } else if (backwards) {
            var forEachInLine = function forEachInLine(row, endIndex, callback) {
              var line = session.getLine(row);
              var matches = [];
              var m,
                last = 0;
              re.lastIndex = 0;
              while (m = re.exec(line)) {
                var length = m[0].length;
                last = m.index;
                if (!length) {
                  if (last >= line.length) break;
                  re.lastIndex = last += 1;
                }
                if (m.index + length > endIndex) break;
                matches.push(m.index, length);
              }
              for (var i = matches.length - 1; i >= 0; i -= 2) {
                var column = matches[i - 1];
                var length = matches[i];
                if (callback(row, column, row, column + length)) return true;
              }
            };
          } else {
            var forEachInLine = function forEachInLine(row, startIndex, callback) {
              var line = session.getLine(row);
              var m;
              var last = startIndex;
              re.lastIndex = startIndex;
              while (m = re.exec(line)) {
                var length = m[0].length;
                last = m.index;
                if (callback(row, last, row, last + length)) return true;
                if (!length) {
                  re.lastIndex = last += 1;
                  if (last >= line.length) return false;
                }
              }
            };
          }
          return {
            forEach: forEach
          };
        };
      }).call(Search.prototype);
      function addWordBoundary(needle, options) {
        function wordBoundary(c) {
          if (/\w/.test(c) || options.regExp) return "\\b";
          return "";
        }
        return wordBoundary(needle[0]) + needle + wordBoundary(needle[needle.length - 1]);
      }
      exports.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (acequire, exports, module) {
      "use strict";

      var keyUtil = acequire("../lib/keys");
      var useragent = acequire("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      function HashHandler(config, platform) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = true;
      }
      function MultiHashHandler(config, platform) {
        HashHandler.call(this, config, platform);
        this.$singleCommand = false;
      }
      MultiHashHandler.prototype = HashHandler.prototype;
      (function () {
        this.addCommand = function (command) {
          if (this.commands[command.name]) this.removeCommand(command);
          this.commands[command.name] = command;
          if (command.bindKey) this._buildKeyHash(command);
        };
        this.removeCommand = function (command, keepCommand) {
          var name = command && (typeof command === 'string' ? command : command.name);
          command = this.commands[name];
          if (!keepCommand) delete this.commands[name];
          var ckb = this.commandKeyBinding;
          for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
              delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
              var i = cmdGroup.indexOf(command);
              if (i != -1) {
                cmdGroup.splice(i, 1);
                if (cmdGroup.length == 1) ckb[keyId] = cmdGroup[0];
              }
            }
          }
        };
        this.bindKey = function (key, command, position) {
          if (typeof key == "object" && key) {
            if (position == undefined) position = key.position;
            key = key[this.platform];
          }
          if (!key) return;
          if (typeof command == "function") return this.addCommand({
            exec: command,
            bindKey: key,
            name: command.name || key
          });
          key.split("|").forEach(function (keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
              var parts = keyPart.split(/\s+/);
              keyPart = parts.pop();
              parts.forEach(function (keyPart) {
                var binding = this.parseKeys(keyPart);
                var id = KEY_MODS[binding.hashId] + binding.key;
                chain += (chain ? " " : "") + id;
                this._addCommandToBinding(chain, "chainKeys");
              }, this);
              chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
          }, this);
        };
        function getPosition(command) {
          return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
        }
        this._addCommandToBinding = function (keyId, command, position) {
          var ckb = this.commandKeyBinding,
            i;
          if (!command) {
            delete ckb[keyId];
          } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
          } else {
            if (!Array.isArray(ckb[keyId])) {
              ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
              ckb[keyId].splice(i, 1);
            }
            if (typeof position != "number") {
              position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
              var other = commands[i];
              var otherPos = getPosition(other);
              if (otherPos > position) break;
            }
            commands.splice(i, 0, command);
          }
        };
        this.addCommands = function (commands) {
          commands && Object.keys(commands).forEach(function (name) {
            var command = commands[name];
            if (!command) return;
            if (typeof command === "string") return this.bindKey(command, name);
            if (typeof command === "function") command = {
              exec: command
            };
            if (typeof command !== "object") return;
            if (!command.name) command.name = name;
            this.addCommand(command);
          }, this);
        };
        this.removeCommands = function (commands) {
          Object.keys(commands).forEach(function (name) {
            this.removeCommand(commands[name]);
          }, this);
        };
        this.bindKeys = function (keyList) {
          Object.keys(keyList).forEach(function (key) {
            this.bindKey(key, keyList[key]);
          }, this);
        };
        this._buildKeyHash = function (command) {
          this.bindKey(command.bindKey, command);
        };
        this.parseKeys = function (keys) {
          var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) {
            return x;
          });
          var key = parts.pop();
          var keyCode = keyUtil[key];
          if (keyUtil.FUNCTION_KEYS[keyCode]) key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();else if (!parts.length) return {
            key: key,
            hashId: -1
          };else if (parts.length == 1 && parts[0] == "shift") return {
            key: key.toUpperCase(),
            hashId: -1
          };
          var hashId = 0;
          for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
              if (typeof console != "undefined") console.error("invalid modifier " + parts[i] + " in " + keys);
              return false;
            }
            hashId |= modifier;
          }
          return {
            key: key,
            hashId: hashId
          };
        };
        this.findKeyCommand = function findKeyCommand(hashId, keyString) {
          var key = KEY_MODS[hashId] + keyString;
          return this.commandKeyBinding[key];
        };
        this.handleKeyboard = function (data, hashId, keyString, keyCode) {
          if (keyCode < 0) return;
          var key = KEY_MODS[hashId] + keyString;
          var command = this.commandKeyBinding[key];
          if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
          }
          if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
              data.$keyChain = data.$keyChain || key;
              return {
                command: "null"
              };
            }
          }
          if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1) data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0) data.$keyChain = ""; // reset keyChain
          }

          return {
            command: command
          };
        };
        this.getStatusText = function (editor, data) {
          return data.$keyChain || "";
        };
      }).call(HashHandler.prototype);
      exports.HashHandler = HashHandler;
      exports.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../lib/oop");
      var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var CommandManager = function CommandManager(platform, commands) {
        MultiHashHandler.call(this, commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function (e) {
          return e.command.exec(e.editor, e.args || {});
        });
      };
      oop.inherits(CommandManager, MultiHashHandler);
      (function () {
        oop.implement(this, EventEmitter);
        this.exec = function (command, editor, args) {
          if (Array.isArray(command)) {
            for (var i = command.length; i--;) {
              if (this.exec(command[i], editor, args)) return true;
            }
            return false;
          }
          if (typeof command === "string") command = this.commands[command];
          if (!command) return false;
          if (editor && editor.$readOnly && !command.readOnly) return false;
          if (command.isAvailable && !command.isAvailable(editor)) return false;
          var e = {
            editor: editor,
            command: command,
            args: args
          };
          e.returnValue = this._emit("exec", e);
          this._signal("afterExec", e);
          return e.returnValue === false ? false : true;
        };
        this.toggleRecording = function (editor) {
          if (this.$inReplay) return;
          editor && editor._emit("changeStatus");
          if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);
            if (!this.macro.length) this.macro = this.oldMacro;
            return this.recording = false;
          }
          if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function (e) {
              this.macro.push([e.command, e.args]);
            }.bind(this);
          }
          this.oldMacro = this.macro;
          this.macro = [];
          this.on("exec", this.$addCommandToMacro);
          return this.recording = true;
        };
        this.replay = function (editor) {
          if (this.$inReplay || !this.macro) return;
          if (this.recording) return this.toggleRecording(editor);
          try {
            this.$inReplay = true;
            this.macro.forEach(function (x) {
              if (typeof x == "string") this.exec(x, editor);else this.exec(x[0], editor, x[1]);
            }, this);
          } finally {
            this.$inReplay = false;
          }
        };
        this.trimMacro = function (m) {
          return m.map(function (x) {
            if (typeof x[0] != "string") x[0] = x[0].name;
            if (!x[1]) x = x[0];
            return x;
          });
        };
      }).call(CommandManager.prototype);
      exports.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var lang = acequire("../lib/lang");
      var config = acequire("../config");
      var Range = acequire("../range").Range;
      function bindKey(win, mac) {
        return {
          win: win,
          mac: mac
        };
      }
      exports.commands = [{
        name: "showSettingsMenu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function exec(editor) {
          config.loadModule("ace/ext/settings_menu", function (module) {
            module.init(editor);
            editor.showSettingsMenu();
          });
        },
        readOnly: true
      }, {
        name: "goToNextError",
        bindKey: bindKey("Alt-E", "F4"),
        exec: function exec(editor) {
          config.loadModule("ace/ext/error_marker", function (module) {
            module.showErrorMarker(editor, 1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "goToPreviousError",
        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
        exec: function exec(editor) {
          config.loadModule("ace/ext/error_marker", function (module) {
            module.showErrorMarker(editor, -1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "selectall",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function exec(editor) {
          editor.selectAll();
        },
        readOnly: true
      }, {
        name: "centerselection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function exec(editor) {
          editor.centerSelection();
        },
        readOnly: true
      }, {
        name: "gotoline",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function exec(editor) {
          var line = parseInt(prompt("Enter line number:"), 10);
          if (!isNaN(line)) {
            editor.gotoLine(line);
          }
        },
        readOnly: true
      }, {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function exec(editor) {
          editor.session.toggleFold(false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function exec(editor) {
          editor.session.toggleFold(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "toggleFoldWidget",
        bindKey: bindKey("F2", "F2"),
        exec: function exec(editor) {
          editor.session.toggleFoldWidget();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "toggleParentFoldWidget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function exec(editor) {
          editor.session.toggleFoldWidget(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "foldall",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function exec(editor) {
          editor.session.foldAll();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "foldOther",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function exec(editor) {
          editor.session.foldAll();
          editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "unfoldall",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function exec(editor) {
          editor.session.unfold();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "findnext",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function exec(editor) {
          editor.findNext();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "findprevious",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function exec(editor) {
          editor.findPrevious();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "selectOrFindNext",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function exec(editor) {
          if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findNext();
        },
        readOnly: true
      }, {
        name: "selectOrFindPrevious",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function exec(editor) {
          if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findPrevious();
        },
        readOnly: true
      }, {
        name: "find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function exec(editor) {
          config.loadModule("ace/ext/searchbox", function (e) {
            e.Search(editor);
          });
        },
        readOnly: true
      }, {
        name: "overwrite",
        bindKey: "Insert",
        exec: function exec(editor) {
          editor.toggleOverwrite();
        },
        readOnly: true
      }, {
        name: "selecttostart",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function exec(editor) {
          editor.getSelection().selectFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "gotostart",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function exec(editor) {
          editor.navigateFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "selectup",
        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function exec(editor) {
          editor.getSelection().selectUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "golineup",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function exec(editor, args) {
          editor.navigateUp(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttoend",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function exec(editor) {
          editor.getSelection().selectFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "gotoend",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function exec(editor) {
          editor.navigateFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "selectdown",
        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function exec(editor) {
          editor.getSelection().selectDown();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "golinedown",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function exec(editor, args) {
          editor.navigateDown(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectwordleft",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function exec(editor) {
          editor.getSelection().selectWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotowordleft",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function exec(editor) {
          editor.navigateWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttolinestart",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function exec(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotolinestart",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function exec(editor) {
          editor.navigateLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectleft",
        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function exec(editor) {
          editor.getSelection().selectLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotoleft",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function exec(editor, args) {
          editor.navigateLeft(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectwordright",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function exec(editor) {
          editor.getSelection().selectWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotowordright",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function exec(editor) {
          editor.navigateWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttolineend",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function exec(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotolineend",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function exec(editor) {
          editor.navigateLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectright",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function exec(editor) {
          editor.getSelection().selectRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotoright",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function exec(editor, args) {
          editor.navigateRight(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectpagedown",
        bindKey: "Shift-PageDown",
        exec: function exec(editor) {
          editor.selectPageDown();
        },
        readOnly: true
      }, {
        name: "pagedown",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function exec(editor) {
          editor.scrollPageDown();
        },
        readOnly: true
      }, {
        name: "gotopagedown",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function exec(editor) {
          editor.gotoPageDown();
        },
        readOnly: true
      }, {
        name: "selectpageup",
        bindKey: "Shift-PageUp",
        exec: function exec(editor) {
          editor.selectPageUp();
        },
        readOnly: true
      }, {
        name: "pageup",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function exec(editor) {
          editor.scrollPageUp();
        },
        readOnly: true
      }, {
        name: "gotopageup",
        bindKey: "PageUp",
        exec: function exec(editor) {
          editor.gotoPageUp();
        },
        readOnly: true
      }, {
        name: "scrollup",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function exec(e) {
          e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      }, {
        name: "scrolldown",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function exec(e) {
          e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      }, {
        name: "selectlinestart",
        bindKey: "Shift-Home",
        exec: function exec(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectlineend",
        bindKey: "Shift-End",
        exec: function exec(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "togglerecording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function exec(editor) {
          editor.commands.toggleRecording(editor);
        },
        readOnly: true
      }, {
        name: "replaymacro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function exec(editor) {
          editor.commands.replay(editor);
        },
        readOnly: true
      }, {
        name: "jumptomatching",
        bindKey: bindKey("Ctrl-P", "Ctrl-P"),
        exec: function exec(editor) {
          editor.jumpToMatching();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "selecttomatching",
        bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
        exec: function exec(editor) {
          editor.jumpToMatching(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "expandToMatching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function exec(editor) {
          editor.jumpToMatching(true, true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "passKeysToBrowser",
        bindKey: bindKey(null, null),
        exec: function exec() {},
        passEvent: true,
        readOnly: true
      }, {
        name: "copy",
        exec: function exec(editor) {},
        readOnly: true
      }, {
        name: "cut",
        exec: function exec(editor) {
          var range = editor.getSelectionRange();
          editor._emit("cut", range);
          if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
          }
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "paste",
        exec: function exec(editor, args) {
          editor.$handlePaste(args);
        },
        scrollIntoView: "cursor"
      }, {
        name: "removeline",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function exec(editor) {
          editor.removeLines();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
      }, {
        name: "duplicateSelection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function exec(editor) {
          editor.duplicateSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "sortlines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function exec(editor) {
          editor.sortLines();
        },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
      }, {
        name: "togglecomment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function exec(editor) {
          editor.toggleCommentLines();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "toggleBlockComment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function exec(editor) {
          editor.toggleBlockComment();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "modifyNumberUp",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function exec(editor) {
          editor.modifyNumber(1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "modifyNumberDown",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function exec(editor) {
          editor.modifyNumber(-1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function exec(editor) {
          config.loadModule("ace/ext/searchbox", function (e) {
            e.Search(editor, true);
          });
        }
      }, {
        name: "undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function exec(editor) {
          editor.undo();
        }
      }, {
        name: "redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function exec(editor) {
          editor.redo();
        }
      }, {
        name: "copylinesup",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function exec(editor) {
          editor.copyLinesUp();
        },
        scrollIntoView: "cursor"
      }, {
        name: "movelinesup",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function exec(editor) {
          editor.moveLinesUp();
        },
        scrollIntoView: "cursor"
      }, {
        name: "copylinesdown",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function exec(editor) {
          editor.copyLinesDown();
        },
        scrollIntoView: "cursor"
      }, {
        name: "movelinesdown",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function exec(editor) {
          editor.moveLinesDown();
        },
        scrollIntoView: "cursor"
      }, {
        name: "del",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function exec(editor) {
          editor.remove("right");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "backspace",
        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function exec(editor) {
          editor.remove("left");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "cut_or_delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function exec(editor) {
          if (editor.selection.isEmpty()) {
            editor.remove("left");
          } else {
            return false;
          }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolinestart",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function exec(editor) {
          editor.removeToLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolineend",
        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function exec(editor) {
          editor.removeToLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolinestarthard",
        bindKey: bindKey("Ctrl-Shift-Backspace", null),
        exec: function exec(editor) {
          var range = editor.selection.getRange();
          range.start.column = 0;
          editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolineendhard",
        bindKey: bindKey("Ctrl-Shift-Delete", null),
        exec: function exec(editor) {
          var range = editor.selection.getRange();
          range.end.column = Number.MAX_VALUE;
          editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removewordleft",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function exec(editor) {
          editor.removeWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removewordright",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function exec(editor) {
          editor.removeWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function exec(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function exec(editor) {
          editor.indent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "blockoutdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function exec(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "blockindent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function exec(editor) {
          editor.blockIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "insertstring",
        exec: function exec(editor, str) {
          editor.insert(str);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "inserttext",
        exec: function exec(editor, args) {
          editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "splitline",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function exec(editor) {
          editor.splitLine();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "transposeletters",
        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
        exec: function exec(editor) {
          editor.transposeLetters();
        },
        multiSelectAction: function multiSelectAction(editor) {
          editor.transposeSelections(1);
        },
        scrollIntoView: "cursor"
      }, {
        name: "touppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function exec(editor) {
          editor.toUpperCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "tolowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function exec(editor) {
          editor.toLowerCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "expandtoline",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function exec(editor) {
          var range = editor.selection.getRange();
          range.start.column = range.end.column = 0;
          range.end.row++;
          editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "joinlines",
        bindKey: bindKey(null, null),
        exec: function exec(editor) {
          var isBackwards = editor.selection.isBackwards();
          var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
          var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
          var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
          var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
          var selectedCount = selectedText.replace(/\n\s*/, " ").length;
          var insertLine = editor.session.doc.getLine(selectionStart.row);
          for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
              curLine = " " + curLine;
            }
            insertLine += curLine;
          }
          if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
            insertLine += editor.session.doc.getNewLineCharacter();
          }
          editor.clearSelection();
          editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
          if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
          } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
          }
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "invertSelection",
        bindKey: bindKey(null, null),
        exec: function exec(editor) {
          var endRow = editor.session.doc.getLength() - 1;
          var endCol = editor.session.doc.getLine(endRow).length;
          var ranges = editor.selection.rangeList.ranges;
          var newRanges = [];
          if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
          }
          for (var i = 0; i < ranges.length; i++) {
            if (i == ranges.length - 1) {
              if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
              }
            }
            if (i === 0) {
              if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
              }
            } else {
              newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
          }
          editor.exitMultiSelectMode();
          editor.clearSelection();
          for (var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
          }
        },
        readOnly: true,
        scrollIntoView: "none"
      }];
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function (acequire, exports, module) {
      "use strict";

      acequire("./lib/fixoldbrowsers");
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var lang = acequire("./lib/lang");
      var useragent = acequire("./lib/useragent");
      var TextInput = acequire("./keyboard/textinput").TextInput;
      var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
      var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
      var EditSession = acequire("./edit_session").EditSession;
      var Search = acequire("./search").Search;
      var Range = acequire("./range").Range;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var CommandManager = acequire("./commands/command_manager").CommandManager;
      var defaultCommands = acequire("./commands/default_commands").commands;
      var config = acequire("./config");
      var TokenIterator = acequire("./token_iterator").TokenIterator;
      var Editor = function Editor(renderer, session) {
        var container = renderer.getContainerElement();
        this.container = container;
        this.renderer = renderer;
        this.id = "editor" + ++Editor.$uid;
        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        if (typeof document == "object") {
          this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
          this.renderer.textarea = this.textInput.getElement();
          this.$mouseHandler = new MouseHandler(this);
          new FoldHandler(this);
        }
        this.keyBinding = new KeyBinding(this);
        this.$blockScrolling = 0;
        this.$search = new Search().set({
          wrap: true
        });
        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);
        this.$initOperationListeners();
        this._$emitInputEvent = lang.delayedCall(function () {
          this._signal("input", {});
          if (this.session && this.session.bgTokenizer) this.session.bgTokenizer.scheduleStart();
        }.bind(this));
        this.on("change", function (_, _self) {
          _self._$emitInputEvent.schedule(31);
        });
        this.setSession(session || new EditSession(""));
        config.resetOptions(this);
        config._signal("editor", this);
      };
      Editor.$uid = 0;
      (function () {
        oop.implement(this, EventEmitter);
        this.$initOperationListeners = function () {
          function last(a) {
            return a[a.length - 1];
          }
          this.selections = [];
          this.commands.on("exec", this.startOperation.bind(this), true);
          this.commands.on("afterExec", this.endOperation.bind(this), true);
          this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
          this.on("change", function () {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
          }.bind(this), true);
          this.on("changeSelection", function () {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
          }.bind(this), true);
        };
        this.curOp = null;
        this.prevOp = {};
        this.startOperation = function (commadEvent) {
          if (this.curOp) {
            if (!commadEvent || this.curOp.command) return;
            this.prevOp = this.curOp;
          }
          if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
          }
          this.$opResetTimer.schedule();
          this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
          };
          if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined) this.$blockScrolling++;
        };
        this.endOperation = function (e) {
          if (this.curOp) {
            if (e && e.returnValue === false) return this.curOp = null;
            this._signal("beforeEndOperation");
            var command = this.curOp.command;
            if (command.name && this.$blockScrolling > 0) this.$blockScrolling--;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
              switch (scrollIntoView) {
                case "center-animate":
                  scrollIntoView = "animate";
                case "center":
                  this.renderer.scrollCursorIntoView(null, 0.5);
                  break;
                case "animate":
                case "cursor":
                  this.renderer.scrollCursorIntoView();
                  break;
                case "selectionPart":
                  var range = this.selection.getRange();
                  var config = this.renderer.layerConfig;
                  if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                    this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                  }
                  break;
                default:
                  break;
              }
              if (scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            this.prevOp = this.curOp;
            this.curOp = null;
          }
        };
        this.$mergeableCommands = ["backspace", "del", "insertstring"];
        this.$historyTracker = function (e) {
          if (!this.$mergeUndoDeltas) return;
          var prev = this.prevOp;
          var mergeableCommands = this.$mergeableCommands;
          var shouldMerge = prev.command && e.command.name == prev.command.name;
          if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;
            shouldMerge = shouldMerge && this.mergeNextCommand // previous command allows to coalesce with
            && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
          } else {
            shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
          }

          if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
            shouldMerge = false; // the sequence is too long
          }

          if (shouldMerge) this.session.mergeUndoDeltas = true;else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
        };
        this.setKeyboardHandler = function (keyboardHandler, cb) {
          if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function (module) {
              if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module && module.handler);
              cb && cb();
            });
          } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
          }
        };
        this.getKeyboardHandler = function () {
          return this.keyBinding.getKeyboardHandler();
        };
        this.setSession = function (session) {
          if (this.session == session) return;
          if (this.curOp) this.endOperation();
          this.curOp = {};
          var oldSession = this.session;
          if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
          }
          this.session = session;
          if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.onChangeMode();
            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
          } else {
            this.selection = null;
            this.renderer.setSession(session);
          }
          this._signal("changeSession", {
            session: session,
            oldSession: oldSession
          });
          this.curOp = null;
          oldSession && oldSession._signal("changeEditor", {
            oldEditor: this
          });
          session && session._signal("changeEditor", {
            editor: this
          });
          if (session && session.bgTokenizer) session.bgTokenizer.scheduleStart();
        };
        this.getSession = function () {
          return this.session;
        };
        this.setValue = function (val, cursorPos) {
          this.session.doc.setValue(val);
          if (!cursorPos) this.selectAll();else if (cursorPos == 1) this.navigateFileEnd();else if (cursorPos == -1) this.navigateFileStart();
          return val;
        };
        this.getValue = function () {
          return this.session.getValue();
        };
        this.getSelection = function () {
          return this.selection;
        };
        this.resize = function (force) {
          this.renderer.onResize(force);
        };
        this.setTheme = function (theme, cb) {
          this.renderer.setTheme(theme, cb);
        };
        this.getTheme = function () {
          return this.renderer.getTheme();
        };
        this.setStyle = function (style) {
          this.renderer.setStyle(style);
        };
        this.unsetStyle = function (style) {
          this.renderer.unsetStyle(style);
        };
        this.getFontSize = function () {
          return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
        };
        this.setFontSize = function (size) {
          this.setOption("fontSize", size);
        };
        this.$highlightBrackets = function () {
          if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
          }
          if (this.$highlightPending) {
            return;
          }
          var self = this;
          this.$highlightPending = true;
          setTimeout(function () {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
              var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
              var range = session.$mode.getMatching(self.session);
            }
            if (range) session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
          }, 50);
        };
        this.$highlightTags = function () {
          if (this.$highlightTagPending) return;
          var self = this;
          this.$highlightTagPending = true;
          setTimeout(function () {
            self.$highlightTagPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
              return;
            }
            if (token.type.indexOf("tag-open") != -1) {
              token = iterator.stepForward();
              if (!token) return;
            }
            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            if (prevToken.value == '<') {
              do {
                prevToken = token;
                token = iterator.stepForward();
                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth++;
                  } else if (prevToken.value === '</') {
                    depth--;
                  }
                }
              } while (token && depth >= 0);
            } else {
              do {
                token = prevToken;
                prevToken = iterator.stepBackward();
                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth++;
                  } else if (prevToken.value === '</') {
                    depth--;
                  }
                }
              } while (prevToken && depth <= 0);
              iterator.stepForward();
            }
            if (!token) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
              return;
            }
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column + token.value.length);
            var sbm = session.$backMarkers[session.$tagHighlight];
            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
            }
            if (range && !session.$tagHighlight) session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
          }, 50);
        };
        this.focus = function () {
          var _self = this;
          setTimeout(function () {
            _self.textInput.focus();
          });
          this.textInput.focus();
        };
        this.isFocused = function () {
          return this.textInput.isFocused();
        };
        this.blur = function () {
          this.textInput.blur();
        };
        this.onFocus = function (e) {
          if (this.$isFocused) return;
          this.$isFocused = true;
          this.renderer.showCursor();
          this.renderer.visualizeFocus();
          this._emit("focus", e);
        };
        this.onBlur = function (e) {
          if (!this.$isFocused) return;
          this.$isFocused = false;
          this.renderer.hideCursor();
          this.renderer.visualizeBlur();
          this._emit("blur", e);
        };
        this.$cursorChange = function () {
          this.renderer.updateCursor();
        };
        this.onDocumentChange = function (delta) {
          var wrap = this.session.$useWrapMode;
          var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
          this.renderer.updateLines(delta.start.row, lastRow, wrap);
          this._signal("change", delta);
          this.$cursorChange();
          this.$updateHighlightActiveLine();
        };
        this.onTokenizerUpdate = function (e) {
          var rows = e.data;
          this.renderer.updateLines(rows.first, rows.last);
        };
        this.onScrollTopChange = function () {
          this.renderer.scrollToY(this.session.getScrollTop());
        };
        this.onScrollLeftChange = function () {
          this.renderer.scrollToX(this.session.getScrollLeft());
        };
        this.onCursorChange = function () {
          this.$cursorChange();
          if (!this.$blockScrolling) {
            config.warn("Automatically scrolling cursor into view after selection change", "this will be disabled in the next version", "set editor.$blockScrolling = Infinity to disable this message");
            this.renderer.scrollCursorIntoView();
          }
          this.$highlightBrackets();
          this.$highlightTags();
          this.$updateHighlightActiveLine();
          this._signal("changeSelection");
        };
        this.$updateHighlightActiveLine = function () {
          var session = this.getSession();
          var highlight;
          if (this.$highlightActiveLine) {
            if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1)) highlight = false;
          }
          if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
          } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
          } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
          }
        };
        this.onSelectionChange = function (e) {
          var session = this.session;
          if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
          }
          session.$selectionMarker = null;
          if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
          } else {
            this.$updateHighlightActiveLine();
          }
          var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
          this.session.highlight(re);
          this._signal("changeSelection");
        };
        this.$getSelectionHighLightRegexp = function () {
          var session = this.session;
          var selection = this.getSelectionRange();
          if (selection.isEmpty() || selection.isMultiLine()) return;
          var startOuter = selection.start.column - 1;
          var endOuter = selection.end.column + 1;
          var line = session.getLine(selection.start.row);
          var lineCols = line.length;
          var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
          if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle)) return;
          needle = line.substring(selection.start.column, selection.end.column);
          if (!/^[\w\d]+$/.test(needle)) return;
          var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
          });
          return re;
        };
        this.onChangeFrontMarker = function () {
          this.renderer.updateFrontMarkers();
        };
        this.onChangeBackMarker = function () {
          this.renderer.updateBackMarkers();
        };
        this.onChangeBreakpoint = function () {
          this.renderer.updateBreakpoints();
        };
        this.onChangeAnnotation = function () {
          this.renderer.setAnnotations(this.session.getAnnotations());
        };
        this.onChangeMode = function (e) {
          this.renderer.updateText();
          this._emit("changeMode", e);
        };
        this.onChangeWrapLimit = function () {
          this.renderer.updateFull();
        };
        this.onChangeWrapMode = function () {
          this.renderer.onResize(true);
        };
        this.onChangeFold = function () {
          this.$updateHighlightActiveLine();
          this.renderer.updateFull();
        };
        this.getSelectedText = function () {
          return this.session.getTextRange(this.getSelectionRange());
        };
        this.getCopyText = function () {
          var text = this.getSelectedText();
          this._signal("copy", text);
          return text;
        };
        this.onCopy = function () {
          this.commands.exec("copy", this);
        };
        this.onCut = function () {
          this.commands.exec("cut", this);
        };
        this.onPaste = function (text, event) {
          var e = {
            text: text,
            event: event
          };
          this.commands.exec("paste", this, e);
        };
        this.$handlePaste = function (e) {
          if (typeof e == "string") e = {
            text: e
          };
          this._signal("paste", e);
          var text = e.text;
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            this.insert(text);
          } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
            if (lines.length > ranges.length || lines.length < 2 || !lines[1]) return this.commands.exec("insertstring", this, text);
            for (var i = ranges.length; i--;) {
              var range = ranges[i];
              if (!range.isEmpty()) this.session.remove(range);
              this.session.insert(range.start, lines[i]);
            }
          }
        };
        this.execCommand = function (command, args) {
          return this.commands.exec(command, this, args);
        };
        this.insert = function (text, pasted) {
          var session = this.session;
          var mode = session.getMode();
          var cursor = this.getCursorPosition();
          if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
              if (text !== transform.text) {
                this.session.mergeUndoDeltas = false;
                this.$mergeNextCommand = false;
              }
              text = transform.text;
            }
          }
          if (text == "\t") text = this.session.getTabString();
          if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
          } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
          }
          if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
              var d = line.substr(cursor.column).search(/\S|$/);
              session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
          }
          this.clearSelection();
          var start = cursor.column;
          var lineState = session.getState(cursor.row);
          var line = session.getLine(cursor.row);
          var shouldOutdent = mode.checkOutdent(lineState, line, text);
          var end = session.insert(cursor, text);
          if (transform && transform.selection) {
            if (transform.selection.length == 2) {
              // Transform relative to the current column
              this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
            } else {
              // Transform relative to the current row.
              this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
          }
          if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
            session.insert({
              row: cursor.row + 1,
              column: 0
            }, lineIndent);
          }
          if (shouldOutdent) mode.autoOutdent(lineState, session, cursor.row);
        };
        this.onTextInput = function (text) {
          this.keyBinding.onTextInput(text);
        };
        this.onCommandKey = function (e, hashId, keyCode) {
          this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        this.setOverwrite = function (overwrite) {
          this.session.setOverwrite(overwrite);
        };
        this.getOverwrite = function () {
          return this.session.getOverwrite();
        };
        this.toggleOverwrite = function () {
          this.session.toggleOverwrite();
        };
        this.setScrollSpeed = function (speed) {
          this.setOption("scrollSpeed", speed);
        };
        this.getScrollSpeed = function () {
          return this.getOption("scrollSpeed");
        };
        this.setDragDelay = function (dragDelay) {
          this.setOption("dragDelay", dragDelay);
        };
        this.getDragDelay = function () {
          return this.getOption("dragDelay");
        };
        this.setSelectionStyle = function (val) {
          this.setOption("selectionStyle", val);
        };
        this.getSelectionStyle = function () {
          return this.getOption("selectionStyle");
        };
        this.setHighlightActiveLine = function (shouldHighlight) {
          this.setOption("highlightActiveLine", shouldHighlight);
        };
        this.getHighlightActiveLine = function () {
          return this.getOption("highlightActiveLine");
        };
        this.setHighlightGutterLine = function (shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        this.getHighlightGutterLine = function () {
          return this.getOption("highlightGutterLine");
        };
        this.setHighlightSelectedWord = function (shouldHighlight) {
          this.setOption("highlightSelectedWord", shouldHighlight);
        };
        this.getHighlightSelectedWord = function () {
          return this.$highlightSelectedWord;
        };
        this.setAnimatedScroll = function (shouldAnimate) {
          this.renderer.setAnimatedScroll(shouldAnimate);
        };
        this.getAnimatedScroll = function () {
          return this.renderer.getAnimatedScroll();
        };
        this.setShowInvisibles = function (showInvisibles) {
          this.renderer.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function () {
          return this.renderer.getShowInvisibles();
        };
        this.setDisplayIndentGuides = function (display) {
          this.renderer.setDisplayIndentGuides(display);
        };
        this.getDisplayIndentGuides = function () {
          return this.renderer.getDisplayIndentGuides();
        };
        this.setShowPrintMargin = function (showPrintMargin) {
          this.renderer.setShowPrintMargin(showPrintMargin);
        };
        this.getShowPrintMargin = function () {
          return this.renderer.getShowPrintMargin();
        };
        this.setPrintMarginColumn = function (showPrintMargin) {
          this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        this.getPrintMarginColumn = function () {
          return this.renderer.getPrintMarginColumn();
        };
        this.setReadOnly = function (readOnly) {
          this.setOption("readOnly", readOnly);
        };
        this.getReadOnly = function () {
          return this.getOption("readOnly");
        };
        this.setBehavioursEnabled = function (enabled) {
          this.setOption("behavioursEnabled", enabled);
        };
        this.getBehavioursEnabled = function () {
          return this.getOption("behavioursEnabled");
        };
        this.setWrapBehavioursEnabled = function (enabled) {
          this.setOption("wrapBehavioursEnabled", enabled);
        };
        this.getWrapBehavioursEnabled = function () {
          return this.getOption("wrapBehavioursEnabled");
        };
        this.setShowFoldWidgets = function (show) {
          this.setOption("showFoldWidgets", show);
        };
        this.getShowFoldWidgets = function () {
          return this.getOption("showFoldWidgets");
        };
        this.setFadeFoldWidgets = function (fade) {
          this.setOption("fadeFoldWidgets", fade);
        };
        this.getFadeFoldWidgets = function () {
          return this.getOption("fadeFoldWidgets");
        };
        this.remove = function (dir) {
          if (this.selection.isEmpty()) {
            if (dir == "left") this.selection.selectLeft();else this.selection.selectRight();
          }
          var range = this.getSelectionRange();
          if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
            if (range.end.column === 0) {
              var text = session.getTextRange(range);
              if (text[text.length - 1] == "\n") {
                var line = session.getLine(range.end.row);
                if (/^\s+$/.test(line)) {
                  range.end.column = line.length;
                }
              }
            }
            if (new_range) range = new_range;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        this.removeWordRight = function () {
          if (this.selection.isEmpty()) this.selection.selectWordRight();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeWordLeft = function () {
          if (this.selection.isEmpty()) this.selection.selectWordLeft();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeToLineStart = function () {
          if (this.selection.isEmpty()) this.selection.selectLineStart();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeToLineEnd = function () {
          if (this.selection.isEmpty()) this.selection.selectLineEnd();
          var range = this.getSelectionRange();
          if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        this.splitLine = function () {
          if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          }
          var cursor = this.getCursorPosition();
          this.insert("\n");
          this.moveCursorToPosition(cursor);
        };
        this.transposeLetters = function () {
          if (!this.selection.isEmpty()) {
            return;
          }
          var cursor = this.getCursorPosition();
          var column = cursor.column;
          if (column === 0) return;
          var line = this.session.getLine(cursor.row);
          var swap, range;
          if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
          } else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
          }
          this.session.replace(range, swap);
          this.session.selection.moveToPosition(range.end);
        };
        this.toLowerCase = function () {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toLowerCase());
          this.selection.setSelectionRange(originalRange);
        };
        this.toUpperCase = function () {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toUpperCase());
          this.selection.setSelectionRange(originalRange);
        };
        this.indent = function () {
          var session = this.session;
          var range = this.getSelectionRange();
          if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
          } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "\t");
              return;
            }
          }
          var line = session.getLine(range.start.row);
          var position = range.start;
          var size = session.getTabSize();
          var column = session.documentToScreenColumn(position.row, position.column);
          if (this.session.getUseSoftTabs()) {
            var count = size - column % size;
            var indentString = lang.stringRepeat(" ", count);
          } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
              range.start.column--;
              count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
          }
          return this.insert(indentString);
        };
        this.blockIndent = function () {
          var rows = this.$getSelectedRows();
          this.session.indentRows(rows.first, rows.last, "\t");
        };
        this.blockOutdent = function () {
          var selection = this.session.getSelection();
          this.session.outdentRows(selection.getRange());
        };
        this.sortLines = function () {
          var rows = this.$getSelectedRows();
          var session = this.session;
          var lines = [];
          for (var i = rows.first; i <= rows.last; i++) lines.push(session.getLine(i));
          lines.sort(function (a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
          });
          var deleteRange = new Range(0, 0, 0, 0);
          for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
          }
        };
        this.toggleCommentLines = function () {
          var state = this.session.getState(this.getCursorPosition().row);
          var rows = this.$getSelectedRows();
          this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };
        this.toggleBlockComment = function () {
          var cursor = this.getCursorPosition();
          var state = this.session.getState(cursor.row);
          var range = this.getSelectionRange();
          this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        this.getNumberAt = function (row, column) {
          var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
          _numberRx.lastIndex = 0;
          var s = this.session.getLine(row);
          while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if (m.index <= column && m.index + m[0].length >= column) {
              var number = {
                value: m[0],
                start: m.index,
                end: m.index + m[0].length
              };
              return number;
            }
          }
          return null;
        };
        this.modifyNumber = function (amount) {
          var row = this.selection.getCursor().row;
          var column = this.selection.getCursor().column;
          var charRange = new Range(row, column - 1, row, column);
          var c = this.session.getTextRange(charRange);
          if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
              var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
              var decimals = nr.start + nr.value.length - fp;
              var t = parseFloat(nr.value);
              t *= Math.pow(10, decimals);
              if (fp !== nr.end && column < fp) {
                amount *= Math.pow(10, nr.end - column - 1);
              } else {
                amount *= Math.pow(10, nr.end - column);
              }
              t += amount;
              t /= Math.pow(10, decimals);
              var nnr = t.toFixed(decimals);
              var replaceRange = new Range(row, nr.start, row, nr.end);
              this.session.replace(replaceRange, nnr);
              this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
            }
          }
        };
        this.removeLines = function () {
          var rows = this.$getSelectedRows();
          this.session.removeFullLines(rows.first, rows.last);
          this.clearSelection();
        };
        this.duplicateSelection = function () {
          var sel = this.selection;
          var doc = this.session;
          var range = sel.getRange();
          var reverse = sel.isBackwards();
          if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
          } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;
            sel.setSelectionRange(range, reverse);
          }
        };
        this.moveLinesDown = function () {
          this.$moveLines(1, false);
        };
        this.moveLinesUp = function () {
          this.$moveLines(-1, false);
        };
        this.moveText = function (range, toPosition, copy) {
          return this.session.moveText(range, toPosition, copy);
        };
        this.copyLinesUp = function () {
          this.$moveLines(-1, true);
        };
        this.copyLinesDown = function () {
          this.$moveLines(1, true);
        };
        this.$moveLines = function (dir, copy) {
          var rows, moved;
          var selection = this.selection;
          if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
          } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
              var rangeIndex = i;
              ranges[i].moveBy(diff, 0);
              rows = this.$getSelectedRows(ranges[i]);
              var first = rows.first;
              var last = rows.last;
              while (++i < l) {
                if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                var subRows = this.$getSelectedRows(ranges[i]);
                if (copy && subRows.first != last) break;else if (!copy && subRows.first > last + 1) break;
                last = subRows.last;
              }
              i--;
              diff = this.session.$moveLines(first, last, copy ? 0 : dir);
              if (copy && dir == -1) rangeIndex = i + 1;
              while (rangeIndex <= i) {
                ranges[rangeIndex].moveBy(diff, 0);
                rangeIndex++;
              }
              if (!copy) diff = 0;
              totalDiff += diff;
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
          }
        };
        this.$getSelectedRows = function (range) {
          range = (range || this.getSelectionRange()).collapseRows();
          return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
          };
        };
        this.onCompositionStart = function (text) {
          this.renderer.showComposition(this.getCursorPosition());
        };
        this.onCompositionUpdate = function (text) {
          this.renderer.setCompositionText(text);
        };
        this.onCompositionEnd = function () {
          this.renderer.hideComposition();
        };
        this.getFirstVisibleRow = function () {
          return this.renderer.getFirstVisibleRow();
        };
        this.getLastVisibleRow = function () {
          return this.renderer.getLastVisibleRow();
        };
        this.isRowVisible = function (row) {
          return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
        };
        this.isRowFullyVisible = function (row) {
          return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
        };
        this.$getVisibleRowCount = function () {
          return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };
        this.$moveByPage = function (dir, select) {
          var renderer = this.renderer;
          var config = this.renderer.layerConfig;
          var rows = dir * Math.floor(config.height / config.lineHeight);
          this.$blockScrolling++;
          if (select === true) {
            this.selection.$moveSelection(function () {
              this.moveCursorBy(rows, 0);
            });
          } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
          }
          this.$blockScrolling--;
          var scrollTop = renderer.scrollTop;
          renderer.scrollBy(0, rows * config.lineHeight);
          if (select != null) renderer.scrollCursorIntoView(null, 0.5);
          renderer.animateScrolling(scrollTop);
        };
        this.selectPageDown = function () {
          this.$moveByPage(1, true);
        };
        this.selectPageUp = function () {
          this.$moveByPage(-1, true);
        };
        this.gotoPageDown = function () {
          this.$moveByPage(1, false);
        };
        this.gotoPageUp = function () {
          this.$moveByPage(-1, false);
        };
        this.scrollPageDown = function () {
          this.$moveByPage(1);
        };
        this.scrollPageUp = function () {
          this.$moveByPage(-1);
        };
        this.scrollToRow = function (row) {
          this.renderer.scrollToRow(row);
        };
        this.scrollToLine = function (line, center, animate, callback) {
          this.renderer.scrollToLine(line, center, animate, callback);
        };
        this.centerSelection = function () {
          var range = this.getSelectionRange();
          var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
          };
          this.renderer.alignCursor(pos, 0.5);
        };
        this.getCursorPosition = function () {
          return this.selection.getCursor();
        };
        this.getCursorPositionScreen = function () {
          return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        this.getSelectionRange = function () {
          return this.selection.getRange();
        };
        this.selectAll = function () {
          this.$blockScrolling += 1;
          this.selection.selectAll();
          this.$blockScrolling -= 1;
        };
        this.clearSelection = function () {
          this.selection.clearSelection();
        };
        this.moveCursorTo = function (row, column) {
          this.selection.moveCursorTo(row, column);
        };
        this.moveCursorToPosition = function (pos) {
          this.selection.moveCursorToPosition(pos);
        };
        this.jumpToMatching = function (select, expand) {
          var cursor = this.getCursorPosition();
          var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
          var prevToken = iterator.getCurrentToken();
          var token = prevToken || iterator.stepForward();
          if (!token) return;
          var matchType;
          var found = false;
          var depth = {};
          var i = cursor.column - token.start;
          var bracketType;
          var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
          };
          do {
            if (token.value.match(/[{}()\[\]]/g)) {
              for (; i < token.value.length && !found; i++) {
                if (!brackets[token.value[i]]) {
                  continue;
                }
                bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
                if (isNaN(depth[bracketType])) {
                  depth[bracketType] = 0;
                }
                switch (token.value[i]) {
                  case '(':
                  case '[':
                  case '{':
                    depth[bracketType]++;
                    break;
                  case ')':
                  case ']':
                  case '}':
                    depth[bracketType]--;
                    if (depth[bracketType] === -1) {
                      matchType = 'bracket';
                      found = true;
                    }
                    break;
                }
              }
            } else if (token && token.type.indexOf('tag-name') !== -1) {
              if (isNaN(depth[token.value])) {
                depth[token.value] = 0;
              }
              if (prevToken.value === '<') {
                depth[token.value]++;
              } else if (prevToken.value === '</') {
                depth[token.value]--;
              }
              if (depth[token.value] === -1) {
                matchType = 'tag';
                found = true;
              }
            }
            if (!found) {
              prevToken = token;
              token = iterator.stepForward();
              i = 0;
            }
          } while (token && !found);
          if (!matchType) return;
          var range, pos;
          if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
              pos = range.start;
              if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
            }
          } else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1) var tag = token.value;else return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
            if (range.compare(cursor.row, cursor.column) === 0) {
              found = false;
              do {
                token = prevToken;
                prevToken = iterator.stepBackward();
                if (prevToken) {
                  if (prevToken.type.indexOf('tag-close') !== -1) {
                    range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                  }
                  if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                    if (prevToken.value === '<') {
                      depth[tag]++;
                    } else if (prevToken.value === '</') {
                      depth[tag]--;
                    }
                    if (depth[tag] === 0) found = true;
                  }
                }
              } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
              pos = range.start;
              if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2) pos = range.end;
            }
          }
          pos = range && range.cursor || pos;
          if (pos) {
            if (select) {
              if (range && expand) {
                this.selection.setRange(range);
              } else if (range && range.isEqual(this.getSelectionRange())) {
                this.clearSelection();
              } else {
                this.selection.selectTo(pos.row, pos.column);
              }
            } else {
              this.selection.moveTo(pos.row, pos.column);
            }
          }
        };
        this.gotoLine = function (lineNumber, column, animate) {
          this.selection.clearSelection();
          this.session.unfold({
            row: lineNumber - 1,
            column: column || 0
          });
          this.$blockScrolling += 1;
          this.exitMultiSelectMode && this.exitMultiSelectMode();
          this.moveCursorTo(lineNumber - 1, column || 0);
          this.$blockScrolling -= 1;
          if (!this.isRowFullyVisible(lineNumber - 1)) this.scrollToLine(lineNumber - 1, true, animate);
        };
        this.navigateTo = function (row, column) {
          this.selection.moveTo(row, column);
        };
        this.navigateUp = function (times) {
          if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(-times || -1, 0);
        };
        this.navigateDown = function (times) {
          if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(times || 1, 0);
        };
        this.navigateLeft = function (times) {
          if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorLeft();
            }
          }
          this.clearSelection();
        };
        this.navigateRight = function (times) {
          if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorRight();
            }
          }
          this.clearSelection();
        };
        this.navigateLineStart = function () {
          this.selection.moveCursorLineStart();
          this.clearSelection();
        };
        this.navigateLineEnd = function () {
          this.selection.moveCursorLineEnd();
          this.clearSelection();
        };
        this.navigateFileEnd = function () {
          this.selection.moveCursorFileEnd();
          this.clearSelection();
        };
        this.navigateFileStart = function () {
          this.selection.moveCursorFileStart();
          this.clearSelection();
        };
        this.navigateWordRight = function () {
          this.selection.moveCursorWordRight();
          this.clearSelection();
        };
        this.navigateWordLeft = function () {
          this.selection.moveCursorWordLeft();
          this.clearSelection();
        };
        this.replace = function (replacement, options) {
          if (options) this.$search.set(options);
          var range = this.$search.find(this.session);
          var replaced = 0;
          if (!range) return replaced;
          if (this.$tryReplace(range, replacement)) {
            replaced = 1;
          }
          if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
          }
          return replaced;
        };
        this.replaceAll = function (replacement, options) {
          if (options) {
            this.$search.set(options);
          }
          var ranges = this.$search.findAll(this.session);
          var replaced = 0;
          if (!ranges.length) return replaced;
          this.$blockScrolling += 1;
          var selection = this.getSelectionRange();
          this.selection.moveTo(0, 0);
          for (var i = ranges.length - 1; i >= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
              replaced++;
            }
          }
          this.selection.setSelectionRange(selection);
          this.$blockScrolling -= 1;
          return replaced;
        };
        this.$tryReplace = function (range, replacement) {
          var input = this.session.getTextRange(range);
          replacement = this.$search.replace(input, replacement);
          if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
          } else {
            return null;
          }
        };
        this.getLastSearchOptions = function () {
          return this.$search.getOptions();
        };
        this.find = function (needle, options, animate) {
          if (!options) options = {};
          if (typeof needle == "string" || needle instanceof RegExp) options.needle = needle;else if (typeof needle == "object") oop.mixin(options, needle);
          var range = this.selection.getRange();
          if (options.needle == null) {
            needle = this.session.getTextRange(range) || this.$search.$options.needle;
            if (!needle) {
              range = this.session.getWordRange(range.start.row, range.start.column);
              needle = this.session.getTextRange(range);
            }
            this.$search.set({
              needle: needle
            });
          }
          this.$search.set(options);
          if (!options.start) this.$search.set({
            start: range
          });
          var newRange = this.$search.find(this.session);
          if (options.preventScroll) return newRange;
          if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
          }
          if (options.backwards) range.start = range.end;else range.end = range.start;
          this.selection.setRange(range);
        };
        this.findNext = function (options, animate) {
          this.find({
            skipCurrent: true,
            backwards: false
          }, options, animate);
        };
        this.findPrevious = function (options, animate) {
          this.find(options, {
            skipCurrent: true,
            backwards: true
          }, animate);
        };
        this.revealRange = function (range, animate) {
          this.$blockScrolling += 1;
          this.session.unfold(range);
          this.selection.setSelectionRange(range);
          this.$blockScrolling -= 1;
          var scrollTop = this.renderer.scrollTop;
          this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
          if (animate !== false) this.renderer.animateScrolling(scrollTop);
        };
        this.undo = function () {
          this.$blockScrolling++;
          this.session.getUndoManager().undo();
          this.$blockScrolling--;
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.redo = function () {
          this.$blockScrolling++;
          this.session.getUndoManager().redo();
          this.$blockScrolling--;
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.destroy = function () {
          this.renderer.destroy();
          this._signal("destroy", this);
          if (this.session) {
            this.session.destroy();
          }
        };
        this.setAutoScrollEditorIntoView = function (enable) {
          if (!enable) return;
          var rect;
          var self = this;
          var shouldScroll = false;
          if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
          var scrollAnchor = this.$scrollAnchor;
          scrollAnchor.style.cssText = "position:absolute";
          this.container.insertBefore(scrollAnchor, this.container.firstChild);
          var onChangeSelection = this.on("changeSelection", function () {
            shouldScroll = true;
          });
          var onBeforeRender = this.renderer.on("beforeRender", function () {
            if (shouldScroll) rect = self.renderer.container.getBoundingClientRect();
          });
          var onAfterRender = this.renderer.on("afterRender", function () {
            if (shouldScroll && rect && (self.isFocused() || self.searchBox && self.searchBox.isFocused())) {
              var renderer = self.renderer;
              var pos = renderer.$cursorLayer.$pixelPos;
              var config = renderer.layerConfig;
              var top = pos.top - config.offset;
              if (pos.top >= 0 && top + rect.top < 0) {
                shouldScroll = true;
              } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                shouldScroll = false;
              } else {
                shouldScroll = null;
              }
              if (shouldScroll != null) {
                scrollAnchor.style.top = top + "px";
                scrollAnchor.style.left = pos.left + "px";
                scrollAnchor.style.height = config.lineHeight + "px";
                scrollAnchor.scrollIntoView(shouldScroll);
              }
              shouldScroll = rect = null;
            }
          });
          this.setAutoScrollEditorIntoView = function (enable) {
            if (enable) return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
          };
        };
        this.$resetCursorStyle = function () {
          var style = this.$cursorStyle || "ace";
          var cursorLayer = this.renderer.$cursorLayer;
          if (!cursorLayer) return;
          cursorLayer.setSmoothBlinking(/smooth/.test(style));
          cursorLayer.isBlinking = !this.$readOnly && style != "wide";
          dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
        };
      }).call(Editor.prototype);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function set(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {
              data: style
            });
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function set() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function set(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function set(readOnly) {
            this.$resetCursorStyle();
          },
          initialValue: false
        },
        cursorStyle: {
          set: function set(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: {
          initialValue: true
        },
        wrapBehavioursEnabled: {
          initialValue: true
        },
        autoScrollEditorIntoView: {
          set: function set(val) {
            this.setAutoScrollEditorIntoView(val);
          }
        },
        keyboardHandler: {
          set: function set(val) {
            this.setKeyboardHandler(val);
          },
          get: function get() {
            return this.keybindingId;
          },
          handlesSet: true
        },
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        showLineNumbers: "renderer",
        showGutter: "renderer",
        displayIndentGuides: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      exports.Editor = Editor;
    });
    ace.define("ace/undomanager", ["require", "exports", "module"], function (acequire, exports, module) {
      "use strict";

      var UndoManager = function UndoManager() {
        this.reset();
      };
      (function () {
        this.execute = function (options) {
          var deltaSets = options.args[0];
          this.$doc = options.args[1];
          if (options.merge && this.hasUndo()) {
            this.dirtyCounter--;
            deltaSets = this.$undoStack.pop().concat(deltaSets);
          }
          this.$undoStack.push(deltaSets);
          this.$redoStack = [];
          if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
          }
          this.dirtyCounter++;
        };
        this.undo = function (dontSelect) {
          var deltaSets = this.$undoStack.pop();
          var undoSelectionRange = null;
          if (deltaSets) {
            undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
            this.$redoStack.push(deltaSets);
            this.dirtyCounter--;
          }
          return undoSelectionRange;
        };
        this.redo = function (dontSelect) {
          var deltaSets = this.$redoStack.pop();
          var redoSelectionRange = null;
          if (deltaSets) {
            redoSelectionRange = this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
            this.$undoStack.push(deltaSets);
            this.dirtyCounter++;
          }
          return redoSelectionRange;
        };
        this.reset = function () {
          this.$undoStack = [];
          this.$redoStack = [];
          this.dirtyCounter = 0;
        };
        this.hasUndo = function () {
          return this.$undoStack.length > 0;
        };
        this.hasRedo = function () {
          return this.$redoStack.length > 0;
        };
        this.markClean = function () {
          this.dirtyCounter = 0;
        };
        this.isClean = function () {
          return this.dirtyCounter === 0;
        };
        this.$serializeDeltas = function (deltaSets) {
          return cloneDeltaSetsObj(deltaSets, $serializeDelta);
        };
        this.$deserializeDeltas = function (deltaSets) {
          return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
        };
        function $serializeDelta(delta) {
          return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines.length == 1 ? null : delta.lines,
            text: delta.lines.length == 1 ? delta.lines[0] : null
          };
        }
        function $deserializeDelta(delta) {
          return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines || [delta.text]
          };
        }
        function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
          var deltaSets_new = new Array(deltaSets_old.length);
          for (var i = 0; i < deltaSets_old.length; i++) {
            var deltaSet_old = deltaSets_old[i];
            var deltaSet_new = {
              group: deltaSet_old.group,
              deltas: new Array(deltaSet_old.length)
            };
            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
              var delta_old = deltaSet_old.deltas[j];
              deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
            }
            deltaSets_new[i] = deltaSet_new;
          }
          return deltaSets_new;
        }
      }).call(UndoManager.prototype);
      exports.UndoManager = UndoManager;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var dom = acequire("../lib/dom");
      var oop = acequire("../lib/oop");
      var lang = acequire("../lib/lang");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var Gutter = function Gutter(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);
        this.gutterWidth = 0;
        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);
        this.$cells = [];
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.setSession = function (session) {
          if (this.session) this.session.removeEventListener("change", this.$updateAnnotations);
          this.session = session;
          if (session) session.on("change", this.$updateAnnotations);
        };
        this.addGutterDecoration = function (row, className) {
          if (window.console) console.warn && console.warn("deprecated use session.addGutterDecoration");
          this.session.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function (row, className) {
          if (window.console) console.warn && console.warn("deprecated use session.removeGutterDecoration");
          this.session.removeGutterDecoration(row, className);
        };
        this.setAnnotations = function (annotations) {
          this.$annotations = [];
          for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo) rowInfo = this.$annotations[row] = {
              text: []
            };
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            if (rowInfo.text.indexOf(annoText) === -1) rowInfo.text.push(annoText);
            var type = annotation.type;
            if (type == "error") rowInfo.className = " ace_error";else if (type == "warning" && rowInfo.className != " ace_error") rowInfo.className = " ace_warning";else if (type == "info" && !rowInfo.className) rowInfo.className = " ace_info";
          }
        };
        this.$updateAnnotations = function (delta) {
          if (!this.$annotations.length) return;
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {} else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
          } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
          }
        };
        this.update = function (config) {
          var session = this.session;
          var firstRow = config.firstRow;
          var lastRow = Math.min(config.lastRow + config.gutterOffset,
          // needed to compensate for hor scollbar
          session.getLength() - 1);
          var fold = session.getNextFoldLine(firstRow);
          var foldStart = fold ? fold.start.row : Infinity;
          var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
          var breakpoints = session.$breakpoints;
          var decorations = session.$decorations;
          var firstLineNumber = session.$firstLineNumber;
          var lastLineNumber = 0;
          var gutterRenderer = session.gutterRenderer || this.$renderer;
          var cell = null;
          var index = -1;
          var row = firstRow;
          while (true) {
            if (row > foldStart) {
              row = fold.end.row + 1;
              fold = session.getNextFoldLine(row, fold);
              foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
              while (this.$cells.length > index + 1) {
                cell = this.$cells.pop();
                this.element.removeChild(cell.element);
              }
              break;
            }
            cell = this.$cells[++index];
            if (!cell) {
              cell = {
                element: null,
                textNode: null,
                foldWidget: null
              };
              cell.element = dom.createElement("div");
              cell.textNode = document.createTextNode('');
              cell.element.appendChild(cell.textNode);
              this.element.appendChild(cell.element);
              this.$cells[index] = cell;
            }
            var className = "ace_gutter-cell ";
            if (breakpoints[row]) className += breakpoints[row];
            if (decorations[row]) className += decorations[row];
            if (this.$annotations[row]) className += this.$annotations[row].className;
            if (cell.element.className != className) cell.element.className = className;
            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height) cell.element.style.height = height;
            if (foldWidgets) {
              var c = foldWidgets[row];
              if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
              if (!cell.foldWidget) {
                cell.foldWidget = dom.createElement("span");
                cell.element.appendChild(cell.foldWidget);
              }
              var className = "ace_fold-widget ace_" + c;
              if (c == "start" && row == foldStart && row < fold.end.row) className += " ace_closed";else className += " ace_open";
              if (cell.foldWidget.className != className) cell.foldWidget.className = className;
              var height = config.lineHeight + "px";
              if (cell.foldWidget.style.height != height) cell.foldWidget.style.height = height;
            } else {
              if (cell.foldWidget) {
                cell.element.removeChild(cell.foldWidget);
                cell.foldWidget = null;
              }
            }
            var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
            if (text !== cell.textNode.data) cell.textNode.data = text;
            row++;
          }
          this.element.style.height = config.minHeight + "px";
          if (this.$fixedWidth || session.$useWrapMode) lastLineNumber = session.getLength() + firstLineNumber;
          var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
          var padding = this.$padding || this.$computePadding();
          gutterWidth += padding.left + padding.right;
          if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
          }
        };
        this.$fixedWidth = false;
        this.$showLineNumbers = true;
        this.$renderer = "";
        this.setShowLineNumbers = function (show) {
          this.$renderer = !show && {
            getWidth: function getWidth() {
              return "";
            },
            getText: function getText() {
              return "";
            }
          };
        };
        this.getShowLineNumbers = function () {
          return this.$showLineNumbers;
        };
        this.$showFoldWidgets = true;
        this.setShowFoldWidgets = function (show) {
          if (show) dom.addCssClass(this.element, "ace_folding-enabled");else dom.removeCssClass(this.element, "ace_folding-enabled");
          this.$showFoldWidgets = show;
          this.$padding = null;
        };
        this.getShowFoldWidgets = function () {
          return this.$showFoldWidgets;
        };
        this.$computePadding = function () {
          if (!this.element.firstChild) return {
            left: 0,
            right: 0
          };
          var style = dom.computedStyle(this.element.firstChild);
          this.$padding = {};
          this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
          this.$padding.right = parseInt(style.paddingRight) || 0;
          return this.$padding;
        };
        this.getRegion = function (point) {
          var padding = this.$padding || this.$computePadding();
          var rect = this.element.getBoundingClientRect();
          if (point.x < padding.left + rect.left) return "markers";
          if (this.$showFoldWidgets && point.x > rect.right - padding.right) return "foldWidgets";
        };
      }).call(Gutter.prototype);
      exports.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("../range").Range;
      var dom = acequire("../lib/dom");
      var Marker = function Marker(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
      };
      (function () {
        this.$padding = 0;
        this.setPadding = function (padding) {
          this.$padding = padding;
        };
        this.setSession = function (session) {
          this.session = session;
        };
        this.setMarkers = function (markers) {
          this.markers = markers;
        };
        this.update = function (config) {
          if (!config) return;
          this.config = config;
          var html = [];
          for (var key in this.markers) {
            var marker = this.markers[key];
            if (!marker.range) {
              marker.update(html, this, this.session, config);
              continue;
            }
            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;
            range = range.toScreenRange(this.session);
            if (marker.renderer) {
              var top = this.$getTop(range.start.row, config);
              var left = this.$padding + (this.session.$bidiHandler.isBidiRow(range.start.row) ? this.session.$bidiHandler.getPosLeft(range.start.column) : range.start.column * config.characterWidth);
              marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
              this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
              this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
              if (marker.type == "text") this.drawTextMarker(html, range, marker.clazz, config);else this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
              if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                this.drawBidiSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
              } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
              }
            }
          }
          this.element.innerHTML = html.join("");
        };
        this.$getTop = function (row, layerConfig) {
          return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };
        function getBorderClass(tl, tr, br, bl) {
          return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
        }
        this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
          var session = this.session;
          var start = range.start.row;
          var end = range.end.row;
          var row = start;
          var prev = 0;
          var curr = 0;
          var next = session.getScreenLastRowColumn(row);
          var clazzModified = null;
          var lineRange = new Range(row, range.start.column, row, curr);
          for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            clazzModified = clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end);
            if (this.session.$bidiHandler.isBidiRow(row)) {
              this.drawBidiSingleLineMarker(stringBuilder, lineRange, clazzModified, layerConfig, row == end ? 0 : 1, extraStyle);
            } else {
              this.drawSingleLineMarker(stringBuilder, lineRange, clazzModified, layerConfig, row == end ? 0 : 1, extraStyle);
            }
          }
        };
        this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
          var padding = this.$padding;
          var height, top, left;
          extraStyle = extraStyle || "";
          if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
            var range1 = range.clone();
            range1.end.row = range1.start.row;
            range1.end.column = this.session.getLine(range1.start.row).length;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
          } else {
            height = config.lineHeight;
            top = this.$getTop(range.start.row, config);
            left = padding + range.start.column * config.characterWidth;
            stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
          }
          if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
            var range1 = range.clone();
            range1.start.row = range1.end.row;
            range1.start.column = 0;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
          } else {
            var width = range.end.column * config.characterWidth;
            height = config.lineHeight;
            top = this.$getTop(range.end.row, config);
            stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
          }
          height = (range.end.row - range.start.row - 1) * config.lineHeight;
          if (height <= 0) return;
          top = this.$getTop(range.start.row + 1, config);
          var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
          stringBuilder.push("<div class='", clazz, radiusClass ? " ace_br" + radiusClass : "", "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
        };
        this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
          var height = config.lineHeight;
          var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
          var top = this.$getTop(range.start.row, config);
          var left = this.$padding + range.start.column * config.characterWidth;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
        };
        this.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
          var height = config.lineHeight,
            top = this.$getTop(range.start.row, config),
            padding = this.$padding;
          var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
          selections.forEach(function (selection) {
            stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", selection.width + (extraLength || 0), "px;", "top:", top, "px;", "left:", padding + selection.left, "px;", extraStyle || "", "'></div>");
          });
        };
        this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          if (range.start.row != range.end.row) height += this.$getTop(range.end.row, config) - top;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
        };
        this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
        };
      }).call(Marker.prototype);
      exports.Marker = Marker;
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../lib/oop");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var useragent = acequire("../lib/useragent");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var Text = function Text(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.EOF_CHAR = "\xB6";
        this.EOL_CHAR_LF = "\xAC";
        this.EOL_CHAR_CRLF = "\xa4";
        this.EOL_CHAR = this.EOL_CHAR_LF;
        this.TAB_CHAR = "\u2014"; //"\u21E5";
        this.SPACE_CHAR = "\xB7";
        this.$padding = 0;
        this.$updateEolChar = function () {
          var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
          if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
          }
        };
        this.setPadding = function (padding) {
          this.$padding = padding;
          this.element.style.padding = "0 " + padding + "px";
        };
        this.getLineHeight = function () {
          return this.$fontMetrics.$characterSize.height || 0;
        };
        this.getCharacterWidth = function () {
          return this.$fontMetrics.$characterSize.width || 0;
        };
        this.$setFontMetrics = function (measure) {
          this.$fontMetrics = measure;
          this.$fontMetrics.on("changeCharacterSize", function (e) {
            this._signal("changeCharacterSize", e);
          }.bind(this));
          this.$pollSizeChanges();
        };
        this.checkForSizeChanges = function () {
          this.$fontMetrics.checkForSizeChanges();
        };
        this.$pollSizeChanges = function () {
          return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        this.setSession = function (session) {
          this.session = session;
          if (session) this.$computeTabString();
        };
        this.showInvisibles = false;
        this.setShowInvisibles = function (showInvisibles) {
          if (this.showInvisibles == showInvisibles) return false;
          this.showInvisibles = showInvisibles;
          this.$computeTabString();
          return true;
        };
        this.displayIndentGuides = true;
        this.setDisplayIndentGuides = function (display) {
          if (this.displayIndentGuides == display) return false;
          this.displayIndentGuides = display;
          this.$computeTabString();
          return true;
        };
        this.$tabStrings = [];
        this.onChangeTabSize = this.$computeTabString = function () {
          var tabSize = this.session.getTabSize();
          this.tabSize = tabSize;
          var tabStr = this.$tabStrings = [0];
          for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
              tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + lang.stringRepeat(this.TAB_CHAR, i) + "</span>");
            } else {
              tabStr.push(lang.stringRepeat(" ", i));
            }
          }
          if (this.displayIndentGuides) {
            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
              className += " ace_invisible";
              spaceClass = " ace_invisible_space";
              tabClass = " ace_invisible_tab";
              var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
              var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
            } else {
              var spaceContent = lang.stringRepeat(" ", this.tabSize);
              var tabContent = spaceContent;
            }
            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
          }
        };
        this.updateLines = function (config, firstRow, lastRow) {
          if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
          }
          this.config = config;
          var first = Math.max(firstRow, config.firstRow);
          var last = Math.min(lastRow, config.lastRow);
          var lineElements = this.element.childNodes;
          var lineElementsIdx = 0;
          for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
              if (foldLine.containsRow(first)) {
                first = foldLine.start.row;
                break;
              } else {
                row = foldLine.end.row;
              }
            }
            lineElementsIdx++;
          }
          var row = first;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > last) break;
            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
              var html = [];
              this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
              lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
              lineElement.innerHTML = html.join("");
            }
            row++;
          }
        };
        this.scrollLines = function (config) {
          var oldConfig = this.config;
          this.config = config;
          if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);
          if (config.lastRow < oldConfig.firstRow) return this.update(config);
          var el = this.element;
          if (oldConfig.firstRow < config.firstRow) for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--) el.removeChild(el.firstChild);
          if (oldConfig.lastRow > config.lastRow) for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--) el.removeChild(el.lastChild);
          if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild) el.insertBefore(fragment, el.firstChild);else el.appendChild(fragment);
          }
          if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
          }
        };
        this.$renderLinesFragment = function (config, firstRow, lastRow) {
          var fragment = this.element.ownerDocument.createDocumentFragment();
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow) break;
            var container = dom.createElement("div");
            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
              container.className = 'ace_line_group';
              fragment.appendChild(container);
              container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
            } else {
              while (container.firstChild) fragment.appendChild(container.firstChild);
            }
            row++;
          }
          return fragment;
        };
        this.update = function (config) {
          this.config = config;
          var html = [];
          var firstRow = config.firstRow,
            lastRow = config.lastRow;
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow) break;
            if (this.$useLineGroups()) html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            if (this.$useLineGroups()) html.push("</div>"); // end the line group

            row++;
          }
          this.element.innerHTML = html.join("");
        };
        this.$textToken = {
          "text": true,
          "rparen": true,
          "lparen": true
        };
        this.$renderToken = function (stringBuilder, screenColumn, token, value) {
          var self = this;
          var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
          var replaceFunc = function replaceFunc(c, a, b, tabIdx, idx4) {
            if (a) {
              return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : c;
            } else if (c == "&") {
              return "&#38;";
            } else if (c == "<") {
              return "&#60;";
            } else if (c == ">") {
              return "&#62;";
            } else if (c == "\t") {
              var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
              screenColumn += tabSize - 1;
              return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
              var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
              var space = self.showInvisibles ? self.SPACE_CHAR : "";
              screenColumn += 1;
              return "<span class='" + classToUse + "' style='width:" + self.config.characterWidth * 2 + "px'>" + space + "</span>";
            } else if (b) {
              return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
              screenColumn += 1;
              return "<span class='ace_cjk' style='width:" + self.config.characterWidth * 2 + "px'>" + c + "</span>";
            }
          };
          var output = value.replace(replaceReg, replaceFunc);
          if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold") style = " style='width:" + token.value.length * this.config.characterWidth + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
          } else {
            stringBuilder.push(output);
          }
          return screenColumn + value.length;
        };
        this.renderIndentGuide = function (stringBuilder, value, max) {
          var cols = value.search(this.$indentGuideRe);
          if (cols <= 0 || cols >= max) return value;
          if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
            return value.substr(cols);
          } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
          }
          return value;
        };
        this.$renderWrappedLine = function (stringBuilder, tokens, splits, onlyContents) {
          var chars = 0;
          var split = 0;
          var splitChars = splits[0];
          var screenColumn = 0;
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
              chars = value.length;
              value = this.renderIndentGuide(stringBuilder, value, splitChars);
              if (!value) continue;
              chars -= value.length;
            }
            if (chars + value.length < splitChars) {
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              chars += value.length;
            } else {
              while (chars + value.length >= splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                value = value.substring(splitChars - chars);
                chars = splitChars;
                if (!onlyContents) {
                  stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                }
                stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));
                split++;
                screenColumn = 0;
                splitChars = splits[split] || Number.MAX_VALUE;
              }
              if (value.length != 0) {
                chars += value.length;
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              }
            }
          }
        };
        this.$renderSimpleLine = function (stringBuilder, tokens) {
          var screenColumn = 0;
          var token = tokens[0];
          var value = token.value;
          if (this.displayIndentGuides) value = this.renderIndentGuide(stringBuilder, value);
          if (value) screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          }
        };
        this.$renderLine = function (stringBuilder, row, onlyContents, foldLine) {
          if (!foldLine && foldLine != false) foldLine = this.session.getFoldLine(row);
          if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);else var tokens = this.session.getTokens(row);
          if (!onlyContents) {
            stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
          }
          if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length) this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);else this.$renderSimpleLine(stringBuilder, tokens);
          }
          if (this.showInvisibles) {
            if (foldLine) row = foldLine.end.row;
            stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
          }
          if (!onlyContents) stringBuilder.push("</div>");
        };
        this.$getFoldLineTokens = function (row, foldLine) {
          var session = this.session;
          var renderTokens = [];
          function addTokens(tokens, from, to) {
            var idx = 0,
              col = 0;
            while (col + tokens[idx].value.length < from) {
              col += tokens[idx].value.length;
              idx++;
              if (idx == tokens.length) return;
            }
            if (col != from) {
              var value = tokens[idx].value.substring(from - col);
              if (value.length > to - from) value = value.substring(0, to - from);
              renderTokens.push({
                type: tokens[idx].type,
                value: value
              });
              col = from + value.length;
              idx += 1;
            }
            while (col < to && idx < tokens.length) {
              var value = tokens[idx].value;
              if (value.length + col > to) {
                renderTokens.push({
                  type: tokens[idx].type,
                  value: value.substring(0, to - col)
                });
              } else renderTokens.push(tokens[idx]);
              col += value.length;
              idx += 1;
            }
          }
          var tokens = session.getTokens(row);
          foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
              renderTokens.push({
                type: "fold",
                value: placeholder
              });
            } else {
              if (isNewRow) tokens = session.getTokens(row);
              if (tokens.length) addTokens(tokens, lastColumn, column);
            }
          }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
          return renderTokens;
        };
        this.$useLineGroups = function () {
          return this.session.getUseWrapMode();
        };
        this.destroy = function () {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.$measureNode) this.$measureNode.parentNode.removeChild(this.$measureNode);
          delete this.$measureNode;
        };
      }).call(Text.prototype);
      exports.Text = Text;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      var dom = acequire("../lib/dom");
      var isIE8;
      var Cursor = function Cursor(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);
        if (isIE8 === undefined) isIE8 = !("opacity" in this.element.style);
        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;
        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = (isIE8 ? this.$updateVisibility : this.$updateOpacity).bind(this);
      };
      (function () {
        this.$updateVisibility = function (val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--;) cursors[i].style.visibility = val ? "" : "hidden";
        };
        this.$updateOpacity = function (val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--;) cursors[i].style.opacity = val ? "" : "0";
        };
        this.$padding = 0;
        this.setPadding = function (padding) {
          this.$padding = padding;
        };
        this.setSession = function (session) {
          this.session = session;
        };
        this.setBlinking = function (blinking) {
          if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
          }
        };
        this.setBlinkInterval = function (blinkInterval) {
          if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
          }
        };
        this.setSmoothBlinking = function (smoothBlinking) {
          if (smoothBlinking != this.smoothBlinking && !isIE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = this.$updateOpacity.bind(this);
            this.restartTimer();
          }
        };
        this.addCursor = function () {
          var el = dom.createElement("div");
          el.className = "ace_cursor";
          this.element.appendChild(el);
          this.cursors.push(el);
          return el;
        };
        this.removeCursor = function () {
          if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
          }
        };
        this.hideCursor = function () {
          this.isVisible = false;
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        this.showCursor = function () {
          this.isVisible = true;
          dom.removeCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        this.restartTimer = function () {
          var update = this.$updateCursors;
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
          if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
          }
          update(true);
          if (!this.isBlinking || !this.blinkInterval || !this.isVisible) return;
          if (this.smoothBlinking) {
            setTimeout(function () {
              dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
          }
          var blink = function () {
            this.timeoutId = setTimeout(function () {
              update(false);
            }, 0.6 * this.blinkInterval);
          }.bind(this);
          this.intervalId = setInterval(function () {
            update(true);
            blink();
          }, this.blinkInterval);
          blink();
        };
        this.getPixelPosition = function (position, onScreen) {
          if (!this.config || !this.session) return {
            left: 0,
            top: 0
          };
          if (!position) position = this.session.selection.getCursor();
          var pos = this.session.documentToScreenPosition(position);
          var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
          var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
          return {
            left: cursorLeft,
            top: cursorTop
          };
        };
        this.update = function (config) {
          this.config = config;
          var selections = this.session.$selectionMarkers;
          var i = 0,
            cursorIndex = 0;
          if (selections === undefined || selections.length === 0) {
            selections = [{
              cursor: null
            }];
          }
          for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
              continue;
            }
            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
            if (!this.drawCursor) {
              style.left = pixelPos.left + "px";
              style.top = pixelPos.top + "px";
              style.width = config.characterWidth + "px";
              style.height = config.lineHeight + "px";
            } else {
              this.drawCursor(style, pixelPos, config, selections[i], this.session);
            }
          }
          while (this.cursors.length > cursorIndex) this.removeCursor();
          var overwrite = this.session.getOverwrite();
          this.$setOverwrite(overwrite);
          this.$pixelPos = pixelPos;
          this.restartTimer();
        };
        this.drawCursor = null;
        this.$setOverwrite = function (overwrite) {
          if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite) dom.addCssClass(this.element, "ace_overwrite-cursors");else dom.removeCssClass(this.element, "ace_overwrite-cursors");
          }
        };
        this.destroy = function () {
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
        };
      }).call(Cursor.prototype);
      exports.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var event = acequire("./lib/event");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 0x8000;
      var ScrollBar = function ScrollBar(parent) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        this.element.appendChild(this.inner);
        parent.appendChild(this.element);
        this.setVisible(false);
        this.skipEvent = false;
        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.setVisible = function (isVisible) {
          this.element.style.display = isVisible ? "" : "none";
          this.isVisible = isVisible;
          this.coeff = 1;
        };
      }).call(ScrollBar.prototype);
      var VScrollBar = function VScrollBar(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollTop = 0;
        this.scrollHeight = 0;
        renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
        this.$minWidth = 0;
      };
      oop.inherits(VScrollBar, ScrollBar);
      (function () {
        this.classSuffix = '-v';
        this.onScroll = function () {
          if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
              var h = this.element.clientHeight / this.scrollHeight;
              this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", {
              data: this.scrollTop
            });
          }
          this.skipEvent = false;
        };
        this.getWidth = function () {
          return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        this.setHeight = function (height) {
          this.element.style.height = height + "px";
        };
        this.setInnerHeight = this.setScrollHeight = function (height) {
          this.scrollHeight = height;
          if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
          } else if (this.coeff != 1) {
            this.coeff = 1;
          }
          this.inner.style.height = height + "px";
        };
        this.setScrollTop = function (scrollTop) {
          if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
          }
        };
      }).call(VScrollBar.prototype);
      var HScrollBar = function HScrollBar(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollLeft = 0;
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
      };
      oop.inherits(HScrollBar, ScrollBar);
      (function () {
        this.classSuffix = '-h';
        this.onScroll = function () {
          if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {
              data: this.scrollLeft
            });
          }
          this.skipEvent = false;
        };
        this.getHeight = function () {
          return this.isVisible ? this.height : 0;
        };
        this.setWidth = function (width) {
          this.element.style.width = width + "px";
        };
        this.setInnerWidth = function (width) {
          this.inner.style.width = width + "px";
        };
        this.setScrollWidth = function (width) {
          this.inner.style.width = width + "px";
        };
        this.setScrollLeft = function (scrollLeft) {
          if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
          }
        };
      }).call(HScrollBar.prototype);
      exports.ScrollBar = VScrollBar; // backward compatibility
      exports.ScrollBarV = VScrollBar; // backward compatibility
      exports.ScrollBarH = HScrollBar; // backward compatibility

      exports.VScrollBar = VScrollBar;
      exports.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function (acequire, exports, module) {
      "use strict";

      var event = acequire("./lib/event");
      var RenderLoop = function RenderLoop(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.window = win || window;
      };
      (function () {
        this.schedule = function (change) {
          this.changes = this.changes | change;
          if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function () {
              _self.pending = false;
              var changes;
              while (changes = _self.changes) {
                _self.changes = 0;
                _self.onRender(changes);
              }
            }, this.window);
          }
        };
      }).call(RenderLoop.prototype);
      exports.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("../lib/oop");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var useragent = acequire("../lib/useragent");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 0;
      var FontMetrics = exports.FontMetrics = function (parentEl) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);
        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);
        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);
        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);
        if (!CHAR_COUNT) this.$testFractionalRect();
        this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.checkForSizeChanges();
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.$testFractionalRect = function () {
          var el = dom.createElement("div");
          this.$setMeasureNodeStyles(el.style);
          el.style.width = "0.2px";
          document.documentElement.appendChild(el);
          var w = el.getBoundingClientRect().width;
          if (w > 0 && w < 1) CHAR_COUNT = 50;else CHAR_COUNT = 100;
          el.parentNode.removeChild(el);
        };
        this.$setMeasureNodeStyles = function (style, isRoot) {
          style.width = style.height = "auto";
          style.left = style.top = "0px";
          style.visibility = "hidden";
          style.position = "absolute";
          style.whiteSpace = "pre";
          if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
          } else {
            style.font = "inherit";
          }
          style.overflow = isRoot ? "hidden" : "visible";
        };
        this.checkForSizeChanges = function () {
          var size = this.$measureSizes();
          if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {
              data: size
            });
          }
        };
        this.$pollSizeChanges = function () {
          if (this.$pollSizeChangesTimer) return this.$pollSizeChangesTimer;
          var self = this;
          return this.$pollSizeChangesTimer = setInterval(function () {
            self.checkForSizeChanges();
          }, 500);
        };
        this.setPolling = function (val) {
          if (val) {
            this.$pollSizeChanges();
          } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
          }
        };
        this.$measureSizes = function () {
          if (CHAR_COUNT === 50) {
            var rect = null;
            try {
              rect = this.$measureNode.getBoundingClientRect();
            } catch (e) {
              rect = {
                width: 0,
                height: 0
              };
            }
            var size = {
              height: rect.height,
              width: rect.width / CHAR_COUNT
            };
          } else {
            var size = {
              height: this.$measureNode.clientHeight,
              width: this.$measureNode.clientWidth / CHAR_COUNT
            };
          }
          if (size.width === 0 || size.height === 0) return null;
          return size;
        };
        this.$measureCharWidth = function (ch) {
          this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
          var rect = this.$main.getBoundingClientRect();
          return rect.width / CHAR_COUNT;
        };
        this.getCharacterWidth = function (ch) {
          var w = this.charSizes[ch];
          if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
          }
          return w;
        };
        this.destroy = function () {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);
        };
      }).call(FontMetrics.prototype);
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var config = acequire("./config");
      var useragent = acequire("./lib/useragent");
      var GutterLayer = acequire("./layer/gutter").Gutter;
      var MarkerLayer = acequire("./layer/marker").Marker;
      var TextLayer = acequire("./layer/text").Text;
      var CursorLayer = acequire("./layer/cursor").Cursor;
      var HScrollBar = acequire("./scrollbar").HScrollBar;
      var VScrollBar = acequire("./scrollbar").VScrollBar;
      var RenderLoop = acequire("./renderloop").RenderLoop;
      var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
.ace_text-input-ios {\
position: absolute !important;\
top: -100000px !important;\
left: -100000px !important;\
}\
";
      dom.importCssString(editorCss, "ace_editor.css");
      var VirtualRenderer = function VirtualRenderer(container, theme) {
        var _self = this;
        this.container = container || dom.createElement("div");
        this.$keepTextAreaAtCursor = !useragent.isOldIE;
        dom.addCssClass(this.container, "ace_editor");
        this.setTheme(theme);
        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.$gutter.setAttribute("aria-hidden", true);
        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";
        this.container.appendChild(this.scroller);
        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);
        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
        this.$markerBack = new MarkerLayer(this.content);
        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;
        this.$markerFront = new MarkerLayer(this.content);
        this.$cursorLayer = new CursorLayer(this.content);
        this.$horizScroll = false;
        this.$vScroll = false;
        this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.addEventListener("scroll", function (e) {
          if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.addEventListener("scroll", function (e) {
          if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });
        this.scrollTop = 0;
        this.scrollLeft = 0;
        this.cursorPos = {
          row: 0,
          column: 0
        };
        this.$fontMetrics = new FontMetrics(this.container);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.addEventListener("changeCharacterSize", function (e) {
          _self.updateCharacterSize();
          _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
          _self._signal("changeCharacterSize", e);
        });
        this.$size = {
          width: 0,
          height: 0,
          scrollerHeight: 0,
          scrollerWidth: 0,
          $dirty: true
        };
        this.layerConfig = {
          width: 1,
          padding: 0,
          firstRow: 0,
          firstRowScreen: 0,
          lastRow: 0,
          lineHeight: 0,
          characterWidth: 0,
          minHeight: 1,
          maxHeight: 1,
          offset: 0,
          height: 1,
          gutterOffset: 1
        };
        this.scrollMargin = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          v: 0,
          h: 0
        };
        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
        this.$loop.schedule(this.CHANGE_FULL);
        this.updateCharacterSize();
        this.setPadding(4);
        config.resetOptions(this);
        config._emit("renderer", this);
      };
      (function () {
        this.CHANGE_CURSOR = 1;
        this.CHANGE_MARKER = 2;
        this.CHANGE_GUTTER = 4;
        this.CHANGE_SCROLL = 8;
        this.CHANGE_LINES = 16;
        this.CHANGE_TEXT = 32;
        this.CHANGE_SIZE = 64;
        this.CHANGE_MARKER_BACK = 128;
        this.CHANGE_MARKER_FRONT = 256;
        this.CHANGE_FULL = 512;
        this.CHANGE_H_SCROLL = 1024;
        oop.implement(this, EventEmitter);
        this.updateCharacterSize = function () {
          if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
          }
          this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
          this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
          this.$updatePrintMargin();
        };
        this.setSession = function (session) {
          if (this.session) this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
          this.session = session;
          if (session && this.scrollMargin.top && session.getScrollTop() <= 0) session.setScrollTop(-this.scrollMargin.top);
          this.$cursorLayer.setSession(session);
          this.$markerBack.setSession(session);
          this.$markerFront.setSession(session);
          this.$gutterLayer.setSession(session);
          this.$textLayer.setSession(session);
          if (!session) return;
          this.$loop.schedule(this.CHANGE_FULL);
          this.session.$setFontMetrics(this.$fontMetrics);
          this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
          this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
          this.onChangeNewLineMode();
          this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        this.updateLines = function (firstRow, lastRow, force) {
          if (lastRow === undefined) lastRow = Infinity;
          if (!this.$changedLines) {
            this.$changedLines = {
              firstRow: firstRow,
              lastRow: lastRow
            };
          } else {
            if (this.$changedLines.firstRow > firstRow) this.$changedLines.firstRow = firstRow;
            if (this.$changedLines.lastRow < lastRow) this.$changedLines.lastRow = lastRow;
          }
          if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force) this.$changedLines.lastRow = this.layerConfig.lastRow;else return;
          }
          if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
          this.$loop.schedule(this.CHANGE_LINES);
        };
        this.onChangeNewLineMode = function () {
          this.$loop.schedule(this.CHANGE_TEXT);
          this.$textLayer.$updateEolChar();
          this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        };
        this.onChangeTabSize = function () {
          this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
          this.$textLayer.onChangeTabSize();
        };
        this.updateText = function () {
          this.$loop.schedule(this.CHANGE_TEXT);
        };
        this.updateFull = function (force) {
          if (force) this.$renderChanges(this.CHANGE_FULL, true);else this.$loop.schedule(this.CHANGE_FULL);
        };
        this.updateFontSize = function () {
          this.$textLayer.checkForSizeChanges();
        };
        this.$changes = 0;
        this.$updateSizeAsync = function () {
          if (this.$loop.pending) this.$size.$dirty = true;else this.onResize();
        };
        this.onResize = function (force, gutterWidth, width, height) {
          if (this.resizing > 2) return;else if (this.resizing > 0) this.resizing++;else this.resizing = force ? 1 : 0;
          var el = this.container;
          if (!height) height = el.clientHeight || el.scrollHeight;
          if (!width) width = el.clientWidth || el.scrollWidth;
          var changes = this.$updateCachedSize(force, gutterWidth, width, height);
          if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;
          if (force) this.$gutterLayer.$padding = null;
          if (force) this.$renderChanges(changes | this.$changes, true);else this.$loop.schedule(changes | this.$changes);
          if (this.resizing) this.resizing = 0;
          this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
        };
        this.$updateCachedSize = function (force, gutterWidth, width, height) {
          height -= this.$extraHeight || 0;
          var changes = 0;
          var size = this.$size;
          var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
          };
          if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;
            size.scrollerHeight = size.height;
            if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
            changes = changes | this.CHANGE_SCROLL;
          }
          if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            this.gutterWidth = gutterWidth;
            this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());
            this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) changes |= this.CHANGE_FULL;
          }
          size.$dirty = !width || !height;
          if (changes) this._signal("resize", oldSize);
          return changes;
        };
        this.onGutterResize = function () {
          var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
          if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
          if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
          }
        };
        this.adjustWrapLimit = function () {
          var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
          var limit = Math.floor(availableWidth / this.characterWidth);
          return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        this.setAnimatedScroll = function (shouldAnimate) {
          this.setOption("animatedScroll", shouldAnimate);
        };
        this.getAnimatedScroll = function () {
          return this.$animatedScroll;
        };
        this.setShowInvisibles = function (showInvisibles) {
          this.setOption("showInvisibles", showInvisibles);
          this.session.$bidiHandler.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function () {
          return this.getOption("showInvisibles");
        };
        this.getDisplayIndentGuides = function () {
          return this.getOption("displayIndentGuides");
        };
        this.setDisplayIndentGuides = function (display) {
          this.setOption("displayIndentGuides", display);
        };
        this.setShowPrintMargin = function (showPrintMargin) {
          this.setOption("showPrintMargin", showPrintMargin);
        };
        this.getShowPrintMargin = function () {
          return this.getOption("showPrintMargin");
        };
        this.setPrintMarginColumn = function (showPrintMargin) {
          this.setOption("printMarginColumn", showPrintMargin);
        };
        this.getPrintMarginColumn = function () {
          return this.getOption("printMarginColumn");
        };
        this.getShowGutter = function () {
          return this.getOption("showGutter");
        };
        this.setShowGutter = function (show) {
          return this.setOption("showGutter", show);
        };
        this.getFadeFoldWidgets = function () {
          return this.getOption("fadeFoldWidgets");
        };
        this.setFadeFoldWidgets = function (show) {
          this.setOption("fadeFoldWidgets", show);
        };
        this.setHighlightGutterLine = function (shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        this.getHighlightGutterLine = function () {
          return this.getOption("highlightGutterLine");
        };
        this.$updateGutterLineHighlight = function () {
          var pos = this.$cursorLayer.$pixelPos;
          var height = this.layerConfig.lineHeight;
          if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
          }
          this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
          this.$gutterLineHighlight.style.height = height + "px";
        };
        this.$updatePrintMargin = function () {
          if (!this.$showPrintMargin && !this.$printMarginEl) return;
          if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
          }
          var style = this.$printMarginEl.style;
          style.left = this.characterWidth * this.$printMarginColumn + this.$padding + "px";
          style.visibility = this.$showPrintMargin ? "visible" : "hidden";
          if (this.session && this.session.$wrap == -1) this.adjustWrapLimit();
        };
        this.getContainerElement = function () {
          return this.container;
        };
        this.getMouseEventTarget = function () {
          return this.scroller;
        };
        this.getTextAreaContainer = function () {
          return this.container;
        };
        this.$moveTextAreaToCursor = function () {
          if (!this.$keepTextAreaAtCursor) return;
          var config = this.layerConfig;
          var posTop = this.$cursorLayer.$pixelPos.top;
          var posLeft = this.$cursorLayer.$pixelPos.left;
          posTop -= config.offset;
          var style = this.textarea.style;
          var h = this.lineHeight;
          if (posTop < 0 || posTop > config.height - h) {
            style.top = style.left = "0";
            return;
          }
          var w = this.characterWidth;
          if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= this.session.$getStringScreenWidth(val)[0] + 2;
            h += 2;
          }
          posLeft -= this.scrollLeft;
          if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;
          posLeft += this.gutterWidth;
          style.height = h + "px";
          style.width = w + "px";
          style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
          style.top = Math.min(posTop, this.$size.height - h) + "px";
        };
        this.getFirstVisibleRow = function () {
          return this.layerConfig.firstRow;
        };
        this.getFirstFullyVisibleRow = function () {
          return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        this.getLastFullyVisibleRow = function () {
          var config = this.layerConfig;
          var lastRow = config.lastRow;
          var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
          if (top - this.session.getScrollTop() > config.height - config.lineHeight) return lastRow - 1;
          return lastRow;
        };
        this.getLastVisibleRow = function () {
          return this.layerConfig.lastRow;
        };
        this.$padding = null;
        this.setPadding = function (padding) {
          this.$padding = padding;
          this.$textLayer.setPadding(padding);
          this.$cursorLayer.setPadding(padding);
          this.$markerFront.setPadding(padding);
          this.$markerBack.setPadding(padding);
          this.$loop.schedule(this.CHANGE_FULL);
          this.$updatePrintMargin();
        };
        this.setScrollMargin = function (top, bottom, left, right) {
          var sm = this.scrollMargin;
          sm.top = top | 0;
          sm.bottom = bottom | 0;
          sm.right = right | 0;
          sm.left = left | 0;
          sm.v = sm.top + sm.bottom;
          sm.h = sm.left + sm.right;
          if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
          this.updateFull();
        };
        this.getHScrollBarAlwaysVisible = function () {
          return this.$hScrollBarAlwaysVisible;
        };
        this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
          this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        this.getVScrollBarAlwaysVisible = function () {
          return this.$vScrollBarAlwaysVisible;
        };
        this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
          this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };
        this.$updateScrollBarV = function () {
          var scrollHeight = this.layerConfig.maxHeight;
          var scrollerHeight = this.$size.scrollerHeight;
          if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
              scrollHeight = this.scrollTop + scrollerHeight;
              this.scrollBarV.scrollTop = null;
            }
          }
          this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
          this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        this.$updateScrollBarH = function () {
          this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
          this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        this.$frozen = false;
        this.freeze = function () {
          this.$frozen = true;
        };
        this.unfreeze = function () {
          this.$frozen = false;
        };
        this.$renderChanges = function (changes, force) {
          if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
          }
          if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
            this.$changes |= changes;
            return;
          }
          if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
          }
          if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
          }
          this._signal("beforeRender");
          if (this.session && this.session.$bidiHandler) this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
          var config = this.layerConfig;
          if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
            changes |= this.$computeLayerConfig();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
              var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
              if (st > 0) {
                this.scrollTop = st;
                changes = changes | this.CHANGE_SCROLL;
                changes |= this.$computeLayerConfig();
              }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL) this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = -config.offset + "px";
            this.content.style.marginTop = -config.offset + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
          }
          if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
          }
          if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter) this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
          }
          if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES) this.$textLayer.update(config);else this.$textLayer.scrollLines(config);
            if (this.$showGutter) this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
          }
          if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter) this.$gutterLayer.update(config);
          } else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
          } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter) this.$gutterLayer.update(config);
          }
          if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
          }
          this._signal("afterRender");
        };
        this.$autosize = function () {
          var height = this.session.getScreenLength() * this.lineHeight;
          var maxHeight = this.$maxLines * this.lineHeight;
          var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
          if (this.$horizScroll) desiredHeight += this.scrollBarH.getHeight();
          if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight) desiredHeight = this.$maxPixelHeight;
          var vScroll = height > maxHeight;
          if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            this._signal("autosize");
          }
        };
        this.$computeLayerConfig = function () {
          var session = this.session;
          var size = this.$size;
          var hideScrollbars = size.height <= 2 * this.lineHeight;
          var screenLines = this.session.getScreenLength();
          var maxHeight = screenLines * this.lineHeight;
          var longestLine = this.$getLongestLine();
          var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
          var hScrollChanged = this.$horizScroll !== horizScroll;
          if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
          }
          var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
          if (this.$maxLines && this.lineHeight > 1) this.$autosize();
          var offset = this.scrollTop % this.lineHeight;
          var minHeight = size.scrollerHeight + this.lineHeight;
          var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
          maxHeight += scrollPastEnd;
          var sm = this.scrollMargin;
          this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
          this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
          var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
          var vScrollChanged = vScrollBefore !== vScroll;
          if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
          }
          var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
          var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
          var lastRow = firstRow + lineCount;
          var firstRowScreen, firstRowHeight;
          var lineHeight = this.lineHeight;
          firstRow = session.screenToDocumentRow(firstRow, 0);
          var foldLine = session.getFoldLine(firstRow);
          if (foldLine) {
            firstRow = foldLine.start.row;
          }
          firstRowScreen = session.documentToScreenRow(firstRow, 0);
          firstRowHeight = session.getRowLength(firstRow) * lineHeight;
          lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
          minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
          offset = this.scrollTop - firstRowScreen * lineHeight;
          var changes = 0;
          if (this.layerConfig.width != longestLine) changes = this.CHANGE_H_SCROLL;
          if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged) longestLine = this.$getLongestLine();
          }
          this.layerConfig = {
            width: longestLine,
            padding: this.$padding,
            firstRow: firstRow,
            firstRowScreen: firstRowScreen,
            lastRow: lastRow,
            lineHeight: lineHeight,
            characterWidth: this.characterWidth,
            minHeight: minHeight,
            maxHeight: maxHeight,
            offset: offset,
            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height: this.$size.scrollerHeight
          };
          return changes;
        };
        this.$updateLines = function () {
          if (!this.$changedLines) return;
          var firstRow = this.$changedLines.firstRow;
          var lastRow = this.$changedLines.lastRow;
          this.$changedLines = null;
          var layerConfig = this.layerConfig;
          if (firstRow > layerConfig.lastRow + 1) {
            return;
          }
          if (lastRow < layerConfig.firstRow) {
            return;
          }
          if (lastRow === Infinity) {
            if (this.$showGutter) this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
          }
          this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
          return true;
        };
        this.$getLongestLine = function () {
          var charCount = this.session.getScreenWidth();
          if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;
          return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        this.updateFrontMarkers = function () {
          this.$markerFront.setMarkers(this.session.getMarkers(true));
          this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        this.updateBackMarkers = function () {
          this.$markerBack.setMarkers(this.session.getMarkers());
          this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        this.addGutterDecoration = function (row, className) {
          this.$gutterLayer.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function (row, className) {
          this.$gutterLayer.removeGutterDecoration(row, className);
        };
        this.updateBreakpoints = function (rows) {
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.setAnnotations = function (annotations) {
          this.$gutterLayer.setAnnotations(annotations);
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.updateCursor = function () {
          this.$loop.schedule(this.CHANGE_CURSOR);
        };
        this.hideCursor = function () {
          this.$cursorLayer.hideCursor();
        };
        this.showCursor = function () {
          this.$cursorLayer.showCursor();
        };
        this.scrollSelectionIntoView = function (anchor, lead, offset) {
          this.scrollCursorIntoView(anchor, offset);
          this.scrollCursorIntoView(lead, offset);
        };
        this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
          if (this.$size.scrollerHeight === 0) return;
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var left = pos.left;
          var top = pos.top;
          var topMargin = $viewMargin && $viewMargin.top || 0;
          var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
          var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
          if (scrollTop + topMargin > top) {
            if (offset && scrollTop + topMargin > top + this.lineHeight) top -= offset * this.$size.scrollerHeight;
            if (top === 0) top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
          } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight) top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
          }
          var scrollLeft = this.scrollLeft;
          if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth) left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
          } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
          } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
          }
        };
        this.getScrollTop = function () {
          return this.session.getScrollTop();
        };
        this.getScrollLeft = function () {
          return this.session.getScrollLeft();
        };
        this.getScrollTopRow = function () {
          return this.scrollTop / this.lineHeight;
        };
        this.getScrollBottomRow = function () {
          return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        this.scrollToRow = function (row) {
          this.session.setScrollTop(row * this.lineHeight);
        };
        this.alignCursor = function (cursor, alignment) {
          if (typeof cursor == "number") cursor = {
            row: cursor,
            column: 0
          };
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var h = this.$size.scrollerHeight - this.lineHeight;
          var offset = pos.top - h * (alignment || 0);
          this.session.setScrollTop(offset);
          return offset;
        };
        this.STEPS = 8;
        this.$calcSteps = function (fromValue, toValue) {
          var i = 0;
          var l = this.STEPS;
          var steps = [];
          var func = function func(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
          };
          for (i = 0; i < l; ++i) steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
          return steps;
        };
        this.scrollToLine = function (line, center, animate, callback) {
          var pos = this.$cursorLayer.getPixelPosition({
            row: line,
            column: 0
          });
          var offset = pos.top;
          if (center) offset -= this.$size.scrollerHeight / 2;
          var initialScroll = this.scrollTop;
          this.session.setScrollTop(offset);
          if (animate !== false) this.animateScrolling(initialScroll, callback);
        };
        this.animateScrolling = function (fromValue, callback) {
          var toValue = this.scrollTop;
          if (!this.$animatedScroll) return;
          var _self = this;
          if (fromValue == toValue) return;
          if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
              fromValue = oldSteps[0];
              if (fromValue == toValue) return;
            }
          }
          var steps = _self.$calcSteps(fromValue, toValue);
          this.$scrollAnimation = {
            from: fromValue,
            to: toValue,
            steps: steps
          };
          clearInterval(this.$timer);
          _self.session.setScrollTop(steps.shift());
          _self.session.$scrollTop = toValue;
          this.$timer = setInterval(function () {
            if (steps.length) {
              _self.session.setScrollTop(steps.shift());
              _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
              _self.session.$scrollTop = -1;
              _self.session.setScrollTop(toValue);
              toValue = null;
            } else {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              callback && callback();
            }
          }, 10);
        };
        this.scrollToY = function (scrollTop) {
          if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
          }
        };
        this.scrollToX = function (scrollLeft) {
          if (this.scrollLeft !== scrollLeft) this.scrollLeft = scrollLeft;
          this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        this.scrollTo = function (x, y) {
          this.session.setScrollTop(y);
          this.session.setScrollLeft(y);
        };
        this.scrollBy = function (deltaX, deltaY) {
          deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
          deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        this.isScrollableBy = function (deltaX, deltaY) {
          if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
          if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
          if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
          if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
        };
        this.pixelToScreenCoordinates = function (x, y) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
          var offset = offsetX / this.characterWidth;
          var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
          var col = Math.round(offset);
          return {
            row: row,
            column: col,
            side: offset - col > 0 ? 1 : -1,
            offsetX: offsetX
          };
        };
        this.screenToTextCoordinates = function (x, y) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
          var col = Math.round(offsetX / this.characterWidth);
          var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
          return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
        };
        this.textToScreenCoordinates = function (row, column) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var pos = this.session.documentToScreenPosition(row, column);
          var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
          var y = pos.row * this.lineHeight;
          return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
          };
        };
        this.visualizeFocus = function () {
          dom.addCssClass(this.container, "ace_focus");
        };
        this.visualizeBlur = function () {
          dom.removeCssClass(this.container, "ace_focus");
        };
        this.showComposition = function (position) {
          if (!this.$composition) this.$composition = {
            keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
            cssText: this.textarea.style.cssText
          };
          this.$keepTextAreaAtCursor = true;
          dom.addCssClass(this.textarea, "ace_composition");
          this.textarea.style.cssText = "";
          this.$moveTextAreaToCursor();
        };
        this.setCompositionText = function (text) {
          this.$moveTextAreaToCursor();
        };
        this.hideComposition = function () {
          if (!this.$composition) return;
          dom.removeCssClass(this.textarea, "ace_composition");
          this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
          this.textarea.style.cssText = this.$composition.cssText;
          this.$composition = null;
        };
        this.setTheme = function (theme, cb) {
          var _self = this;
          this.$themeId = theme;
          _self._dispatchEvent('themeChange', {
            theme: theme
          });
          if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
          } else {
            afterLoad(theme);
          }
          function afterLoad(module) {
            if (_self.$themeId != theme) return cb && cb();
            if (!module || !module.cssClass) throw new Error("couldn't load module " + theme + " or it didn't call define");
            dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);
            if (_self.theme) dom.removeCssClass(_self.container, _self.theme.cssClass);
            var padding = "padding" in module ? module.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding) _self.setPadding(padding);
            _self.$theme = module.cssClass;
            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
              _self.$size.width = 0;
              _self.$updateSizeAsync();
            }
            _self._dispatchEvent('themeLoaded', {
              theme: module
            });
            cb && cb();
          }
        };
        this.getTheme = function () {
          return this.$themeId;
        };
        this.setStyle = function (style, include) {
          dom.setCssClass(this.container, style, include !== false);
        };
        this.unsetStyle = function (style) {
          dom.removeCssClass(this.container, style);
        };
        this.setCursorStyle = function (style) {
          if (this.scroller.style.cursor != style) this.scroller.style.cursor = style;
        };
        this.setMouseCursor = function (cursorStyle) {
          this.scroller.style.cursor = cursorStyle;
        };
        this.destroy = function () {
          this.$textLayer.destroy();
          this.$cursorLayer.destroy();
        };
      }).call(VirtualRenderer.prototype);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        animatedScroll: {
          initialValue: false
        },
        showInvisibles: {
          set: function set(value) {
            if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function set() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function set() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function set(val) {
            if (typeof val == "number") this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function get() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function set(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        fadeFoldWidgets: {
          set: function set(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function set(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
          },
          initialValue: true
        },
        showLineNumbers: {
          set: function set(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function set(show) {
            if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function set(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
              this.$gutterLineHighlight = dom.createElement("div");
              this.$gutterLineHighlight.className = "ace_gutter-active-line";
              this.$gutter.appendChild(this.$gutterLineHighlight);
              return;
            }
            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos) this.$updateGutterLineHighlight();
          },
          initialValue: false,
          value: true
        },
        hScrollBarAlwaysVisible: {
          set: function set(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function set(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function set(size) {
            if (typeof size == "number") size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {
          set: function set(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }
        },
        maxLines: {
          set: function set(val) {
            this.updateFull();
          }
        },
        minLines: {
          set: function set(val) {
            this.updateFull();
          }
        },
        maxPixelHeight: {
          set: function set(val) {
            this.updateFull();
          },
          initialValue: 0
        },
        scrollPastEnd: {
          set: function set(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val) return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {
          set: function set(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }
        },
        theme: {
          set: function set(val) {
            this.setTheme(val);
          },
          get: function get() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        }
      });
      exports.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../lib/oop");
      var net = acequire("../lib/net");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var config = acequire("../config");
      function $workerBlob(workerUrl, mod) {
        var script = mod.src;
        "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], {
            "type": "application/javascript"
          });
        } catch (e) {
          // Backwards-compatibility
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      }
      function createWorker(workerUrl, mod) {
        var blob = $workerBlob(workerUrl, mod);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);
        return new Worker(blobURL);
      }
      var WorkerClient = function WorkerClient(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        if (acequire.nameToUrl && !acequire.toUrl) acequire.toUrl = acequire.nameToUrl;
        if (config.get("packaged") || !acequire.toUrl) {
          workerUrl = workerUrl || config.moduleUrl(mod.id, "worker");
        } else {
          var normalizePath = this.$normalizePath;
          workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));
          var tlns = {};
          topLevelNamespaces.forEach(function (ns) {
            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
          });
        }
        this.$worker = createWorker(workerUrl, mod);
        if (importScripts) {
          this.send("importScripts", importScripts);
        }
        this.$worker.postMessage({
          init: true,
          tlns: tlns,
          module: mod.id,
          classname: classname
        });
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.onMessage = function (e) {
          var msg = e.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, {
                data: msg.data
              });
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function (err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function (path) {
          return net.qualifyURL(path);
        };
        this.terminate = function () {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker = null;
          if (this.$doc) this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function (cmd, args) {
          this.$worker.postMessage({
            command: cmd,
            args: args
          });
        };
        this.call = function (cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function (event, data) {
          try {
            this.$worker.postMessage({
              event: event,
              data: {
                data: data.data
              }
            });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function (doc) {
          if (this.$doc) this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener);
        };
        this.changeListener = function (delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert") this.deltaQueue.push(delta.start, delta.lines);else this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function () {
          var q = this.deltaQueue;
          if (!q) return;
          this.deltaQueue = null;
          if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else this.emit("change", {
            data: q
          });
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function UIWorkerClient(topLevelNamespaces, mod, classname) {
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.messageBuffer = [];
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var _self = this;
        this.$worker = {};
        this.$worker.terminate = function () {};
        this.$worker.postMessage = function (e) {
          _self.messageBuffer.push(e);
          if (main) {
            if (emitSync) setTimeout(processNext);else processNext();
          }
        };
        this.setEmitSync = function (val) {
          emitSync = val;
        };
        var processNext = function processNext() {
          var msg = _self.messageBuffer.shift();
          if (msg.command) main[msg.command].apply(main, msg.args);else if (msg.event) sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function (msg) {
          _self.onMessage({
            data: msg
          });
        };
        sender.callback = function (data, callbackId) {
          this.postMessage({
            type: "call",
            id: callbackId,
            data: data
          });
        };
        sender.emit = function (name, data) {
          this.postMessage({
            type: "event",
            name: name,
            data: data
          });
        };
        config.loadModule(["worker", mod], function (Main) {
          main = new Main[classname](sender);
          while (_self.messageBuffer.length) processNext();
        });
      };
      UIWorkerClient.prototype = WorkerClient.prototype;
      exports.UIWorkerClient = UIWorkerClient;
      exports.WorkerClient = WorkerClient;
      exports.createWorker = createWorker;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("./range").Range;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var oop = acequire("./lib/oop");
      var PlaceHolder = function PlaceHolder(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate);
        this.$others = others;
        this.$onCursorChange = function () {
          setTimeout(function () {
            _self.onCursorChange();
          });
        };
        this.$pos = pos;
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {
          length: -1
        };
        this.$undoStackDepth = undoStack.length;
        this.setup();
        session.selection.on("changeCursor", this.$onCursorChange);
      };
      (function () {
        oop.implement(this, EventEmitter);
        this.setup = function () {
          var _self = this;
          var doc = this.doc;
          var session = this.session;
          this.selectionBefore = session.selection.toJSON();
          if (session.selection.inMultiSelectMode) session.selection.toSingleRange();
          this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
          var pos = this.pos;
          pos.$insertRight = true;
          pos.detach();
          pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
          this.others = [];
          this.$others.forEach(function (other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
          });
          session.setUndoSelect(false);
        };
        this.showOtherMarkers = function () {
          if (this.othersActive) return;
          var session = this.session;
          var _self = this;
          this.othersActive = true;
          this.others.forEach(function (anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
          });
        };
        this.hideOtherMarkers = function () {
          if (!this.othersActive) return;
          this.othersActive = false;
          for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
          }
        };
        this.onUpdate = function (delta) {
          if (this.$updating) return this.updateAnchors(delta);
          var range = delta;
          if (range.start.row !== range.end.row) return;
          if (range.start.row !== this.pos.row) return;
          this.$updating = true;
          var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
          var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
          var distanceFromStart = range.start.column - this.pos.column;
          this.updateAnchors(delta);
          if (inMainRange) this.length += lengthDiff;
          if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
              for (var i = this.others.length - 1; i >= 0; i--) {
                var otherPos = this.others[i];
                var newPos = {
                  row: otherPos.row,
                  column: otherPos.column + distanceFromStart
                };
                this.doc.insertMergedLines(newPos, delta.lines);
              }
            } else if (delta.action === 'remove') {
              for (var i = this.others.length - 1; i >= 0; i--) {
                var otherPos = this.others[i];
                var newPos = {
                  row: otherPos.row,
                  column: otherPos.column + distanceFromStart
                };
                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
              }
            }
          }
          this.$updating = false;
          this.updateMarkers();
        };
        this.updateAnchors = function (delta) {
          this.pos.onChange(delta);
          for (var i = this.others.length; i--;) this.others[i].onChange(delta);
          this.updateMarkers();
        };
        this.updateMarkers = function () {
          if (this.$updating) return;
          var _self = this;
          var session = this.session;
          var updateMarker = function updateMarker(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
          };
          updateMarker(this.pos, this.mainClass);
          for (var i = this.others.length; i--;) updateMarker(this.others[i], this.othersClass);
        };
        this.onCursorChange = function (event) {
          if (this.$updating || !this.session) return;
          var pos = this.session.selection.getCursor();
          if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
          } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
          }
        };
        this.detach = function () {
          this.session.removeMarker(this.pos && this.pos.markerId);
          this.hideOtherMarkers();
          this.doc.removeEventListener("change", this.$onUpdate);
          this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
          this.session.setUndoSelect(true);
          this.session = null;
        };
        this.cancel = function () {
          if (this.$undoStackDepth === -1) return;
          var undoManager = this.session.getUndoManager();
          var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
          for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
          }
          if (this.selectionBefore) this.session.selection.fromJSON(this.selectionBefore);
        };
      }).call(PlaceHolder.prototype);
      exports.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        if (ctrl && useragent.isMac) button = ev.button;
        if (e.editor.inMultiSelectMode && button == 2) {
          e.editor.textInput.onContextMenu(e.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button === 0 && e.editor.inMultiSelectMode) e.editor.exitMultiSelectMode();
          return;
        }
        if (button !== 0) return;
        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e.x,
          mouseY = e.y;
        var onMouseSelection = function onMouseSelection(e) {
          mouseX = e.clientX;
          mouseY = e.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt) selectionMode = shift ? "block" : "add";else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift) return;
          } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection) return; // dragging

          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.$blockScrolling++;
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function () {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor)) selection.substractPoint(tmpSel.cursor);else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function blockSelect() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead)) return;
            screenCursor = newCursor;
            editor.$blockScrolling++;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty()) rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
            editor.$blockScrolling--;
          };
          editor.$blockScrolling++;
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift) screenAnchor = session.documentToScreenPosition(selection.lead);else selection.moveToPosition(pos);
          editor.$blockScrolling--;
          screenCursor = {
            row: -1,
            column: -1
          };
          var onMouseSelectionEnd = function onMouseSelectionEnd(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length) rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++) selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function () {
            onSelectionInterval();
          }, 20);
          return e.preventDefault();
        }
      }
      exports.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function (acequire, exports, module) {
      exports.defaultCommands = [{
        name: "addCursorAbove",
        exec: function exec(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: {
          win: "Ctrl-Alt-Up",
          mac: "Ctrl-Alt-Up"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        exec: function exec(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: {
          win: "Ctrl-Alt-Down",
          mac: "Ctrl-Alt-Down"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        exec: function exec(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Up",
          mac: "Ctrl-Alt-Shift-Up"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        exec: function exec(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Down",
          mac: "Ctrl-Alt-Shift-Down"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        exec: function exec(editor) {
          editor.selectMore(-1);
        },
        bindKey: {
          win: "Ctrl-Alt-Left",
          mac: "Ctrl-Alt-Left"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        exec: function exec(editor) {
          editor.selectMore(1);
        },
        bindKey: {
          win: "Ctrl-Alt-Right",
          mac: "Ctrl-Alt-Right"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        exec: function exec(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Left",
          mac: "Ctrl-Alt-Shift-Left"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        exec: function exec(editor) {
          editor.selectMore(1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Right",
          mac: "Ctrl-Alt-Shift-Right"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "splitIntoLines",
        exec: function exec(editor) {
          editor.multiSelect.splitIntoLines();
        },
        bindKey: {
          win: "Ctrl-Alt-L",
          mac: "Ctrl-Alt-L"
        },
        readOnly: true
      }, {
        name: "alignCursors",
        exec: function exec(editor) {
          editor.alignCursors();
        },
        bindKey: {
          win: "Ctrl-Alt-A",
          mac: "Ctrl-Alt-A"
        },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        exec: function exec(editor) {
          editor.findAll();
        },
        bindKey: {
          win: "Ctrl-Alt-K",
          mac: "Ctrl-Alt-G"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports.multiSelectCommands = [{
        name: "singleSelection",
        bindKey: "esc",
        exec: function exec(editor) {
          editor.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function isAvailable(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
      exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function (acequire, exports, module) {
      var RangeList = acequire("./range_list").RangeList;
      var Range = acequire("./range").Range;
      var Selection = acequire("./selection").Selection;
      var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
      var event = acequire("./lib/event");
      var lang = acequire("./lib/lang");
      var commands = acequire("./commands/multi_select_commands");
      exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = acequire("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = acequire("./edit_session").EditSession;
      (function () {
        this.getSelectionMarkers = function () {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function () {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function (range, $blockChangeEvents) {
          if (!range) return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor) range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length) this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function (range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length) this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function (pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function () {
          var removed = this.rangeList.merge();
          if (removed.length) this.$onRemoveRange(removed);else if (this.ranges[0]) this.fromOrientedRange(this.ranges[0]);
        };
        this.$onAddRange = function (range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", {
            range: range
          });
        };
        this.$onRemoveRange = function (removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i = removed.length; i--;) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", {
            ranges: removed
          });
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange())) this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function () {
          if (this.rangeList) return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function () {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function () {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
              if (isBackwards) var start = range.end,
                end = range.start;else var start = range.start,
                end = range.end;
              this.addRange(Range.fromPoints(end, end));
              this.addRange(Range.fromPoints(start, start));
              return;
            }
            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);
            for (var i = startRow + 1; i < endRow; i++) rectSel.push(this.getLineRange(i, true));
            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.toggleBlockSelection = function () {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0) startColumn = 0;
          if (startRow < 0) startRow = 0;
          if (startRow == endRow) includeEmptyLines = true;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd)) break;
              var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards) rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0) end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty()) start++;
            }
            for (var i = end; i >= start; i--) {
              if (rectSel[i].isEmpty()) rectSel.splice(i, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = acequire("./editor").Editor;
      (function () {
        this.updateSelectionMarkers = function () {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function (orientedRange) {
          if (!orientedRange.cursor) orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function (range) {
          if (!range.marker) return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1) this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function (ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i = ranges.length; i--;) {
            var range = ranges[i];
            if (!range.marker) continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1) markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function (e) {
          this.addSelectionMarker(e.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function (e) {
          this.removeSelectionMarkers(e.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function (e) {
          if (this.inMultiSelectMode) return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function (e) {
          if (this.session.multiSelect.inVirtualMode) return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function (e) {
          var command = e.command;
          var editor = e.editor;
          if (!editor.multiSelect) return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
          } else {
            result = command.multiSelectAction(editor, e.args || {});
          }
          return result;
        };
        this.forEachSelection = function (cmd, args, options) {
          if (this.inVirtualSelectionMode) return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length) return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i = ranges.length; i--;) {
            if ($byLines) {
              while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row) i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined) result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to) this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function () {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function () {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
              buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length) text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function (e, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor) return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column) this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
          }
        };
        this.findAll = function (needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == undefined) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length) return 0;
          this.$blockScrolling += 1;
          var selection = this.multiSelect;
          if (!additive) selection.toSingleRange(ranges[0]);
          for (var i = ranges.length; i--;) selection.addRange(ranges[i], true);
          if (range && selection.rangeList.rangeAtPoint(range.start)) selection.addRange(range, true);
          this.$blockScrolling -= 1;
          return ranges.length;
        };
        this.selectMoreLines = function (dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn) screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip) var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove) this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function (dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i = all.length; i--;) {
            var range = all[i];
            if (range.isEmpty()) {
              var tmp = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp.start.row;
              range.start.column = tmp.start.column;
              range.end.row = tmp.end.row;
              range.end.column = tmp.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i = all.length; i--;) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0) words.unshift(words.pop());else words.push(words.shift());
          for (var i = all.length; i--;) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
        };
        this.selectMore = function (dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst) return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip) this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function () {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function (r) {
            if (r.cursor.row == row) return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row,
              lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0) fr = 0;
              if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({
              row: fr,
              column: 0
            }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function (r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function (r) {
              var p = r.cursor;
              var line = session.getLine(p.row);
              var spaceOffset = line.substr(p.column).search(/\S/g);
              if (spaceOffset == -1) spaceOffset = 0;
              if (p.column > maxCol) maxCol = p.column;
              if (spaceOffset < minSpace) minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function (r, i) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d = spaceOffsets[i] - minSpace;
              if (l > d) session.insert(p, lang.stringRepeat(" ", l - d));else session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function (lines, forceLeft) {
          var isLeftAligned = true,
            isRightAligned = true;
          var startW, textW, endW;
          return lines.map(function (line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m) return [line];
            if (startW == null) {
              startW = m[1].length;
              textW = m[2].length;
              endW = m[3].length;
              return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length) isRightAligned = false;
            if (startW != m[1].length) isLeftAligned = false;
            if (startW > m[1].length) startW = m[1].length;
            if (textW < m[2].length) textW = m[2].length;
            if (endW > m[3].length) endW = m[3].length;
            return m;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports.onSessionChange = function (e) {
        var session = e.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode) this.$onMultiSelect();else this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange) return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function (e) {
          var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
          if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        });
        event.addListener(el, "keyup", reset);
        event.addListener(el, "blur", reset);
        function reset(e) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports.MultiSelect = MultiSelect;
      acequire("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function set(val) {
            MultiSelect(this);
            if (val) {
              this.on("changeSession", this.$multiselectOnSessionChange);
              this.on("mousedown", onMouseDown);
            } else {
              this.off("changeSession", this.$multiselectOnSessionChange);
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function set(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("../../range").Range;
      var FoldMode = exports.FoldMode = function () {};
      (function () {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function (session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line)) return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) return "end";
          return "";
        };
        this.getFoldWidgetRange = function (session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function (session, row, column) {
          var re = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re);
          if (startLevel == -1) return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1) continue;
            if (level <= startLevel) break;
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
          var start = {
            row: row,
            column: column + 1
          };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end) return;
          var fw = session.foldWidgets[end.row];
          if (fw == null) fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
          var end = {
            row: row,
            column: column
          };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start) return;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      exports.isDark = false;
      exports.cssClass = "ace-tm";
      exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
      var dom = acequire("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var Range = acequire("./range").Range;
      function LineWidgets(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);
        this.session.on("change", this.updateOnChange);
        this.session.on("changeFold", this.updateOnFold);
        this.session.on("changeEditor", this.$onChangeEditor);
      }
      (function () {
        this.getRowLength = function (row) {
          var h;
          if (this.lineWidgets) h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
          } else {
            return this.$wrapData[row].length + 1 + h;
          }
        };
        this.$getWidgetScreenLength = function () {
          var screenRows = 0;
          this.lineWidgets.forEach(function (w) {
            if (w && w.rowCount && !w.hidden) screenRows += w.rowCount;
          });
          return screenRows;
        };
        this.$onChangeEditor = function (e) {
          this.attach(e.editor);
        };
        this.attach = function (editor) {
          if (editor && editor.widgetManager && editor.widgetManager != this) editor.widgetManager.detach();
          if (this.editor == editor) return;
          this.detach();
          this.editor = editor;
          if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
          }
        };
        this.detach = function (e) {
          var editor = this.editor;
          if (!editor) return;
          this.editor = null;
          editor.widgetManager = null;
          editor.renderer.off("beforeRender", this.measureWidgets);
          editor.renderer.off("afterRender", this.renderWidgets);
          var lineWidgets = this.session.lineWidgets;
          lineWidgets && lineWidgets.forEach(function (w) {
            if (w && w.el && w.el.parentNode) {
              w._inDocument = false;
              w.el.parentNode.removeChild(w.el);
            }
          });
        };
        this.updateOnFold = function (e, session) {
          var lineWidgets = session.lineWidgets;
          if (!lineWidgets || !e.action) return;
          var fold = e.data;
          var start = fold.start.row;
          var end = fold.end.row;
          var hide = e.action == "add";
          for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i]) lineWidgets[i].hidden = hide;
          }
          if (lineWidgets[end]) {
            if (hide) {
              if (!lineWidgets[start]) lineWidgets[start] = lineWidgets[end];else lineWidgets[end].hidden = hide;
            } else {
              if (lineWidgets[start] == lineWidgets[end]) lineWidgets[start] = undefined;
              lineWidgets[end].hidden = hide;
            }
          }
        };
        this.updateOnChange = function (delta) {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets) return;
          var startRow = delta.start.row;
          var len = delta.end.row - startRow;
          if (len === 0) {} else if (delta.action == 'remove') {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function (w) {
              w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
          } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
          }
        };
        this.$updateRows = function () {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets) return;
          var noWidgets = true;
          lineWidgets.forEach(function (w, i) {
            if (w) {
              noWidgets = false;
              w.row = i;
              while (w.$oldWidget) {
                w.$oldWidget.row = i;
                w = w.$oldWidget;
              }
            }
          });
          if (noWidgets) this.session.lineWidgets = null;
        };
        this.addLineWidget = function (w) {
          if (!this.session.lineWidgets) this.session.lineWidgets = new Array(this.session.getLength());
          var old = this.session.lineWidgets[w.row];
          if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
              old.el.parentNode.removeChild(old.el);
              old._inDocument = false;
            }
          }
          this.session.lineWidgets[w.row] = w;
          w.session = this.session;
          var renderer = this.editor.renderer;
          if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
          }
          if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
          }
          if (!w.coverGutter) {
            w.el.style.zIndex = 3;
          }
          if (w.pixelHeight == null) {
            w.pixelHeight = w.el.offsetHeight;
          }
          if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
          }
          var fold = this.session.getFoldAt(w.row, 0);
          w.$fold = fold;
          if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row]) lineWidgets[fold.start.row] = w;else w.hidden = true;
          }
          this.session._emit("changeFold", {
            data: {
              start: {
                row: w.row
              }
            }
          });
          this.$updateRows();
          this.renderWidgets(null, renderer);
          this.onWidgetChanged(w);
          return w;
        };
        this.removeLineWidget = function (w) {
          w._inDocument = false;
          w.session = null;
          if (w.el && w.el.parentNode) w.el.parentNode.removeChild(w.el);
          if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
          } catch (e) {}
          if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
              this.session.lineWidgets[w.row] = w.$oldWidget;
              if (w.$oldWidget) this.onWidgetChanged(w.$oldWidget);
            } else {
              while (w1) {
                if (w1.$oldWidget == w) {
                  w1.$oldWidget = w.$oldWidget;
                  break;
                }
                w1 = w1.$oldWidget;
              }
            }
          }
          this.session._emit("changeFold", {
            data: {
              start: {
                row: w.row
              }
            }
          });
          this.$updateRows();
        };
        this.getWidgetsAtRow = function (row) {
          var lineWidgets = this.session.lineWidgets;
          var w = lineWidgets && lineWidgets[row];
          var list = [];
          while (w) {
            list.push(w);
            w = w.$oldWidget;
          }
          return list;
        };
        this.onWidgetChanged = function (w) {
          this.session._changedWidgets.push(w);
          this.editor && this.editor.renderer.updateFull();
        };
        this.measureWidgets = function (e, renderer) {
          var changedWidgets = this.session._changedWidgets;
          var config = renderer.layerConfig;
          if (!changedWidgets || !changedWidgets.length) return;
          var min = Infinity;
          for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el) continue;
            if (w.session != this.session) continue;
            if (!w._inDocument) {
              if (this.session.lineWidgets[w.row] != w) continue;
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            w.h = w.el.offsetHeight;
            if (!w.fixedWidth) {
              w.w = w.el.offsetWidth;
              w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
              rowCount -= this.session.getRowLineCount(w.row);
              if (rowCount < 0) rowCount = 0;
            }
            if (w.rowCount != rowCount) {
              w.rowCount = rowCount;
              if (w.row < min) min = w.row;
            }
          }
          if (min != Infinity) {
            this.session._emit("changeFold", {
              data: {
                start: {
                  row: min
                }
              }
            });
            this.session.lineWidgetWidth = null;
          }
          this.session._changedWidgets = [];
        };
        this.renderWidgets = function (e, renderer) {
          var config = renderer.layerConfig;
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets) return;
          var first = Math.min(this.firstRow, config.firstRow);
          var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
          while (first > 0 && !lineWidgets[first]) first--;
          this.firstRow = config.firstRow;
          this.lastRow = config.lastRow;
          renderer.$cursorLayer.config = config;
          for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;
            if (w.hidden) {
              w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
              continue;
            }
            if (!w._inDocument) {
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({
              row: i,
              column: 0
            }, true).top;
            if (!w.coverLine) top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth) left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            if (w.fullWidth && w.screenWidth) {
              w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            if (w.fixedWidth) {
              w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
              w.el.style.right = "";
            }
          }
        };
      }).call(LineWidgets.prototype);
      exports.LineWidgets = LineWidgets;
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var LineWidgets = acequire("../line_widgets").LineWidgets;
      var dom = acequire("../lib/dom");
      var Range = acequire("../range").Range;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = first + last >> 1;
          var c = comparator(needle, array[mid]);
          if (c > 0) first = mid + 1;else if (c < 0) last = mid - 1;else return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length) return;
        var i = binarySearch(annotations, {
          row: row,
          column: -1
        }, Range.comparePoints);
        if (i < 0) i = -i - 1;
        if (i >= annotations.length) i = dir > 0 ? 0 : annotations.length - 1;else if (i === 0 && dir < 0) i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir) return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i += dir];
          } while (annotation && annotation.row === row);
          if (!annotation) return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports.showErrorMarker = function (editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
          session.widgetManager = new LineWidgets(session);
          session.widgetManager.attach(editor);
        }
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
          return w.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        el.appendChild(dom.createElement("div"));
        var kb = function kb(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {
              command: "null"
            };
          }
        };
        w.destroy = function () {
          if (editor.$mouseHandler.isMousePressed) return;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w);
          editor.off("changeSelection", w.destroy);
          editor.off("changeSession", w.destroy);
          editor.off("mouseup", w.destroy);
          editor.off("change", w.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        editor.session.widgetManager.addLineWidget(w);
        w.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, {
          bottom: w.el.offsetHeight
        });
      };
      dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function (acequire, exports, module) {
      "use strict";

      acequire("./lib/fixoldbrowsers");
      var dom = acequire("./lib/dom");
      var event = acequire("./lib/event");
      var Editor = acequire("./editor").Editor;
      var EditSession = acequire("./edit_session").EditSession;
      var UndoManager = acequire("./undomanager").UndoManager;
      var Renderer = acequire("./virtual_renderer").VirtualRenderer;
      acequire("./worker/worker_client");
      acequire("./keyboard/hash_handler");
      acequire("./placeholder");
      acequire("./multi_select");
      acequire("./mode/folding/fold_mode");
      acequire("./theme/textmate");
      acequire("./ext/error_marker");
      exports.config = acequire("./config");
      exports.acequire = acequire;
      if (true) exports.define = __webpack_require__( /*! !webpack amd define */"./node_modules/webpack/buildin/amd-define.js");
      exports.edit = function (el) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el) throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor) return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = dom.getInnerText(el);
          el.innerHTML = "";
        }
        var doc = exports.createEditSession(value);
        var editor = new Editor(new Renderer(el));
        editor.setSession(doc);
        var env = {
          document: doc,
          editor: editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode) env.textarea = oldNode;
        event.addListener(window, "resize", env.onResize);
        editor.on("destroy", function () {
          event.removeListener(window, "resize", env.onResize);
          env.editor.container.env = null; // prevent memory leak on old ie
        });

        editor.container.env = editor.env = env;
        return editor;
      };
      exports.createEditSession = function (text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports.EditSession = EditSession;
      exports.UndoManager = UndoManager;
      exports.version = "1.2.9";
    });
    (function () {
      ace.acequire(["ace/ace"], function (a) {
        if (a) {
          a.config.init(true);
          a.define = ace.define;
        }
        if (!window.ace) window.ace = a;
        for (var key in a) if (a.hasOwnProperty(key)) window.ace[key] = a[key];
      });
    })();
    module.exports = window.ace.acequire("ace/ace");

    /***/
  },

  /***/"./node_modules/brace/mode/json.js":
  /*!*****************************************!*\
    !*** ./node_modules/brace/mode/json.js ***!
    \*****************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceModeJsonJs(module, exports, __webpack_require__) {
    ace.define("ace/mode/json_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../lib/oop");
      var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
      var JsonHighlightRules = function JsonHighlightRules() {
        this.$rules = {
          "start": [{
            token: "variable",
            // single line
            regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
          }, {
            token: "string",
            // single line
            regex: '"',
            next: "string"
          }, {
            token: "constant.numeric",
            // hex
            regex: "0[xX][0-9a-fA-F]+\\b"
          }, {
            token: "constant.numeric",
            // float
            regex: "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
          }, {
            token: "constant.language.boolean",
            regex: "(?:true|false)\\b"
          }, {
            token: "text",
            // single quoted strings are not allowed
            regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
          }, {
            token: "comment",
            // comments are not allowed, but who cares?
            regex: "\\/\\/.*$"
          }, {
            token: "comment.start",
            // comments are not allowed, but who cares?
            regex: "\\/\\*",
            next: "comment"
          }, {
            token: "paren.lparen",
            regex: "[[({]"
          }, {
            token: "paren.rparen",
            regex: "[\\])}]"
          }, {
            token: "text",
            regex: "\\s+"
          }],
          "string": [{
            token: "constant.language.escape",
            regex: /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
          }, {
            token: "string",
            regex: '"|$',
            next: "start"
          }, {
            defaultToken: "string"
          }],
          "comment": [{
            token: "comment.end",
            // comments are not allowed, but who cares?
            regex: "\\*\\/",
            next: "start"
          }, {
            defaultToken: "comment"
          }]
        };
      };
      oop.inherits(JsonHighlightRules, TextHighlightRules);
      exports.JsonHighlightRules = JsonHighlightRules;
    });
    ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      "use strict";

      var Range = acequire("../range").Range;
      var MatchingBraceOutdent = function MatchingBraceOutdent() {};
      (function () {
        this.checkOutdent = function (line, input) {
          if (!/^\s+$/.test(line)) return false;
          return /^\s*\}/.test(input);
        };
        this.autoOutdent = function (doc, row) {
          var line = doc.getLine(row);
          var match = line.match(/^(\s*\})/);
          if (!match) return 0;
          var column = match[1].length;
          var openBracePos = doc.findMatchingBracket({
            row: row,
            column: column
          });
          if (!openBracePos || openBracePos.row == row) return 0;
          var indent = this.$getIndent(doc.getLine(openBracePos.row));
          doc.replace(new Range(row, 0, row, column - 1), indent);
        };
        this.$getIndent = function (line) {
          return line.match(/^\s*/)[0];
        };
      }).call(MatchingBraceOutdent.prototype);
      exports.MatchingBraceOutdent = MatchingBraceOutdent;
    });
    ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../../lib/oop");
      var Range = acequire("../../range").Range;
      var BaseFoldMode = acequire("./fold_mode").FoldMode;
      var FoldMode = exports.FoldMode = function (commentRegex) {
        if (commentRegex) {
          this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
          this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
        }
      };
      oop.inherits(FoldMode, BaseFoldMode);
      (function () {
        this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
        this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
        this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
        this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
        this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
        this._getFoldWidgetBase = this.getFoldWidget;
        this.getFoldWidget = function (session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
          }
          var fw = this._getFoldWidgetBase(session, foldStyle, row);
          if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

          return fw;
        };
        this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
          var line = session.getLine(row);
          if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);
          var match = line.match(this.foldingStartMarker);
          if (match) {
            var i = match.index;
            if (match[1]) return this.openingBracketBlock(session, match[1], row, i);
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            if (range && !range.isMultiLine()) {
              if (forceMultiline) {
                range = this.getSectionRange(session, row);
              } else if (foldStyle != "all") range = null;
            }
            return range;
          }
          if (foldStyle === "markbegin") return;
          var match = line.match(this.foldingStopMarker);
          if (match) {
            var i = match.index + match[0].length;
            if (match[1]) return this.closingBracketBlock(session, match[1], row, i);
            return session.getCommentFoldRange(row, i, -1);
          }
        };
        this.getSectionRange = function (session, row) {
          var line = session.getLine(row);
          var startIndent = line.search(/\S/);
          var startRow = row;
          var startColumn = line.length;
          row = row + 1;
          var endRow = row;
          var maxRow = session.getLength();
          while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1) continue;
            if (startIndent > indent) break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            if (subRange) {
              if (subRange.start.row <= startRow) {
                break;
              } else if (subRange.isMultiLine()) {
                row = subRange.end.row;
              } else if (startIndent == indent) {
                break;
              }
            }
            endRow = row;
          }
          return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
        };
        this.getCommentRegionBlock = function (session, line, row) {
          var startColumn = line.search(/\s*$/);
          var maxRow = session.getLength();
          var startRow = row;
          var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
          var depth = 1;
          while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;else depth++;
            if (!depth) break;
          }
          var endRow = row;
          if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
          }
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/mode/json", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/json_highlight_rules", "ace/mode/matching_brace_outdent", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle", "ace/worker/worker_client"], function (acequire, exports, module) {
      "use strict";

      var oop = acequire("../lib/oop");
      var TextMode = acequire("./text").Mode;
      var HighlightRules = acequire("./json_highlight_rules").JsonHighlightRules;
      var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
      var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
      var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
      var WorkerClient = acequire("../worker/worker_client").WorkerClient;
      var Mode = function Mode() {
        this.HighlightRules = HighlightRules;
        this.$outdent = new MatchingBraceOutdent();
        this.$behaviour = new CstyleBehaviour();
        this.foldingRules = new CStyleFoldMode();
      };
      oop.inherits(Mode, TextMode);
      (function () {
        this.getNextLineIndent = function (state, line, tab) {
          var indent = this.$getIndent(line);
          if (state == "start") {
            var match = line.match(/^.*[\{\(\[]\s*$/);
            if (match) {
              indent += tab;
            }
          }
          return indent;
        };
        this.checkOutdent = function (state, line, input) {
          return this.$outdent.checkOutdent(line, input);
        };
        this.autoOutdent = function (state, doc, row) {
          this.$outdent.autoOutdent(doc, row);
        };
        this.createWorker = function (session) {
          var worker = new WorkerClient(["ace"], __webpack_require__( /*! ../worker/json */"./node_modules/brace/worker/json.js"), "JsonWorker");
          worker.attachToDocument(session.getDocument());
          worker.on("annotate", function (e) {
            session.setAnnotations(e.data);
          });
          worker.on("terminate", function () {
            session.clearAnnotations();
          });
          return worker;
        };
        this.$id = "ace/mode/json";
      }).call(Mode.prototype);
      exports.Mode = Mode;
    });

    /***/
  },

  /***/"./node_modules/brace/snippets/json.js":
  /*!*********************************************!*\
    !*** ./node_modules/brace/snippets/json.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceSnippetsJsonJs(module, exports) {
    ace.define("ace/snippets/json", ["require", "exports", "module"], function (e, t, n) {
      "use strict";

      t.snippetText = undefined, t.scope = "json";
    });

    /***/
  },

  /***/"./node_modules/brace/theme/monokai.js":
  /*!*********************************************!*\
    !*** ./node_modules/brace/theme/monokai.js ***!
    \*********************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceThemeMonokaiJs(module, exports) {
    ace.define("ace/theme/monokai", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      exports.isDark = true;
      exports.cssClass = "ace-monokai";
      exports.cssText = ".ace-monokai .ace_gutter {\
background: #2F3129;\
color: #8F908A\
}\
.ace-monokai .ace_print-margin {\
width: 1px;\
background: #555651\
}\
.ace-monokai {\
background-color: #272822;\
color: #F8F8F2\
}\
.ace-monokai .ace_cursor {\
color: #F8F8F0\
}\
.ace-monokai .ace_marker-layer .ace_selection {\
background: #49483E\
}\
.ace-monokai.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #272822;\
}\
.ace-monokai .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-monokai .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #49483E\
}\
.ace-monokai .ace_marker-layer .ace_active-line {\
background: #202020\
}\
.ace-monokai .ace_gutter-active-line {\
background-color: #272727\
}\
.ace-monokai .ace_marker-layer .ace_selected-word {\
border: 1px solid #49483E\
}\
.ace-monokai .ace_invisible {\
color: #52524d\
}\
.ace-monokai .ace_entity.ace_name.ace_tag,\
.ace-monokai .ace_keyword,\
.ace-monokai .ace_meta.ace_tag,\
.ace-monokai .ace_storage {\
color: #F92672\
}\
.ace-monokai .ace_punctuation,\
.ace-monokai .ace_punctuation.ace_tag {\
color: #fff\
}\
.ace-monokai .ace_constant.ace_character,\
.ace-monokai .ace_constant.ace_language,\
.ace-monokai .ace_constant.ace_numeric,\
.ace-monokai .ace_constant.ace_other {\
color: #AE81FF\
}\
.ace-monokai .ace_invalid {\
color: #F8F8F0;\
background-color: #F92672\
}\
.ace-monokai .ace_invalid.ace_deprecated {\
color: #F8F8F0;\
background-color: #AE81FF\
}\
.ace-monokai .ace_support.ace_constant,\
.ace-monokai .ace_support.ace_function {\
color: #66D9EF\
}\
.ace-monokai .ace_fold {\
background-color: #A6E22E;\
border-color: #F8F8F2\
}\
.ace-monokai .ace_storage.ace_type,\
.ace-monokai .ace_support.ace_class,\
.ace-monokai .ace_support.ace_type {\
font-style: italic;\
color: #66D9EF\
}\
.ace-monokai .ace_entity.ace_name.ace_function,\
.ace-monokai .ace_entity.ace_other,\
.ace-monokai .ace_entity.ace_other.ace_attribute-name,\
.ace-monokai .ace_variable {\
color: #A6E22E\
}\
.ace-monokai .ace_variable.ace_parameter {\
font-style: italic;\
color: #FD971F\
}\
.ace-monokai .ace_string {\
color: #E6DB74\
}\
.ace-monokai .ace_comment {\
color: #75715E\
}\
.ace-monokai .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y\
}";
      var dom = acequire("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });

    /***/
  },

  /***/"./node_modules/brace/theme/textmate.js":
  /*!**********************************************!*\
    !*** ./node_modules/brace/theme/textmate.js ***!
    \**********************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceThemeTextmateJs(module, exports) {
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      "use strict";

      exports.isDark = false;
      exports.cssClass = "ace-tm";
      exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
      var dom = acequire("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });

    /***/
  },

  /***/"./node_modules/brace/worker/json.js":
  /*!*******************************************!*\
    !*** ./node_modules/brace/worker/json.js ***!
    \*******************************************/
  /*! no static exports found */
  /***/
  function node_modulesBraceWorkerJsonJs(module, exports) {
    module.exports.id = 'ace/mode/json_worker';
    module.exports.src = "\"no use strict\";!function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}}(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}if(\"[object Object]\"!==Object.prototype.toString.call(obj))return obj;copy={};for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/json/json_parse\",[\"require\",\"exports\",\"module\"],function(){\"use strict\";var at,ch,text,value,escapee={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\t\"},error=function(m){throw{name:\"SyntaxError\",message:m,at:at,text:text}},next=function(c){return c&&c!==ch&&error(\"Expected '\"+c+\"' instead of '\"+ch+\"'\"),ch=text.charAt(at),at+=1,ch},number=function(){var number,string=\"\";for(\"-\"===ch&&(string=\"-\",next(\"-\"));ch>=\"0\"&&\"9\">=ch;)string+=ch,next();if(\".\"===ch)for(string+=\".\";next()&&ch>=\"0\"&&\"9\">=ch;)string+=ch;if(\"e\"===ch||\"E\"===ch)for(string+=ch,next(),(\"-\"===ch||\"+\"===ch)&&(string+=ch,next());ch>=\"0\"&&\"9\">=ch;)string+=ch,next();return number=+string,isNaN(number)?(error(\"Bad number\"),void 0):number},string=function(){var hex,i,uffff,string=\"\";if('\"'===ch)for(;next();){if('\"'===ch)return next(),string;if(\"\\\\\"===ch)if(next(),\"u\"===ch){for(uffff=0,i=0;4>i&&(hex=parseInt(next(),16),isFinite(hex));i+=1)uffff=16*uffff+hex;string+=String.fromCharCode(uffff)}else{if(\"string\"!=typeof escapee[ch])break;string+=escapee[ch]}else string+=ch}error(\"Bad string\")},white=function(){for(;ch&&\" \">=ch;)next()},word=function(){switch(ch){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+ch+\"'\")},array=function(){var array=[];if(\"[\"===ch){if(next(\"[\"),white(),\"]\"===ch)return next(\"]\"),array;for(;ch;){if(array.push(value()),white(),\"]\"===ch)return next(\"]\"),array;next(\",\"),white()}}error(\"Bad array\")},object=function(){var key,object={};if(\"{\"===ch){if(next(\"{\"),white(),\"}\"===ch)return next(\"}\"),object;for(;ch;){if(key=string(),white(),next(\":\"),Object.hasOwnProperty.call(object,key)&&error('Duplicate key \"'+key+'\"'),object[key]=value(),white(),\"}\"===ch)return next(\"}\"),object;next(\",\"),white()}}error(\"Bad object\")};return value=function(){switch(white(),ch){case\"{\":return object();case\"[\":return array();case'\"':return string();case\"-\":return number();default:return ch>=\"0\"&&\"9\">=ch?number():word()}},function(source,reviver){var result;return text=source,at=0,ch=\" \",result=value(),white(),ch&&error(\"Syntax error\"),\"function\"==typeof reviver?function walk(holder,key){var k,v,value=holder[key];if(value&&\"object\"==typeof value)for(k in value)Object.hasOwnProperty.call(value,k)&&(v=walk(value,k),void 0!==v?value[k]=v:delete value[k]);return reviver.call(holder,key,value)}({\"\":result},\"\"):result}}),ace.define(\"ace/mode/json_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/json/json_parse\"],function(acequire,exports){\"use strict\";var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,parse=acequire(\"./json/json_parse\"),JsonWorker=exports.JsonWorker=function(sender){Mirror.call(this,sender),this.setTimeout(200)};oop.inherits(JsonWorker,Mirror),function(){this.onUpdate=function(){var value=this.doc.getValue(),errors=[];try{value&&parse(value)}catch(e){var pos=this.doc.indexToPosition(e.at-1);errors.push({row:pos.row,column:pos.column,text:e.message,type:\"error\"})}this.sender.emit(\"annotate\",errors)}}.call(JsonWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0\n}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\x0B\\f\\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\\u2028\\u2029\uFEFF\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

    /***/
  },

  /***/"./node_modules/ng2-ace-editor/index.js":
  /*!**********************************************!*\
    !*** ./node_modules/ng2-ace-editor/index.js ***!
    \**********************************************/
  /*! exports provided: AceEditorDirective, AceEditorComponent, AceEditorModule */
  /***/
  function node_modulesNg2AceEditorIndexJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */
    var _src_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./src/directive */"./node_modules/ng2-ace-editor/src/directive.js");
    /* harmony reexport (safe) */
    __webpack_require__.d(__webpack_exports__, "AceEditorDirective", function () {
      return _src_directive__WEBPACK_IMPORTED_MODULE_0__["AceEditorDirective"];
    });

    /* harmony import */
    var _src_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./src/component */"./node_modules/ng2-ace-editor/src/component.js");
    /* harmony reexport (safe) */
    __webpack_require__.d(__webpack_exports__, "AceEditorComponent", function () {
      return _src_component__WEBPACK_IMPORTED_MODULE_1__["AceEditorComponent"];
    });

    /* harmony import */
    var _src_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./src/module */"./node_modules/ng2-ace-editor/src/module.js");
    /* harmony reexport (safe) */
    __webpack_require__.d(__webpack_exports__, "AceEditorModule", function () {
      return _src_module__WEBPACK_IMPORTED_MODULE_2__["AceEditorModule"];
    });

    //# sourceMappingURL=index.js.map

    /***/
  },

  /***/"./node_modules/ng2-ace-editor/src/component.js":
  /*!******************************************************!*\
    !*** ./node_modules/ng2-ace-editor/src/component.js ***!
    \******************************************************/
  /*! exports provided: AceEditorComponent */
  /***/
  function node_modulesNg2AceEditorSrcComponentJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AceEditorComponent", function () {
      return AceEditorComponent;
    });
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_forms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/forms */"./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */
    var brace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! brace */"./node_modules/brace/index.js");
    /* harmony import */
    var brace__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(brace__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */
    var brace_theme_monokai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! brace/theme/monokai */"./node_modules/brace/theme/monokai.js");
    /* harmony import */
    var brace_theme_monokai__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(brace_theme_monokai__WEBPACK_IMPORTED_MODULE_3__);
    var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = undefined && undefined.__metadata || function (k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var AceEditorComponent = /** @class */function () {
      function AceEditorComponent(elementRef, zone) {
        var _this = this;
        this.zone = zone;
        this.textChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.textChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.style = {};
        this._options = {};
        this._readOnly = false;
        this._theme = "monokai";
        this._mode = "html";
        this._autoUpdateContent = true;
        this._durationBeforeCallback = 0;
        this._text = "";
        this._onChange = function (_) {};
        this._onTouched = function () {};
        var el = elementRef.nativeElement;
        this.zone.runOutsideAngular(function () {
          _this._editor = ace['edit'](el);
        });
        this._editor.$blockScrolling = Infinity;
      }
      AceEditorComponent_1 = AceEditorComponent;
      AceEditorComponent.prototype.ngOnInit = function () {
        this.init();
        this.initEvents();
      };
      AceEditorComponent.prototype.ngOnDestroy = function () {
        this._editor.destroy();
      };
      AceEditorComponent.prototype.init = function () {
        this.setOptions(this._options || {});
        this.setTheme(this._theme);
        this.setMode(this._mode);
        this.setReadOnly(this._readOnly);
      };
      AceEditorComponent.prototype.initEvents = function () {
        var _this = this;
        this._editor.on('change', function () {
          return _this.updateText();
        });
        this._editor.on('paste', function () {
          return _this.updateText();
        });
      };
      AceEditorComponent.prototype.updateText = function () {
        var _this = this;
        var newVal = this._editor.getValue();
        if (newVal === this.oldText) {
          return;
        }
        if (!this._durationBeforeCallback) {
          this._text = newVal;
          this.zone.run(function () {
            _this.textChange.emit(newVal);
            _this.textChanged.emit(newVal);
          });
          this._onChange(newVal);
        } else {
          if (this.timeoutSaving) {
            clearTimeout(this.timeoutSaving);
          }
          this.timeoutSaving = setTimeout(function () {
            _this._text = newVal;
            _this.zone.run(function () {
              _this.textChange.emit(newVal);
              _this.textChanged.emit(newVal);
            });
            _this.timeoutSaving = null;
          }, this._durationBeforeCallback);
        }
        this.oldText = newVal;
      };
      Object.defineProperty(AceEditorComponent.prototype, "options", {
        set: function set(options) {
          this.setOptions(options);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setOptions = function (options) {
        this._options = options;
        this._editor.setOptions(options || {});
      };
      Object.defineProperty(AceEditorComponent.prototype, "readOnly", {
        set: function set(readOnly) {
          this.setReadOnly(readOnly);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setReadOnly = function (readOnly) {
        this._readOnly = readOnly;
        this._editor.setReadOnly(readOnly);
      };
      Object.defineProperty(AceEditorComponent.prototype, "theme", {
        set: function set(theme) {
          this.setTheme(theme);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setTheme = function (theme) {
        this._theme = theme;
        this._editor.setTheme("ace/theme/" + theme);
      };
      Object.defineProperty(AceEditorComponent.prototype, "mode", {
        set: function set(mode) {
          this.setMode(mode);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setMode = function (mode) {
        this._mode = mode;
        if (typeof this._mode === 'object') {
          this._editor.getSession().setMode(this._mode);
        } else {
          this._editor.getSession().setMode("ace/mode/" + this._mode);
        }
      };
      Object.defineProperty(AceEditorComponent.prototype, "value", {
        get: function get() {
          return this.text;
        },
        set: function set(value) {
          this.setText(value);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.writeValue = function (value) {
        this.setText(value);
      };
      AceEditorComponent.prototype.registerOnChange = function (fn) {
        this._onChange = fn;
      };
      AceEditorComponent.prototype.registerOnTouched = function (fn) {
        this._onTouched = fn;
      };
      Object.defineProperty(AceEditorComponent.prototype, "text", {
        get: function get() {
          return this._text;
        },
        set: function set(text) {
          this.setText(text);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setText = function (text) {
        if (text === null || text === undefined) {
          text = "";
        }
        if (this._text !== text && this._autoUpdateContent === true) {
          this._text = text;
          this._editor.setValue(text);
          this._onChange(text);
          this._editor.clearSelection();
        }
      };
      Object.defineProperty(AceEditorComponent.prototype, "autoUpdateContent", {
        set: function set(status) {
          this.setAutoUpdateContent(status);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setAutoUpdateContent = function (status) {
        this._autoUpdateContent = status;
      };
      Object.defineProperty(AceEditorComponent.prototype, "durationBeforeCallback", {
        set: function set(num) {
          this.setDurationBeforeCallback(num);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorComponent.prototype.setDurationBeforeCallback = function (num) {
        this._durationBeforeCallback = num;
      };
      AceEditorComponent.prototype.getEditor = function () {
        return this._editor;
      };
      var AceEditorComponent_1;
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), __metadata("design:type", Object)], AceEditorComponent.prototype, "textChanged", void 0);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), __metadata("design:type", Object)], AceEditorComponent.prototype, "textChange", void 0);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object)], AceEditorComponent.prototype, "style", void 0);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorComponent.prototype, "options", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorComponent.prototype, "readOnly", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorComponent.prototype, "theme", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorComponent.prototype, "mode", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", String), __metadata("design:paramtypes", [String])], AceEditorComponent.prototype, "value", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", String), __metadata("design:paramtypes", [String])], AceEditorComponent.prototype, "text", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorComponent.prototype, "autoUpdateContent", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Number), __metadata("design:paramtypes", [Number])], AceEditorComponent.prototype, "durationBeforeCallback", null);
      AceEditorComponent = AceEditorComponent_1 = __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        selector: 'ace-editor',
        template: '',
        styles: [':host { display:block;width:100%; }'],
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_1__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(function () {
            return AceEditorComponent_1;
          }),
          multi: true
        }]
      }), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]])], AceEditorComponent);
      return AceEditorComponent;
    }();

    //# sourceMappingURL=component.js.map

    /***/
  },

  /***/"./node_modules/ng2-ace-editor/src/directive.js":
  /*!******************************************************!*\
    !*** ./node_modules/ng2-ace-editor/src/directive.js ***!
    \******************************************************/
  /*! exports provided: AceEditorDirective */
  /***/
  function node_modulesNg2AceEditorSrcDirectiveJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AceEditorDirective", function () {
      return AceEditorDirective;
    });
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var brace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! brace */"./node_modules/brace/index.js");
    /* harmony import */
    var brace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(brace__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */
    var brace_theme_monokai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! brace/theme/monokai */"./node_modules/brace/theme/monokai.js");
    /* harmony import */
    var brace_theme_monokai__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(brace_theme_monokai__WEBPACK_IMPORTED_MODULE_2__);
    var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = undefined && undefined.__metadata || function (k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var AceEditorDirective = /** @class */function () {
      function AceEditorDirective(elementRef, zone) {
        var _this = this;
        this.zone = zone;
        this.textChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.textChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this._options = {};
        this._readOnly = false;
        this._theme = "monokai";
        this._mode = "html";
        this._autoUpdateContent = true;
        this._durationBeforeCallback = 0;
        this._text = "";
        var el = elementRef.nativeElement;
        this.zone.runOutsideAngular(function () {
          _this.editor = ace["edit"](el);
        });
        this.editor.$blockScrolling = Infinity;
      }
      AceEditorDirective.prototype.ngOnInit = function () {
        this.init();
        this.initEvents();
      };
      AceEditorDirective.prototype.ngOnDestroy = function () {
        this.editor.destroy();
      };
      AceEditorDirective.prototype.init = function () {
        this.editor.setOptions(this._options || {});
        this.editor.setTheme("ace/theme/" + this._theme);
        this.setMode(this._mode);
        this.editor.setReadOnly(this._readOnly);
      };
      AceEditorDirective.prototype.initEvents = function () {
        var _this = this;
        this.editor.on('change', function () {
          return _this.updateText();
        });
        this.editor.on('paste', function () {
          return _this.updateText();
        });
      };
      AceEditorDirective.prototype.updateText = function () {
        var _this = this;
        var newVal = this.editor.getValue();
        if (newVal === this.oldText) {
          return;
        }
        if (!this._durationBeforeCallback) {
          this._text = newVal;
          this.zone.run(function () {
            _this.textChange.emit(newVal);
            _this.textChanged.emit(newVal);
          });
        } else {
          if (this.timeoutSaving != null) {
            clearTimeout(this.timeoutSaving);
          }
          this.timeoutSaving = setTimeout(function () {
            _this._text = newVal;
            _this.zone.run(function () {
              _this.textChange.emit(newVal);
              _this.textChanged.emit(newVal);
            });
            _this.timeoutSaving = null;
          }, this._durationBeforeCallback);
        }
        this.oldText = newVal;
      };
      Object.defineProperty(AceEditorDirective.prototype, "options", {
        set: function set(options) {
          this._options = options;
          this.editor.setOptions(options || {});
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "readOnly", {
        set: function set(readOnly) {
          this._readOnly = readOnly;
          this.editor.setReadOnly(readOnly);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "theme", {
        set: function set(theme) {
          this._theme = theme;
          this.editor.setTheme("ace/theme/" + theme);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "mode", {
        set: function set(mode) {
          this.setMode(mode);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorDirective.prototype.setMode = function (mode) {
        this._mode = mode;
        if (typeof this._mode === 'object') {
          this.editor.getSession().setMode(this._mode);
        } else {
          this.editor.getSession().setMode("ace/mode/" + this._mode);
        }
      };
      Object.defineProperty(AceEditorDirective.prototype, "text", {
        get: function get() {
          return this._text;
        },
        set: function set(text) {
          this.setText(text);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorDirective.prototype.setText = function (text) {
        if (this._text !== text) {
          if (text === null || text === undefined) {
            text = "";
          }
          if (this._autoUpdateContent === true) {
            this._text = text;
            this.editor.setValue(text);
            this.editor.clearSelection();
          }
        }
      };
      Object.defineProperty(AceEditorDirective.prototype, "autoUpdateContent", {
        set: function set(status) {
          this._autoUpdateContent = status;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "durationBeforeCallback", {
        set: function set(num) {
          this.setDurationBeforeCallback(num);
        },
        enumerable: true,
        configurable: true
      });
      AceEditorDirective.prototype.setDurationBeforeCallback = function (num) {
        this._durationBeforeCallback = num;
      };
      Object.defineProperty(AceEditorDirective.prototype, "aceEditor", {
        get: function get() {
          return this.editor;
        },
        enumerable: true,
        configurable: true
      });
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), __metadata("design:type", Object)], AceEditorDirective.prototype, "textChanged", void 0);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), __metadata("design:type", Object)], AceEditorDirective.prototype, "textChange", void 0);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorDirective.prototype, "options", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorDirective.prototype, "readOnly", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorDirective.prototype, "theme", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorDirective.prototype, "mode", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", String), __metadata("design:paramtypes", [String])], AceEditorDirective.prototype, "text", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], AceEditorDirective.prototype, "autoUpdateContent", null);
      __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), __metadata("design:type", Number), __metadata("design:paramtypes", [Number])], AceEditorDirective.prototype, "durationBeforeCallback", null);
      AceEditorDirective = __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"])({
        selector: '[ace-editor]'
      }), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]])], AceEditorDirective);
      return AceEditorDirective;
    }();

    //# sourceMappingURL=directive.js.map

    /***/
  },

  /***/"./node_modules/ng2-ace-editor/src/module.js":
  /*!***************************************************!*\
    !*** ./node_modules/ng2-ace-editor/src/module.js ***!
    \***************************************************/
  /*! exports provided: AceEditorModule */
  /***/
  function node_modulesNg2AceEditorSrcModuleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AceEditorModule", function () {
      return AceEditorModule;
    });
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./component */"./node_modules/ng2-ace-editor/src/component.js");
    /* harmony import */
    var _directive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./directive */"./node_modules/ng2-ace-editor/src/directive.js");
    var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var list = [_component__WEBPACK_IMPORTED_MODULE_1__["AceEditorComponent"], _directive__WEBPACK_IMPORTED_MODULE_2__["AceEditorDirective"]];
    var AceEditorModule = /** @class */function () {
      function AceEditorModule() {}
      AceEditorModule = __decorate([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
        declarations: list.slice(),
        imports: [],
        providers: [],
        exports: list
      })], AceEditorModule);
      return AceEditorModule;
    }();

    //# sourceMappingURL=module.js.map

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/modules/viewer/viewer.component.html":
  /*!**************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/modules/viewer/viewer.component.html ***!
    \**************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibModulesViewerViewerComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<div style=\"\n  height: 100vh;\n  top: 0px;\n  left: 0px;\n  position: fixed;\n  right: 0px;\n  bottom: 0px;\n  z-index: 1000\">\n  <mat-toolbar style=\"display: flex; justify-content: center; height: auto;\">\n    <mat-label class=\"padding-s font-size-m\" i18n>Device Type</mat-label>\n    <mat-form-field class=\"font-size-m\">\n      <mat-select [(value)]=\"selected\">\n        <mat-option style=\"z-index: 1002\" *ngFor=\"let device of previewDevices\" [value]=\"device\">\n          {{ device.viewValue }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </mat-toolbar>\n  <div style=\"display: flex; justify-content: center; overflow: hidden; padding: 8px;\" class=\"mat-toolbar\">\n    <iframe style=\"overflow: auto;\" class=\"iframe\" [src]=\"iframeUrl | pipeSafeSanitizer: 'resourceUrl'\"\n      [width]=\"selected.width\">\n    </iframe>\n  </div>\n</div>\n\n<input #mobile type=\"hidden\" i18n-value value=\"Mobile\" />\n<input #tab type=\"hidden\" i18n-value value=\"Tablet\" />\n<input #desktop type=\"hidden\" i18n-value value=\"Desktop\" />\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.html":
  /*!****************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.html ***!
    \****************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorComponentsEditorEditorComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<router-outlet></router-outlet>\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.html":
  /*!*******************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.html ***!
    \*******************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAceEditorAceEditorComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<div>\n  <ace-editor #editor [(text)]=\"text\" [mode]=\"mode\" [options]=\"options\" [readOnly]=\"false\" [autoUpdateContent]=\"false\"\n    (textChanged)=\"onChange($event)\" [theme]=\"'textmate'\" [durationBeforeCallback]=\"1000\"></ace-editor>\n</div>\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.html":
  /*!***************************************************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.html ***!
    \***************************************************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthEditorActionButtonsAuthEditorActionButtonsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<div class=\"buttons margin-top-xl\">\n  <div\n    class=\"button-grid margin-right-xxs cursor-pointer\"\n    (click)=\"showSettingButtons = !showSettingButtons\"\n  >\n    <button mat-icon-button class=\"padding-remove ws-mat-primary-background mat-elevation-z6\">\n      <mat-icon class=\"text-white\" *ngIf=\"showSettingButtons\">close</mat-icon>\n      <mat-icon class=\"text-white\" *ngIf=\"!showSettingButtons\">more_vert</mat-icon>\n    </button>\n    <p class=\"mat-h5 margin-remove button-text padding-remove-top\" *ngIf=\"showSettingButtons\" i18n>\n      Close\n    </p>\n  </div>\n  <ng-container *ngIf=\"showSettingButtons\">\n    <div\n      *ngFor=\"let button of buttonConfig?.buttons || []\"\n      class=\"button-grid cursor-pointer\"\n      (click)=\"action.next(button.event)\"\n    >\n      <button mat-icon-button class=\" mat-elevation-z5 small-button padding-remove  margin-top-l\">\n        <mat-icon class=\"text-white small-icon ws-mat-primary-text\">{{ button.icon }}</mat-icon>\n      </button>\n      <p class=\"mat-h5 margin-remove button-text\">\n        {{ button.title }}\n      </p>\n    </div>\n  </ng-container>\n</div>\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.html":
  /*!***********************************************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.html ***!
    \***********************************************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthLanguageSelectBarAuthLanguageSelectBarComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<p>auth-language-select-bar works!</p>\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.html":
  /*!*********************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.html ***!
    \*********************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthPickerAuthPickerComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<h1 mat-dialog-title>Add Content</h1>\n<mat-dialog-content>\n  <mat-chip-list class=\"mb-4 block\">\n    <mat-chip *ngFor=\"let content of selectedContents\" [removable]=\"true\"\n      (removed)=\"selectedContentChanged(content, false)\">\n      <ng-container *ngIf=\"content.name; else noName\">{{ content.name || '' }}</ng-container>\n      <mat-icon matChipRemove>cancel</mat-icon>\n    </mat-chip>\n  </mat-chip-list>\n  <div class=\"flex\">\n    <mat-form-field class=\"width-expand margin-right-m\" appearance=\"fill\" floatLabel=\"never\">\n      <mat-icon matPrefix>search</mat-icon>\n      <mat-label i18n>Search content</mat-label>\n      <input matInput [(ngModel)]=\"query\" (ngModelChange)=\"debounceSubject.next(true)\" autocomplete=\"off\"\n        class=\"resize-none\" />\n    </mat-form-field>\n    <div class=\"btn-filter\">\n      <mat-slide-toggle [(ngModel)]=\"showMine\" (change)=\"debounceSubject.next(true)\" i18n>Show only my contents\n      </mat-slide-toggle>\n    </div>\n  </div>\n  <h2 *ngIf=\"searchFetchStatus === 'error'\" class=\"mat-title\" i18n>\n    Error fetching data\n  </h2>\n  <h2 *ngIf=\"searchFetchStatus === 'done' && !searchResults?.length\" class=\"mat-title\" i18n>\n    No results\n  </h2>\n  <div class=\"flex flex-wrap -mr-4\" *ngIf=\"searchFetchStatus === 'done'\">\n    <div class=\"w-full sm:w-1/2 mb-4 flex\" *ngFor=\"let content of searchResults\">\n      <mat-checkbox [checked]=\"\n          selectedContentIds?.has(content?.identifier) || preSelected?.has(content?.identifier)\n        \" [disabled]=\"preSelected?.has(content?.identifier)\" (change)=\"selectedContentChanged(content, $event.checked)\"\n        class=\"leading-none pr-4\">\n      </mat-checkbox>\n      <img class=\"w-24 h-16 ws-mat-primary-lite-background\" [src]=\"content?.appIcon\"\n        [wsUtilsDefaultThumbnail]=\"defaultThumbnail\" alt=\"Content Icon\" i18n-alt />\n      <div class=\"flex-1 min-w-0\">\n        <div class=\"flex\">\n          <h3\n            class=\"flex-1 min-w-0 mat-subheading-2 margin-remove-bottom margin-left-xs margin-right-xs truncate leading-none pb-1\">\n            <ng-container *ngIf=\"content.name; else noName\">{{ content.name || '' }}</ng-container>\n          </h3>\n        </div>\n        <p class=\"margin-remove-bottom margin-left-xs margin-right-xs\">\n          <ng-container *ngIf=\"content?.duration\">{{ content.duration | pipeDurationTransform: 'hms' }}\n          </ng-container>\n        </p>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"flex flex-wrap -mr-4\" *ngIf=\"searchFetchStatus === 'fetching'\">\n    <div class=\"w-full sm:w-1/2 mb-4 flex\" *ngFor=\"let _ of ' '.repeat(10).split('')\">\n      <div class=\"w-24 h-16 ws-mat-primary-lite-background\"></div>\n      <div class=\"flex-1 min-w-0\">\n        <div class=\"h-5 ml-2 mr-8 mb-2 bg-gray-400\"></div>\n        <div class=\"h-4 ml-2 mr-32 bg-gray-400\"></div>\n      </div>\n    </div>\n  </div>\n  <ng-template #noName i18n>Untitled Content</ng-template>\n</mat-dialog-content>\n<div mat-dialog-actions class=\"float-right\">\n  <button mat-stroked-button [mat-dialog-close] cdkFocusInitial i18n>Cancel</button>\n  <button mat-raised-button (click)=\"close()\" [disabled]=\"!selectedContents || !selectedContents.length\" color=\"primary\"\n    i18n>\n    Add\n  </button>\n</div>\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.html":
  /*!*****************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.html ***!
    \*****************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditMetaEditMetaComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<form [formGroup]=\"contentForm\" class=\"width-2-3\">\n  <mat-sidenav class=\"padding-s width-300\" position=\"end\" [fixedInViewport]=\"true\" [(opened)]=\"sideNavBarOpened\">\n    <div class=\"flex header-bg\">\n      <h2 class=\"margin-left-l margin-top-l\">Course Settings</h2>\n      <mat-icon class=\"ws-mat-primary-text margin-top-l pointer cross-btn\" (click)=\"sideNavBarOpened=false\">\n        clear\n      </mat-icon>\n    </div>   \n    <div class=\"inner-section\">\n      <div class=\"margin-right-l margin-top-l\">\n\n        <div class=\"margin-top-xs margin-left-xl\" *ngIf=\"checkCondition('exclusiveContent', 'show')\"\n          [ngClass]=\"{ disable: checkCondition('exclusiveContent', 'disabled') }\">\n          <label>\n            <div class=\"margin-top-xs flex flex-middle\">\n              <b [ngClass]=\"{ required: checkCondition('exclusiveContent', 'required') }\" i18n>Cost</b>\n              <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('exclusiveContent')\">\n                info\n              </mat-icon>\n            </div>\n            <span i18n *ngIf=\"infoType === 'exclusiveContent'\">Is Paid Content?</span>\n          </label>\n          <div class=\"margin-top-l\">\n            <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('exclusiveContent') }\">\n              <mat-select formControlName=\"exclusiveContent\" i18n-placeholder placeholder=\"--Select--\">\n                <mat-option [value]=\"true\" i18n> Paid</mat-option>\n                <mat-option [value]=\"false\" i18n> Free </mat-option>\n              </mat-select>\n              <mat-error *ngIf=\"showError('exclusiveContent')\" i18n>Cost is mandatory\n              </mat-error>\n            </mat-form-field>\n          </div>\n        </div>\n        <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('complexityLevel', 'show')\"\n          [ngClass]=\"{ disable: checkCondition('complexityLevel', 'disabled') }\">\n          <label>\n            <div class=\"margin-top-xs flex flex-middle\"\n              [ngClass]=\"{ required: checkCondition('complexityLevel', 'required') }\">\n              <b i18n>Knowledge Level</b>\n              <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('knowledgeLevel')\">info\n              </mat-icon>\n            </div>\n            <span i18n *ngIf=\"infoType === 'knowledgeLevel'\">How tough do you think the content is?</span>\n          </label>\n          <div class=\"margin-top-l\">\n            <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('complexityLevel') }\">\n              <mat-select formControlName=\"complexityLevel\" i18n-placeholder placeholder=\"--Select--\">\n                <mat-option *ngIf=\"!checkCondition('complexityLevel', 'required')\" i18n [value]=\"null\">None\n                </mat-option>\n                <mat-option *ngFor=\"let complexityLevel of complexityLevelList\" [value]=\"complexityLevel\">\n                  {{ complexityLevel }}</mat-option>\n              </mat-select>\n              <mat-error *ngIf=\"showError('complexityLevel')\" i18n>Knowledge Level is mandatory\n              </mat-error>\n            </mat-form-field>\n          </div>\n        </div>\n      </div>\n\n\n      <div class=\"margin-right-l\">\n        <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('fileType', 'show')\"\n          [ngClass]=\"{ disable: checkCondition('fileType', 'disabled') }\">\n          <label [ngClass]=\"{ required: checkCondition('fileType', 'required') }\">\n            <b i18n>File Type</b>\n          </label>\n          <div class=\"margin-top-l\">\n            <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('fileType') }\">\n              <mat-select formControlName=\"fileType\" i18n-placeholder placeholder=\"--Select--\">\n                <mat-option *ngIf=\"!checkCondition('fileType', 'required')\" i18n [value]=\"null\">None</mat-option>\n                <mat-option *ngFor=\"let fileType of ordinals.fileType\" [value]=\"fileType\">\n                  {{ fileType }}</mat-option>\n              </mat-select>\n              <mat-error *ngIf=\"showError('fileType')\" i18n>File Type is mandatory </mat-error>\n            </mat-form-field>\n          </div>\n        </div>\n        <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('visibility', 'show')\"\n          [ngClass]=\"{ disable: checkCondition('visibility', 'disabled') }\">\n          <label>\n            <div class=\"margin-top-xs flex flex-middle\">\n              <b [ngClass]=\"{ required: checkCondition('visibility', 'required') }\" i18n>Allow preview in draft mode\n                for others</b>\n              <mat-icon *ngIf=\"contentForm.controls.visibility.value === 'Public'\"\n                matTooltip=\"Click to copy the private url\" class=\"margin-left-xs pointer\"\n                (click)=\"copyData('previewUrl')\">file_copy\n              </mat-icon>\n              <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('previewUrl')\">info\n              </mat-icon>\n            </div>\n            <span i18n *ngIf=\"infoType === 'previewUrl'\">Anyone with this URL can see the content</span>\n          </label>\n          <div class=\"margin-top-l\">\n            <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('visibility') }\">\n              <mat-select formControlName=\"visibility\" i18n-placeholder placeholder=\"--Select--\">\n                <mat-option [value]=\"'Private'\" i18n> Don't Allow </mat-option>\n                <mat-option [value]=\"'Public'\"> Allow </mat-option>\n              </mat-select>\n              <mat-error *ngIf=\"showError('visibility')\" i18n>The above feild is mandatory\n              </mat-error>\n            </mat-form-field>\n          </div>\n        </div>\n      </div>\n\n      <ng-template i18n>\n        Intended For\n      </ng-template>\n      <div class=\"margin-top-xl margin-right-l\">\n        <p class=\"mat-h5 margin-top-s margin-left-xl\" *ngIf=\"checkCondition('audience', 'show')\">\n          * Provide meta details. Depending on the content type, some properties are enabled or\n          disabled.\n        </p>\n        <div class=\"showInpoup\">\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('audience', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('audience', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Audience</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('audience')\">info\n                </mat-icon>\n              </div>\n              <span i18n *ngIf=\"infoType === 'audience'\">\n                Add one or more targeted listeners for whom this content is intended for\n              </span>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs width-90\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('audience') }\">\n                <mat-chip-list #audienceChipList i18n-aria-label aria-label=\"Audience selection\">\n                  <mat-chip *ngFor=\"let job of contentForm.controls.audience.value\" [selectable]=\"selectable\"\n                    [removable]=\"removable\" (removed)=\"removeFromFormControl(job, 'audience')\">\n                    {{ job }}\n                    <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                  </mat-chip>\n                  <input i18n-placeholder placeholder=\"--Select--\" #audienceView [formControl]=\"audienceCtrl\"\n                    [matChipInputFor]=\"audienceChipList\" [matAutocomplete]=\"audienceAuto\"\n                    [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\" [matChipInputAddOnBlur]=\"false\"\n                    (matChipInputTokenEnd)=\"removeField($event)\" />\n                </mat-chip-list>\n                <mat-autocomplete #audienceAuto=\"matAutocomplete\"\n                  (optionSelected)=\"addToFormControl($event, 'audience')\">\n                  <mat-option *ngIf=\"!checkCondition('audience', 'required')\" i18n [value]=\"null\">None\n                  </mat-option>\n                  <mat-option *ngFor=\"let job of audienceList\" [value]=\"job\">\n                    {{ job }}\n                  </mat-option>\n                </mat-autocomplete>\n                <mat-error class=\"error-font\" *ngIf=\"showError('audience')\" i18n>Audience is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('org', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('org', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Organisation</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('organisation')\">info\n                </mat-icon>\n              </div>\n              <span i18n *ngIf=\"infoType === 'organisation'\">\n                Select your organisation below\n              </span>\n            </label>\n            <div class=\"margin-top-s\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs width-90\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('org') }\">\n                <mat-select formControlName=\"org\" i18n-placeholder placeholder=\"--Select--\" multiple>\n                  <mat-select-trigger>\n                    {{ contentForm.controls.org.value ? contentForm.controls.org.value[0] : '' }}\n                    <span *ngIf=\"contentForm.controls.org.value\" class=\"example-additional-selection\">\n                      (+{{ contentForm.controls.org.value.length - 1 }}\n                      <ng-container *ngIf=\"contentForm.controls.org.value.length === 2\" i18n>other</ng-container>\n                      <ng-container *ngIf=\"contentForm.controls.org.value.length > 2\" i18n>others</ng-container>\n                      )\n                    </span>\n                  </mat-select-trigger>\n                  <mat-option *ngFor=\"let org of ordinals.org\" [value]=\"org\">{{\n                        org\n                      }}</mat-option>\n                </mat-select>\n                <mat-error *ngIf=\"showError('org')\" i18n>Organisation is mandatory </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n        </div>\n        <!-- till here-->\n        <div class=\"\">\n          <div class=\"margin-top-xs margin-left-xl flex-1\">\n            <div class=\"margin-top-xs margin-bottom-s flex flex-middle\">\n              <div class=\"margin-top-xs width-90\" *ngIf=\"checkCondition('region', 'show')\"\n                [ngClass]=\"{ disable: checkCondition('region', 'disabled') }\">\n                <label>\n                  <b class=\"margin-remove-bottom\" i18n>Region</b>\n                </label>\n                <div class=\"margin-top-xs\">\n                  <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n                    [ngClass]=\"{ 'mat-form-field-invalid': showError('region') }\">\n                    <mat-chip-list #regionChipList i18n-aria-label aria-label=\"Region selection\">\n                      <mat-chip *ngFor=\"let region of contentForm.controls.region.value\" [selectable]=\"selectable\"\n                        [removable]=\"removable\" (removed)=\"removeFromFormControl(region, 'region')\">\n                        {{ region }}\n                        <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                      </mat-chip>\n                      <input i18n-placeholder placeholder=\"Search by region\" #regionView [formControl]=\"regionCtrl\"\n                        [matChipInputFor]=\"regionChipList\" [matAutocomplete]=\"regionAuto\"\n                        [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\" [matChipInputAddOnBlur]=\"false\"\n                        (matChipInputTokenEnd)=\"removeField($event)\" />\n                    </mat-chip-list>\n                    <mat-autocomplete #regionAuto=\"matAutocomplete\"\n                      (optionSelected)=\"addToFormControl($event, 'region')\">\n                      <mat-option *ngFor=\"let region of regionList\" [value]=\"region\">\n                        {{ region }}\n                      </mat-option>\n                    </mat-autocomplete>\n                    <mat-error class=\"error-font\" *ngIf=\"showError('region')\" i18n>Region is mandatory\n                    </mat-error>\n                  </mat-form-field>\n                </div>\n              </div>\n            </div>\n          </div>\n          <!--Show in popup-->\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('accessPaths', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('accessPaths', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Access Restrictions</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('accessPaths')\">info\n                </mat-icon>\n              </div>\n              <span i18n *ngIf=\"infoType === 'accessPaths'\">\n                Restrict access to your content by choosing your preference below\n              </span>\n            </label>\n            <div class=\"margin-top-s\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('accessPaths') }\">\n                <mat-chip-list #accessPathChipList i18n-aria-label aria-label=\"Region selection\">\n                  <mat-chip *ngFor=\"let path of contentForm.controls.accessPaths.value\" [selectable]=\"selectable\"\n                    [removable]=\"true\" (removed)=\"removeFromFormControl(path, 'accessPaths')\">\n                    {{ path }}\n                    <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                  </mat-chip>\n                  <input i18n-placeholder placeholder=\"Accessible by everyone\" #accessPathsView\n                    [formControl]=\"accessPathsCtrl\" [matChipInputFor]=\"accessPathChipList\"\n                    [matAutocomplete]=\"accessPathAuto\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n                    [matChipInputAddOnBlur]=\"false\" (matChipInputTokenEnd)=\"removeField($event)\" />\n                </mat-chip-list>\n                <mat-autocomplete #accessPathAuto=\"matAutocomplete\"\n                  (optionSelected)=\"addToFormControl($event, 'accessPaths')\">\n                  <mat-option *ngFor=\"let path of accessPathList\" [value]=\"path\">\n                    {{ path }}\n                  </mat-option>\n                </mat-autocomplete>\n                <mat-error class=\"error-font\" *ngIf=\"showError('accessPaths')\" i18n>Region is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n        </div>\n        <div class=\"\">\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('jobProfile', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('jobProfile', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Job Profiles</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('jobProfile')\">info\n                </mat-icon>\n              </div>\n              <span i18n *ngIf=\"infoType === 'jobProfile'\">\n                Add one or more targeted listeners for whom this content is intended for\n              </span>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs width-90\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('jobProfile') }\">\n                <mat-chip-list #jobProfileChipList i18n-aria-label aria-label=\"Job profile selection\">\n                  <mat-chip *ngFor=\"let job of contentForm.controls.jobProfile.value\" [selectable]=\"selectable\"\n                    [removable]=\"removable\" (removed)=\"removeFromFormControl(job, 'jobProfile')\">\n                    {{ job }}\n                    <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                  </mat-chip>\n                  <input i18n-placeholder placeholder=\"--Select--\" #jobProfileView [formControl]=\"jobProfileCtrl\"\n                    [matChipInputFor]=\"jobProfileChipList\" [matAutocomplete]=\"jobProfileAuto\"\n                    [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\" [matChipInputAddOnBlur]=\"false\"\n                    (matChipInputTokenEnd)=\"removeField($event)\" />\n                </mat-chip-list>\n                <mat-autocomplete #jobProfileAuto=\"matAutocomplete\"\n                  (optionSelected)=\"addToFormControl($event, 'jobProfile')\">\n                  <mat-option *ngIf=\"!checkCondition('jobProfile', 'required')\" i18n [value]=\"null\">None\n                  </mat-option>\n                  <mat-option *ngFor=\"let job of jobProfileList\" [value]=\"job\">\n                    {{ job }}\n                  </mat-option>\n                </mat-autocomplete>\n                <mat-error class=\"error-font\" *ngIf=\"showError('jobProfile')\" i18n>Job Profile is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n        </div>\n\n      </div>\n\n      <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('skills', 'show')\"\n        [ngClass]=\"{ disable: checkCondition('skills', 'disabled') }\">\n        <label>\n          <div class=\"margin-top-xs flex flex-middle\">\n            <b [ngClass]=\"{ required: checkCondition('skills', 'required') }\">Skills</b>\n            <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('skills')\">info\n            </mat-icon>\n          </div>\n          <span *ngIf=\"infoType === 'skills'\">Add one or more skills associated with this content</span>\n        </label>\n        <div class=\"margin-top-xs flex margin-right-xl\" [ngClass]=\"{ 'mat-form-field-invalid': showError('skills') }\">\n          <mat-form-field class=\"keywords-chip-list margin-top-xs flex-grow80\" appearance=\"outline\">\n            <mat-chip-list #skills aria-label=\"Keyword selection\">\n              <mat-chip *ngFor=\"let key of contentForm.controls.skills.value\" [selectable]=\"selectable\"\n                [removable]=\"removable\" (removed)=\"removeSkill(key)\">\n                {{ key }}\n                <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n              </mat-chip>\n              <input i18n-placeholder formControlName=\"skills\" placeholder=\"Skills\" #skillsView\n                [matChipInputFor]=\"skills\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n                [matChipInputAddOnBlur]=\"true\" />\n            </mat-chip-list>\n            <mat-select [compareWith]=\"compareSkillFn\" formControlName=\"skills\" placeholder=\"--Select--\"\n              [required]=\"checkCondition('skills', 'required')\" multiple>\n              <mat-option *ngFor=\"let skill of ordinals.skills\" [value]=\"skill\">\n                {{ skill.name }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n        </div>\n        <mat-error *ngIf=\"showError('skills')\" i18n>Skills is mandatory </mat-error>\n      </div>\n\n      <div class=\"margin-top-xs margin-left-xl margin-right-l flex-1\" *ngIf=\"checkCondition('idealScreenSize', 'show')\"\n        [ngClass]=\"{ disable: checkCondition('idealScreenSize', 'disabled') }\">\n        <label>\n          <div class=\"margin-top-s flex flex-middle\">\n            <b [ngClass]=\"{ required: checkCondition('idealScreenSize', 'required') }\" i18n>Best viewed in</b>\n            <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('bestViewedIn')\">info\n            </mat-icon>\n          </div>\n          <span i18n *ngIf=\"infoType === 'bestViewedIn'\">\n            The preferred screen for this content\n          </span>\n        </label>\n        <div class=\"margin-top-s\">\n          <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n            [ngClass]=\"{ 'mat-form-field-invalid': showError('idealScreenSize') }\">\n            <mat-select formControlName=\"idealScreenSize\" i18n-placeholder placeholder=\"--Select--\">\n              <mat-option *ngIf=\"!checkCondition('idealScreenSize', 'required')\" i18n [value]=\"null\">None\n              </mat-option>\n              <mat-option [value]=\"'7'\" i18n> Mobile</mat-option>\n              <mat-option [value]=\"'10'\" i18n> Tablet</mat-option>\n              <mat-option [value]=\"'13'\" i18n> Desktop</mat-option>\n            </mat-select>\n            <mat-error *ngIf=\"showError('idealScreenSize')\" i18n>Best viewed in is mandatory\n            </mat-error>\n          </mat-form-field>\n        </div>\n      </div>\n      <div class=\"margin-top-xl margin-right-l\">\n        <div class=\"\">\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('trackContacts', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('trackContacts', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Reviewers</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('reviewers')\">info\n                </mat-icon>\n              </div>\n              <span *ngIf=\"infoType === 'reviewers'\">\n                Person who can review this content\n              </span>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs\" class=\"margin-top-xs\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('trackContacts') }\">\n                <mat-chip-list #reviewerChipList i18n-aria-label aria-label=\"Reviewer selection\">\n                  <mat-chip *ngFor=\"let author of contentForm.controls.trackContacts.value\" [selectable]=\"selectable\"\n                    [removable]=\"removable\" (removed)=\"removeEmployee(author, 'trackContacts')\">\n                    {{ author.name }}\n                    <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                  </mat-chip>\n                  <input i18n-placeholder placeholder=\"Search by mail\" #trackContactsView\n                    [formControl]=\"trackContactsCtrl\" [matChipInputFor]=\"reviewerChipList\"\n                    [matAutocomplete]=\"reivewerAuto\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n                    [matChipInputAddOnBlur]=\"false\" (matChipInputTokenEnd)=\"removeField($event)\" />\n                </mat-chip-list>\n                <mat-autocomplete #reivewerAuto=\"matAutocomplete\"\n                  (optionSelected)=\"addEmployee($event, 'trackContacts')\">\n                  <mat-option *ngIf=\"fetchTagsStatus === 'fetching'\" i18n>Fetching users...</mat-option>\n                  <mat-option *ngIf=\"fetchTagsStatus === 'done' && !employeeList.length\" i18n>\n                    No user found. Please check the value entered.</mat-option>\n                  <mat-option *ngFor=\"let author of employeeList\" [value]=\"author\">\n                    {{ author.displayName }} | {{ author.mail }}\n                  </mat-option>\n                </mat-autocomplete>\n                <mat-error class=\"error-font\" *ngIf=\"showError('trackContacts')\" i18n>Reviewer is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n\n        </div>\n      </div>\n\n      <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('publisherDetails', 'show')\"\n        [ngClass]=\"{ disable: checkCondition('publisherDetails', 'disabled') }\">\n        <!--Show in popup--> <label>\n          <div class=\"margin-top-xs flex flex-middle\">\n            <b [ngClass]=\"{ required: checkCondition('publisherDetails', 'required') }\" i18n>Publishers</b>\n            <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('publishers')\">info\n            </mat-icon>\n          </div>\n          <span *ngIf=\"infoType === 'publishers'\">\n            Person who can publish this content\n          </span>\n        </label>\n        <div class=\"margin-top-xs\">\n          <mat-form-field appearance=\"outline\" class=\"margin-top-xs\" class=\"margin-top-xs\"\n            [ngClass]=\"{ 'mat-form-field-invalid': showError('publisherDetails') }\">\n            <mat-chip-list #publisherChipList aria-label=\"Publisher selection\">\n              <mat-chip *ngFor=\"let author of contentForm.controls.publisherDetails.value\" [selectable]=\"selectable\"\n                [removable]=\"removable\" (removed)=\"removeEmployee(author, 'publisherDetails')\">\n                {{ author.name }}\n                <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n              </mat-chip>\n              <input i18n-placeholder placeholder=\"Search by mail\" #publisherDetailsView\n                [formControl]=\"publisherDetailsCtrl\" [matChipInputFor]=\"publisherChipList\"\n                [matAutocomplete]=\"publisherAuto\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n                [matChipInputAddOnBlur]=\"false\" (matChipInputTokenEnd)=\"removeField($event)\" />\n            </mat-chip-list>\n            <mat-autocomplete #publisherAuto=\"matAutocomplete\"\n              (optionSelected)=\"addEmployee($event, 'publisherDetails')\">\n              <mat-option *ngIf=\"fetchTagsStatus === 'fetching'\" i18n>Fetching users...</mat-option>\n              <mat-option *ngIf=\"fetchTagsStatus === 'done' && !employeeList.length\" i18n>\n                No user found. Please check the value entered.</mat-option>\n              <mat-option *ngFor=\"let author of employeeList\" [value]=\"author\">\n                {{ author.displayName }} | {{ author.mail }}\n              </mat-option>\n            </mat-autocomplete>\n            <mat-error class=\"error-font\" *ngIf=\"showError('publisherDetails')\" i18n>Publisher is mandatory\n            </mat-error>\n          </mat-form-field>\n        </div>\n        <!--Show in popup-->\n      </div>\n\n      <div class=\"margin-right-l\">\n        <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('keywords', 'show')\"\n          [ngClass]=\"{ disable: checkCondition('keywords', 'disabled') }\">\n          <label>\n            <div class=\"margin-top-xs flex flex-middle\">\n              <b [ngClass]=\"{ required: checkCondition('keywords', 'required') }\" i18n>Keywords</b>\n              <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('keyword')\">info\n              </mat-icon>\n              <mat-icon class=\"float-right margin-left-xs cursor-pointer\" *ngIf=\"\n                      contentForm.controls.keywords.value &&\n                      contentForm.controls.keywords.value.length\n                    \" (click)=\"copyData('keyword')\">\n                file_copy\n              </mat-icon>\n            </div>\n            <span i18n *ngIf=\"infoType === 'keyword'\">Add relevant tags to your content. Press Enter after each\n              keyword.\n            </span>\n          </label>\n          <div class=\"margin-top-xs flex margin-right-xl\">\n            <mat-form-field class=\"keywords-chip-list margin-top-xs flex-grow80\" appearance=\"outline\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('keywords') }\">\n              <mat-chip-list #keywords aria-label=\"Keyword selection\">\n                <mat-chip *ngFor=\"let key of contentForm.controls.keywords.value\" [selectable]=\"selectable\"\n                  [removable]=\"removable\" (removed)=\"removeKeyword(key)\">\n                  {{ key }}\n                  <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                </mat-chip>\n                <input i18n-placeholder [formControl]=\"keywordsCtrl\" [matAutocomplete]=\"auto\"\n                  placeholder=\"Search Keywords\" #keywordsView [matChipInputFor]=\"keywords\"\n                  [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\" [matChipInputAddOnBlur]=\"false\"\n                  (matChipInputTokenEnd)=\"addKeyword($event)\" #keywordsSearch />\n              </mat-chip-list>\n            </mat-form-field>\n            <mat-autocomplete #auto=\"matAutocomplete\" autoActiveFirstOption\n              (optionSelected)=\"optionSelected($event.option.value); keywordsView.value = ''\">\n              <mat-option *ngIf=\"keywordsSearch.value\" [value]=\"keywordsSearch.value\">{{ keywordsSearch.value }}\n              </mat-option>\n              <mat-option *ngFor=\"let option of filteredOptions$ | async\" [value]=\"option\">{{ option }}\n              </mat-option>\n            </mat-autocomplete>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"margin-top-xs margin-left-xl margin-right-l flex-1\" *ngIf=\"checkCondition('learningMode', 'show')\"\n      [ngClass]=\"{ disable: checkCondition('learningMode', 'disabled') }\">\n      <label [ngClass]=\"{ required: checkCondition('learningMode', 'required') }\">\n        <b i18n>Mode</b>\n      </label>\n      <div class=\"margin-top-l\">\n        <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n          [ngClass]=\"{ 'mat-form-field-invalid': showError('learningMode') }\">\n          <mat-select formControlName=\"learningMode\" i18n-placeholder placeholder=\"--Select--\">\n            <mat-option *ngIf=\"!checkCondition('learningMode', 'required')\" i18n [value]=\"null\">None\n            </mat-option>\n            <mat-option *ngFor=\"let learningMode of ordinals.learningMode\" [value]=\"learningMode\">\n              {{ learningMode }}</mat-option>\n          </mat-select>\n          <mat-error *ngIf=\"showError('learningMode')\" i18n>Mode is mandatory </mat-error>\n        </mat-form-field>\n      </div>\n    </div>\n\n      <ng-template i18n>\n        Stakeholders\n      </ng-template>\n      <div class=\"margin-top-xl margin-right-l\">\n        <div class=\"\">\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('creatorContacts', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('creatorContacts', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Curators / Contacts</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('coAuthors')\">info\n                </mat-icon>\n              </div>\n              <span *ngIf=\"infoType === 'coAuthors'\">\n                Person responsible for the content\n              </span>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs\" class=\"margin-top-xs\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('creatorContacts') }\">\n                <mat-chip-list #creatorChipList aria-label=\"Creator selection\">\n                  <mat-chip *ngFor=\"let author of contentForm.controls.creatorContacts.value\" [selectable]=\"selectable\"\n                    [removable]=\"removable\" (removed)=\"removeEmployee(author, 'creatorContacts')\">\n                    {{ author.name }}\n                    <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                  </mat-chip>\n                  <input i18n-placeholder placeholder=\"Search by mail\" #creatorContactsView\n                    [formControl]=\"creatorContactsCtrl\" [matChipInputFor]=\"creatorChipList\"\n                    [matAutocomplete]=\"creatorAuto\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n                    [matChipInputAddOnBlur]=\"false\" (matChipInputTokenEnd)=\"removeField($event)\" />\n                </mat-chip-list>\n                <mat-autocomplete #creatorAuto=\"matAutocomplete\"\n                  (optionSelected)=\"addEmployee($event, 'creatorContacts')\">\n                  <mat-option *ngIf=\"fetchTagsStatus === 'fetching'\" i18n>Fetching users...</mat-option>\n                  <mat-option *ngIf=\"fetchTagsStatus === 'done' && !employeeList.length\" i18n>\n                    No user found. Please check the value entered.</mat-option>\n                  <mat-option *ngFor=\"let author of employeeList\" [value]=\"author\">\n                    {{ author.displayName }} | {{ author.mail }}\n                  </mat-option>\n                </mat-autocomplete>\n                <mat-error class=\"error-font\" *ngIf=\"showError('creatorContacts')\" i18n>Contributor is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n          <!--Show in popup -->\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('creatorDetails', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('creatorDetails', 'disabled') }\">\n            <label>\n              <div class=\"margin-top-xs flex flex-middle\">\n                <b i18n>Authors</b>\n                <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('authors')\">info\n                </mat-icon>\n              </div>\n              <span *ngIf=\"infoType === 'authors'\">\n                Authors who are creating the content\n              </span>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs\" class=\"margin-top-xs\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('creatorDetails') }\">\n                <mat-chip-list #creatorDetailsChipList aria-label=\"Original Author selection\">\n                  <mat-chip *ngFor=\"let author of contentForm.controls.creatorDetails.value\" [selectable]=\"selectable\"\n                    [removable]=\"removable\" (removed)=\"removeCreatorDetails(author)\">\n                    {{ author.name }}\n                    <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n                  </mat-chip>\n                  <input i18n-placeholder placeholder=\"Enter name\" #creatorDetailsView\n                    [formControl]=\"creatorDetailsCtrl\" [matChipInputFor]=\"creatorDetailsChipList\"\n                    [matAutocomplete]=\"originalAuthorsAuto\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n                    [matChipInputAddOnBlur]=\"false\" (matChipInputTokenEnd)=\"addCreatorDetails($event)\" />\n                </mat-chip-list>\n                <mat-autocomplete #originalAuthorsAuto=\"matAutocomplete\"\n                  (optionSelected)=\"addEmployee($event, 'creatorDetails')\">\n                  <mat-option *ngIf=\"fetchTagsStatus === 'fetching'\" i18n>Fetching users...</mat-option>\n                  <mat-option *ngIf=\"fetchTagsStatus === 'done' && !employeeList.length\" i18n>\n                    No user found. Please check the value entered.</mat-option>\n                  <mat-option *ngFor=\"let author of employeeList\" [value]=\"author\">\n                    {{ author.displayName }} | {{ author.mail }}\n                  </mat-option>\n                </mat-autocomplete>\n                <mat-error class=\"error-font\" *ngIf=\"showError('creatorDetails')\" i18n>Original Authors is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n          <!--Show in popup-->\n        </div>\n      </div>\n    </div>\n    <!--added end-->\n    <div class=\"margin-top-xl margin-right-l\">\n      <div class=\"grid\"></div>\n      <div class=\"flex flex-end margin-top-l margin-bottom-l margin-right-l\">\n        <button mat-raised-button type=\"button\" class=\"text-white ws-mat-primary-background text-white margin-right-m\"\n          (click)=\"sideNavBarOpened=false\">\n          <span class=\"text-white\" i18n>Cancel</span>\n        </button>\n        <button mat-raised-button type=\"button\" class=\"text-white ws-mat-primary-background text-white\"\n          (click)=\"data.emit('push'); isSubmitPressed = true\">\n          <span class=\"text-white\" i18n>\n            Save\n          </span>\n        </button>\n      </div>\n    </div>\n\n  </mat-sidenav>\n\n  <mat-sidenav-content class=\"sidenav-content\">\n    <div id=\"edit-meta\" class=\"margin-left-xl margin-top-l\">\n\n      <div class=\"margin-top-xl new-mobile margin-right-l\">\n\n\n        <div class=\"margin-top-s\">\n          <div class=\"margin-top-xs\" *ngIf=\"checkCondition('name', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('name', 'disabled') }\">\n            <p class=\"font-weight-bold margin-remove-bottom\"\n              i18n=\"Title label|Label which explains the user to enter title\"\n              [ngClass]=\"{ required: checkCondition('name', 'required') }\">\n              Title\n            </p>\n            <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('name') }\">\n              <input matInput #name formControlName=\"name\" maxlength=\"500\" i18n-placeholder\n                placeholder=\"Enter a Descriptive title\" [required]=\"checkCondition('name', 'required') ? true : null\" />\n              <mat-hint align=\"end\">{{ name.value.length }} / 500</mat-hint>\n              <mat-error *ngIf=\"showError('name')\" i18n=\"Name Error|Explains name is required\">\n                Title is mandatory\n              </mat-error>\n            </mat-form-field>\n          </div>\n        </div>\n        <div class=\"margin-top-s\">\n          <div *ngIf=\"checkCondition('description', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('description', 'disabled') }\">\n            <mat-label class=\"font-weight-bold\" i18n=\"Subtitle label|Label which explains the user to enter Subtitle\"\n              [ngClass]=\"{ required: checkCondition('description', 'required') }\" i18n>\n              Short/Card Description</mat-label>\n            <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('description') }\">\n              <textarea cdkTextareaAutosize name=\"description\" #description class=\"resize-none\"\n                [matTextareaAutosize]=\"true\" maxlength=\"2000\" matInput rows=\"3\" formControlName=\"description\"\n                i18n-placeholder placeholder=\"Description will appear on card\"\n                [required]=\"checkCondition('description', 'required') ? true : null\">\n            </textarea>\n              <mat-hint align=\"end\">{{ description.value.length }} / 2000</mat-hint>\n              <mat-error *ngIf=\"showError('description')\" i18n>Description is mandatory\n              </mat-error>\n            </mat-form-field>\n          </div>\n        </div>\n        <div class=\"margin-top-m flex justify-start\">\n          <h2> <b> Basic Settings </b>| <a (click)=\"sideNavBarOpened=true\" class=\"ws-mat-default-text cursor-pointer\">\n              Advanced\n              Settings </a></h2>\n        </div>\n\n        <div class=\"\">\n\n          <div class=\"flex flex-column\">\n            <div class=\"margin-top-xs margin-left-l\" *ngIf=\"checkCondition('appIcon', 'show')\"\n              [ngClass]=\"{ disable: checkCondition('appIcon', 'disabled') }\">\n              <label>\n                <div class=\"margin-top-xs flex flex-middle\"\n                  [ngClass]=\"{ required: checkCondition('appIcon', 'required') }\">\n                  <b i18n>Thumbnail</b>\n                  <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('appIcon')\">info\n                  </mat-icon>\n                </div>\n                <span i18n *ngIf=\"infoType === 'appIcon'\">\n                  Maximum file size - 1 MB\n                </span>\n              </label>\n              <div class=\"margin-top-xs\">\n                <img class=\"image max-width\" [ngClass]=\"{\n                      'image-border': showError('appIcon'),\n                      'ws-mat-warn-text': showError('appIcon')\n                    }\" height=\"150\" width=\"256\" [src]=\"contentForm.controls.appIcon.value | relativeUrl\"\n                  (error)=\"changeToDefaultImg($event)\" />\n                <div class=\"photo mat-elevation-z4 mat-app-background\" (click)=\"uploadThumbnail.click()\">\n                  <mat-icon class=\"photo-icon ws-mat-primary-text\">photo_camera</mat-icon>\n                  <input type=\"file\" #uploadThumbnail\n                    (change)=\"uploadAppIcon($event.target.files[0]); uploadThumbnail.value = null\"\n                    style=\"display: none;\" [accept]=\"imageTypes.toString()\" />\n                </div>\n              </div>\n            </div>\n\n            <div class=\"flex margin-left-l\">\n              <div style=\"width: 230px;\" class=\"flex flex-column  margin-right-m margin-top-m\">\n                <div class=\"margin-bottom-m\" *ngIf=\"checkCondition('expiryDate', 'show')\"\n                  [ngClass]=\"{ disable: checkCondition('expiryDate', 'disabled') }\">\n                  <mat-label class=\"font-weight-bold\" [ngClass]=\"{ required: checkCondition('expiryDate', 'required') }\"\n                    i18n=\"\n                        Content expiration date label|Label which explains the user to choose content\n                        expiration date\n                      \">\n                    Expires On</mat-label>\n                  <br />\n                  <mat-checkbox [checked]=\"canExpiry\" (change)=\"assignExpiryDate()\" i18n>Content can expire\n                  </mat-checkbox>\n                  <mat-form-field *ngIf=\"canExpiry\" appearance=\"outline\" class=\"margin-top-sm\"\n                    [ngClass]=\"{ 'mat-form-field-invalid': showError('expiryDate') }\">\n                    <input matInput formControlName=\"expiryDate\" [matDatepicker]=\"picker\" i18n-placeholder\n                      placeholder=\"Choose a date\" [required]=\"checkCondition('expiryDate', 'required') ? true : null\" />\n                    <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n                    <mat-datepicker #picker></mat-datepicker>\n                    <mat-error *ngIf=\"showError('expiryDate')\" i18n>\n                      Expiry Date is mandatory\n                    </mat-error>\n                  </mat-form-field>\n                </div>\n                <div *ngIf=\"checkCondition('duration', 'show')\"\n                  [ngClass]=\"{ disable: checkCondition('duration', 'disabled') }\">\n                  <p class=\"font-weight-bold margin-remove-bottom\"\n                    [ngClass]=\"{ required: checkCondition('duration', 'required') }\">\n                    <span i18n>Duration</span>\n                    <small i18n>(hh:mm:ss)</small>\n                  </p>\n                  <p class=\"not-disable\" *ngIf=\"\n                        checkCondition('duration', 'disabled') &&\n                        contentForm.controls.mimeType.value ===\n                          'application/vnd.ekstep.content-collection'\n                      \" i18n>\n                    Auto calculated from children\n                  </p>\n                  <p class=\"not-disable\" *ngIf=\"\n                        checkCondition('duration', 'disabled') &&\n                        ['application/x-mpegURL', 'audio/mpeg'].includes(\n                          contentForm.controls.mimeType.value\n                        )\n                      \" i18n>\n                    Auto calculated from duration of the file\n                  </p>\n                  <div class=\"flex\">\n                    <div class=\"flex\">\n                      <mat-form-field appearance=\"outline\" class=\"duration-width\"\n                        [ngClass]=\"{ 'mat-form-field-invalid': showError('duration') }\">\n                        <input matInput class=\"numberInput\" [(ngModel)]=\"hours\" [ngModelOptions]=\"{ standalone: true }\"\n                          (keyup)=\"timeToSeconds()\" type=\"number\" placeholder=\"00\" min=\"0\" step=\"1\" />\n                      </mat-form-field>\n                      <div class=\"margin-top-s padding-small\">:</div>\n                    </div>\n                    <div class=\"flex\">\n                      <mat-form-field appearance=\"outline\" class=\"duration-width\"\n                        [ngClass]=\"{ 'mat-form-field-invalid': showError('duration') }\">\n                        <input matInput class=\"numberInput\" [(ngModel)]=\"minutes\"\n                          [ngModelOptions]=\"{ standalone: true }\" (keyup)=\"timeToSeconds()\" type=\"number\"\n                          placeholder=\"00\" min=\"0\" max=\"59\" step=\"1\" />\n                      </mat-form-field>\n                      <div class=\"margin-top-s padding-small\">:</div>\n                    </div>\n                    <div>\n                      <mat-form-field appearance=\"outline\" class=\"duration-width\"\n                        [ngClass]=\"{ 'mat-form-field-invalid': showError('duration') }\">\n                        <input matInput class=\"numberInput\" [(ngModel)]=\"seconds\"\n                          [ngModelOptions]=\"{ standalone: true }\" (keyup)=\"timeToSeconds()\" type=\"number\"\n                          placeholder=\"00\" min=\"0\" max=\"59\" step=\"1\" />\n                        <mat-error *ngIf=\"showError('duration')\"\n                          i18n=\"Duration Error|Explains Duration is mandatory field\">Duration is mandatory\n                        </mat-error>\n                      </mat-form-field>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div class=\"flex flex-column margin-left-l\">\n\n            <div class=\"margin-top-s\" *ngIf=\"checkCondition('subTitle', 'show')\"\n              [ngClass]=\"{ disable: checkCondition('subTitle', 'disabled') }\">\n              <p class=\"font-weight-bold margin-remove-bottom\"\n                [ngClass]=\"{ required: checkCondition('subTitle', 'required') }\">\n                Subtitle\n              </p>\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('subTitle') }\">\n                <input matInput formControlName=\"subTitle\" #subTitle maxlength=\"1000\" i18n-placeholder\n                  placeholder=\"Enter subtitle here\" [required]=\"checkCondition('subTitle', 'required') ? true : null\" />\n                <mat-hint align=\"end\">{{ subTitle.value.length }} / 1000</mat-hint>\n                <mat-error *ngIf=\"showError('subTitle')\" i18n=\"Subtitle Error|Explains Subtitle is required\">\n                  Subtitle is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n\n            <div class=\"margin-top-s\" *ngIf=\"checkCondition('body', 'show')\"\n              [ngClass]=\"{ disable: checkCondition('body', 'disabled') }\">\n              <label>\n                <div class=\"margin-top-xs flex flex-middle\">\n                  <b i18n [ngClass]=\"{ required: checkCondition('body', 'required') }\">Content Body (Long Description)\n                  </b>\n                  <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('contentBody')\">info\n                  </mat-icon>\n                </div>\n                <span *ngIf=\"infoType === 'contentBody'\" i18n>\n                  HTML supported Editor in case you'd like to provide more descriptive details\n                </span>\n              </label>\n              <div class=\"margin-top-s margin-bottom-l\" *ngIf=\"contentForm && contentForm.controls\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('body') }\">\n                <ws-auth-plain-ckeditor [location]=\"location\" [id]=\"contentMeta.identifier\"\n                  [content]=\"contentForm.controls.body.value || ''\" (value)=\"updateContentService('body', $event)\">\n                </ws-auth-plain-ckeditor>\n                <!-- <textarea (value)=\"updateContentService('body', $event)\"></textarea> -->\n              </div>\n            </div>\n          </div>\n\n          <!-- <div class=\"flex flex-end margin-top-l margin-bottom-s margin-right-l\">\n            <button mat-raised-button type=\"button\"\n              class=\"text-white ws-mat-primary-background text-white margin-right-m\" (click)=\"data.emit('save')\">\n              <span class=\"text-white\" i18n>Save</span>\n            </button>\n            <button mat-raised-button type=\"button\" class=\"text-white ws-mat-primary-background text-white\"\n              (click)=\"formNext(1)\">\n              <span class=\"text-white\" i18n>Next</span>\n            </button>\n          </div> -->\n        </div>\n      </div>\n\n      <div class=\"margin-top-xl \">\n        <p class=\"mat-h5 margin-top-s margin-left-xl flex-1\" *ngIf=\"checkCondition('contentType', 'show')\">\n          * Provide meta details. Depending on the content type, some properties are enabled or\n          disabled.\n        </p>\n        <div class=\"margin-top-m \">\n          <div class=\"margin-top-s margin-left-xl flex-1\" *ngIf=\"checkCondition('contentType', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('contentType', 'disabled') }\">\n            <label [ngClass]=\"{ required: checkCondition('contentType', 'required') }\">\n              <b i18n>Content Category</b>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-xs\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('contentType') }\">\n                <mat-select formControlName=\"contentType\" i18n-placeholder placeholder=\"--Select--\"\n                  [required]=\"checkCondition('contentType', 'required')\">\n                  <mat-option [value]=\"'Resource'\">Resource</mat-option>\n                  <mat-option [value]=\"'Course'\">Course</mat-option>\n                  <mat-option [value]=\"'Knowledge Board'\"\n                    *ngIf=\"contentMeta && contentMeta.contentType == 'Knowledge Board'\">Knowledge Board</mat-option>\n                  <mat-option [value]=\"'Knowledge Artifact'\"\n                    *ngIf=\"contentMeta && contentMeta.contentType == 'Knowledge Artifact'\">Knowledge Artifact\n                  </mat-option>\n                </mat-select>\n              </mat-form-field>\n              <mat-error *ngIf=\"showError('contentType')\" i18n>Content Category is mandatory\n              </mat-error>\n            </div>\n          </div>\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('resourceType', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('resourceType', 'disabled') }\">\n            <label [ngClass]=\"{ required: checkCondition('resourceType', 'required') }\">\n              <b *ngIf=\"isSiemens\" i18n>Format</b>\n              <b *ngIf=\"!isSiemens\" i18n>Category Type</b>\n            </label>\n            <div class=\"margin-top-xs\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('resourceType') }\">\n                <mat-select formControlName=\"resourceType\" placeholder=\"--Select--\"\n                  [required]=\"checkCondition('resourceType', 'required')\">\n                  <mat-option *ngIf=\"!checkCondition('resourceType', 'required')\" i18n [value]=\"null\">None\n                  </mat-option>\n                  <mat-option *ngFor=\"let resource of ordinals.resourceType\" [value]=\"resource\">\n                    {{ resource }}</mat-option>\n                </mat-select>\n                <mat-error *ngIf=\"showError('resourceType')\" i18n>Category Type is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"\">\n        \n\n\n          <div class=\"margin-top-xs margin-left-xl flex-1\" *ngIf=\"checkCondition('sourceName', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('sourceName', 'disabled') }\">\n            <label [ngClass]=\"{ required: checkCondition('sourceName', 'required') }\">\n              <b i18n>Provider/Source</b>\n            </label>\n            <div class=\"margin-top-l\">\n              <mat-form-field appearance=\"outline\" class=\"margin-top-s\"\n                [ngClass]=\"{ 'mat-form-field-invalid': showError('sourceName') }\">\n                <mat-select formControlName=\"sourceName\" i18n-placeholder placeholder=\"--Select--\">\n                  <mat-option *ngIf=\"!checkCondition('sourceName', 'required')\" i18n [value]=\"null\">None</mat-option>\n                  <mat-option *ngFor=\"let sourceName of ordinals.sourceName\" [value]=\"sourceName\">\n                    {{ sourceName }}</mat-option>\n                </mat-select>\n                <mat-error *ngIf=\"showError('sourceName')\" i18n>Source is mandatory </mat-error>\n              </mat-form-field>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"\">\n          <div class=\"margin-top-m margin-left-xl flex-1\" *ngIf=\"checkCondition('catalogPaths', 'show')\"\n            [ngClass]=\"{ disable: checkCondition('catalogPaths', 'disabled') }\">\n            <!-- <label> -->\n            <div class=\"margin-top-s flex flex-middle\">\n              <b [ngClass]=\"{ required: checkCondition('catalogPaths', 'required') }\" i18n>Catalog</b>\n              <mat-icon class=\"ws-mat-primary-text margin-left-xs pointer\" (click)=\"showInfo('catalogPaths')\">info\n              </mat-icon>\n              <button mat-button (click)=\"openCatalogSelector()\"\n                class=\"ws-mat-primary-text font-weight-500 flex flex-middle cursor-pointer\">\n                <mat-icon>add</mat-icon>\n                <span i18n>\n                  UPDATE\n                </span>\n              </button>\n            </div>\n            <span i18n *ngIf=\"infoType === 'catalogPaths'\">\n              Select the tags for placement of your content in the catalog\n            </span>\n            <!-- </label> -->\n            <div class=\"margin-top-l flex margin-right-xl\"\n              [ngClass]=\"{ 'mat-form-field-invalid': showError('catalogPaths') }\">\n              <mat-form-field *ngIf=\"(contentForm.controls.catalogPaths.value || []).length > 0\"\n                class=\"catalogwords-chip-list margin-top-xs flex-grow80\" appearance=\"outline\">\n                <mat-chip-list #catalogs *ngFor=\"\n                      let catalog of contentForm.controls.catalogPaths.value.slice(\n                        0,\n                        showMoreGlance ? undefined : 5\n                      );\n                      let i = index\n                    \" i18n-aria-label aria-label=\"Catalog selection\">\n                  <mat-chip [selectable]=\"false\" [removable]=\"false\">\n                    {{ catalog }}\n                  </mat-chip>\n                </mat-chip-list>\n                <button *ngIf=\"(contentForm.controls.catalogPaths.value || []).length > 5\" mat-button\n                  (click)=\"showMoreGlance = !showMoreGlance\">\n                  <mat-icon>{{ !showMoreGlance ? 'arrow_drop_down' : 'arrow_drop_up' }}</mat-icon>\n                  <ng-container i18n *ngIf=\"!showMoreGlance\">Show More</ng-container>\n                  <ng-container i18n *ngIf=\"showMoreGlance\">Show Less</ng-container>\n                </button>\n                <mat-error *ngIf=\"showError('catalogPaths')\" i18n>Catalog is mandatory\n                </mat-error>\n              </mat-form-field>\n            </div>\n            <p i18n\n              *ngIf=\"!(contentForm.controls.catalogPaths && contentForm.controls.catalogPaths.value &&  contentForm.controls.catalogPaths.value.length)\">\n              0 Catalog Selected\n            </p>\n          </div>\n        </div>\n        <!-- <div class=\"flex flex-end margin-top-l margin-bottom-l margin-right-l\">\n            <button mat-raised-button type=\"button\"\n              class=\"text-white ws-mat-primary-background text-white margin-right-m\" (click)=\"data.emit('save')\">\n              <span class=\"text-white\" i18n>Save</span>\n            </button>\n            <button mat-raised-button type=\"button\" class=\"text-white ws-mat-primary-background text-white\"\n              (click)=\"formNext(2)\">\n              <span class=\"text-white\" i18n>Next</span>\n            </button>\n          </div> -->\n      </div>\n\n      <!-- <div class=\"margin-top-xl margin-right-l\">\n        <div class=\"grid\"></div>\n        <div class=\"flex flex-end margin-top-l margin-bottom-l margin-right-l\">\n          <button mat-raised-button type=\"button\" class=\"text-white ws-mat-primary-background text-white margin-right-m\"\n            (click)=\"data.emit('save')\">\n            <span class=\"text-white\" i18n>Save</span>\n          </button>\n          <button mat-raised-button type=\"button\" class=\"text-white ws-mat-primary-background text-white\"\n            (click)=\"data.emit('push'); isSubmitPressed = true\">\n            <span class=\"text-white\" i18n>\n              Done\n            </span>\n          </button>\n        </div>\n      </div> -->\n\n\n\n\n\n\n\n    </div>\n  </mat-sidenav-content>\n</form>";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.html":
  /*!**************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.html ***!
    \**************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditorBaseBaseComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<!-- <ws-auth-editor-action-buttons (action)=\"action($event)\" [buttonConfig]=\"actionButton\"></ws-auth-editor-action-buttons>\n<ws-auth-editor-steps [steps]=\"stepper\" [currentStep]=\"currentStep\" (change)=\"currentStep = $event\">\n</ws-auth-editor-steps> -->\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.html":
  /*!******************************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.html ***!
    \******************************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditorEditMetaV2EditMetaV2ComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<p>edit-meta-v2 works!</p>\n";

    /***/
  },

  /***/"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.html":
  /*!***************************************************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.html ***!
    \***************************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function node_modulesRawLoaderDistCjsJsProjectWsAuthorSrcLibRoutingModulesEditorSharedComponentsPlainCkeditorPlainCkeditorComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "<ckeditor #editor [config]=\"config\" [(ngModel)]=\"html\" (change)=\"onContentChanged()\">\n  <ckbutton [name]=\"'uploadImage'\" [command]=\"'uploadImage'\" (click)=\"addImageUploadBtn()\"\n    [icon]=\"'/assets/authoring/ckeditor/plugins/icons.png'\" [label]=\"imageName\"\n    [toolbar]=\"'insert'\">\n  </ckbutton>\n  <ckbutton [name]=\"'uploadFile'\" [command]=\"'uploadFile'\" (click)=\"addFileUploadBtn()\"\n    [icon]=\"'/assets/authoring/ckeditor/plugins/icons.png'\" [label]=\"fileName\"\n    [toolbar]=\"'insert'\">\n  </ckbutton>\n  <ckbutton [name]=\"'Blank'\" [command]=\"'Blank'\" (click)=\"addBlankBtn()\"\n    [icon]=\"'/assets/authoring/ckeditor/plugins/icons.png'\" [label]=\"blankName\"\n    [toolbar]=\"'insert'\">\n  </ckbutton>\n</ckeditor>\n\n<span [hidden]=\"true\" #uploadFile i18n>Upload File</span>\n<span [hidden]=\"true\" #uploadImage i18n>Upload Image</span>\n<span [hidden]=\"true\" #addBlank i18n>Add Blank</span>\n";

    /***/
  },

  /***/"./node_modules/webpack/buildin/amd-define.js":
  /*!***************************************!*\
    !*** (webpack)/buildin/amd-define.js ***!
    \***************************************/
  /*! no static exports found */
  /***/
  function node_modulesWebpackBuildinAmdDefineJs(module, exports) {
    module.exports = function () {
      throw new Error("define cannot be used indirect");
    };

    /***/
  },

  /***/"./project/ws/author/src/lib/modules/viewer/viewer-routing.module.ts":
  /*!***************************************************************************!*\
    !*** ./project/ws/author/src/lib/modules/viewer/viewer-routing.module.ts ***!
    \***************************************************************************/
  /*! exports provided: ViewerRoutingModule */
  /***/
  function projectWsAuthorSrcLibModulesViewerViewerRoutingModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "ViewerRoutingModule", function () {
      return ViewerRoutingModule;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/router */"./node_modules/@angular/router/fesm2015/router.js");
    /* harmony import */
    var _viewer_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./viewer.component */"./project/ws/author/src/lib/modules/viewer/viewer.component.ts");
    var routes = [{
      path: 'viewer',
      component: _viewer_component__WEBPACK_IMPORTED_MODULE_3__["ViewerComponent"]
    }];
    var ViewerRoutingModule = /*#__PURE__*/_createClass(function ViewerRoutingModule() {
      _classCallCheck(this, ViewerRoutingModule);
    });
    ViewerRoutingModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"].forChild(routes)],
      exports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"]]
    })], ViewerRoutingModule);

    /***/
  },

  /***/"./project/ws/author/src/lib/modules/viewer/viewer.component.scss":
  /*!************************************************************************!*\
    !*** ./project/ws/author/src/lib/modules/viewer/viewer.component.scss ***!
    \************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibModulesViewerViewerComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = ".font-size-m {\n  font-size: 16px;\n}\n\n.iframe {\n  height: calc(100vh - 70px);\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3NvbmFzaGFqdS9WaWRlb3Mvc3BoZXJlLW1vYmlsZS9wcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL21vZHVsZXMvdmlld2VyL3ZpZXdlci5jb21wb25lbnQuc2NzcyIsInByb2plY3Qvd3MvYXV0aG9yL3NyYy9saWIvbW9kdWxlcy92aWV3ZXIvdmlld2VyLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsZUFBQTtBQ0NGOztBREVBO0VBQ0UsMEJBQUE7QUNDRiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL21vZHVsZXMvdmlld2VyL3ZpZXdlci5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5mb250LXNpemUtbSB7XG4gIGZvbnQtc2l6ZTogMTZweDtcbn1cblxuLmlmcmFtZSB7XG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDcwcHgpO1xufVxuIiwiLmZvbnQtc2l6ZS1tIHtcbiAgZm9udC1zaXplOiAxNnB4O1xufVxuXG4uaWZyYW1lIHtcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNzBweCk7XG59Il19 */";

    /***/
  },

  /***/"./project/ws/author/src/lib/modules/viewer/viewer.component.ts":
  /*!**********************************************************************!*\
    !*** ./project/ws/author/src/lib/modules/viewer/viewer.component.ts ***!
    \**********************************************************************/
  /*! exports provided: ViewerComponent */
  /***/
  function projectWsAuthorSrcLibModulesViewerViewerComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "ViewerComponent", function () {
      return ViewerComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/services/access-control.service */"./project/ws/author/src/lib/modules/shared/services/access-control.service.ts");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    var ViewerComponent = /*#__PURE__*/function () {
      // = {
      //   value: 'desktop',
      //   viewValue: this.desktop
      //     ? this.desktop.nativeElement.value ? this.desktop.nativeElement.value : 'Desktop'
      //     : 'Desktop',
      //   height: '950px',
      //   width: '1280px',
      // }
      function ViewerComponent(accessControlSvc) {
        _classCallCheck(this, ViewerComponent);
        this.accessControlSvc = accessControlSvc;
        this.mobile = null;
        this.tab = null;
        this.desktop = null;
        this.identifier = null;
        this.mimeTypeRoute = null;
        this.iframeUrl = "author/toc/".concat(this.identifier, "/overview");
        this.previewDevices = [{
          value: 'mobile',
          viewValue: this.mobile ? this.mobile.nativeElement.value : '',
          height: '812px',
          width: '375px'
        }, {
          value: 'tab',
          viewValue: this.tab ? this.tab.nativeElement.value : '',
          height: '1024px',
          width: '768px'
        }, {
          value: 'desktop',
          viewValue: this.desktop ? this.desktop.nativeElement.value ? this.desktop.nativeElement.value : 'Desktop' : 'Desktop',
          height: '950px',
          width: '1400px'
        }];
        this.selected = this.previewDevices[2];
      }
      _createClass(ViewerComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          if (this.accessControlSvc.authoringConfig.newDesign) {
            if (this.mimeTypeRoute === 'channel') {
              this.iframeUrl = "author/viewer/channel/".concat(this.identifier);
            } else {
              this.iframeUrl = "author/toc/".concat(this.identifier, "/overview");
            }
          } else {
            this.iframeUrl = "/viewer/".concat(this.mimeTypeRoute, "/").concat(this.identifier, "?preview=true");
          }
        }
      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.previewDevices = [{
            value: 'mobile',
            viewValue: this.mobile ? this.mobile.nativeElement.value : '',
            height: '812px',
            width: '375px'
          }, {
            value: 'tab',
            viewValue: this.tab ? this.tab.nativeElement.value : '',
            height: '1024px',
            width: '768px'
          }, {
            value: 'desktop',
            viewValue: this.desktop ? this.desktop.nativeElement.value ? this.desktop.nativeElement.value : 'Desktop' : 'Desktop',
            height: '950px',
            width: '1400px'
          }];
          this.selected = this.previewDevices[2];
          // = {
          //   value: 'desktop',
          //   viewValue: this.desktop
          //     ? this.desktop.nativeElement.value ? this.desktop.nativeElement.value : 'Desktop'
          //     : 'Desktop',
          //   height: '950px',
          //   width: '1280px',
          // }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {}
      }]);
      return ViewerComponent;
    }();
    ViewerComponent.ctorParameters = function () {
      return [{
        type: _ws_author_src_lib_modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_1__["AccessControlService"]
      }];
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('mobile', {
      "static": true
    })], ViewerComponent.prototype, "mobile", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('tab', {
      "static": true
    })], ViewerComponent.prototype, "tab", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('desktop', {
      "static": true
    })], ViewerComponent.prototype, "desktop", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], ViewerComponent.prototype, "identifier", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], ViewerComponent.prototype, "mimeTypeRoute", void 0);
    ViewerComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"])({
      selector: 'ws-auth-viewer',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./viewer.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/modules/viewer/viewer.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./viewer.component.scss */"./project/ws/author/src/lib/modules/viewer/viewer.component.scss"))["default"]]
    })], ViewerComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/modules/viewer/viewer.module.ts":
  /*!*******************************************************************!*\
    !*** ./project/ws/author/src/lib/modules/viewer/viewer.module.ts ***!
    \*******************************************************************/
  /*! exports provided: AuthViewerModule */
  /***/
  function projectWsAuthorSrcLibModulesViewerViewerModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AuthViewerModule", function () {
      return AuthViewerModule;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/common */"./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */
    var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/forms */"./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */
    var _angular_material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @angular/material */"./node_modules/@angular/material/esm2015/material.js");
    /* harmony import */
    var _viewer_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./viewer.component */"./project/ws/author/src/lib/modules/viewer/viewer.component.ts");
    /* harmony import */
    var _viewer_routing_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ./viewer-routing.module */"./project/ws/author/src/lib/modules/viewer/viewer-routing.module.ts");
    /* harmony import */
    var _ws_widget_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @ws-widget/utils */"./library/ws-widget/utils/src/public-api.ts");
    var AuthViewerModule = /*#__PURE__*/_createClass(function AuthViewerModule() {
      _classCallCheck(this, AuthViewerModule);
    });
    AuthViewerModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      declarations: [_viewer_component__WEBPACK_IMPORTED_MODULE_5__["ViewerComponent"]],
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormsModule"], _angular_material__WEBPACK_IMPORTED_MODULE_4__["MatFormFieldModule"], _angular_material__WEBPACK_IMPORTED_MODULE_4__["MatToolbarModule"], _angular_material__WEBPACK_IMPORTED_MODULE_4__["MatSelectModule"], _viewer_routing_module__WEBPACK_IMPORTED_MODULE_6__["ViewerRoutingModule"], _ws_widget_utils__WEBPACK_IMPORTED_MODULE_7__["PipeSafeSanitizerModule"]],
      exports: [_viewer_component__WEBPACK_IMPORTED_MODULE_5__["ViewerComponent"]]
    })], AuthViewerModule);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.scss":
  /*!**************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.scss ***!
    \**************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorComponentsEditorEditorComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3IvY29tcG9uZW50cy9lZGl0b3IvZWRpdG9yLmNvbXBvbmVudC5zY3NzIn0= */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.ts":
  /*!************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.ts ***!
    \************************************************************************************************/
  /*! exports provided: EditorComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorComponentsEditorEditorComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditorComponent", function () {
      return EditorComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _ws_author_src_lib_services_init_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @ws/author/src/lib/services/init.service */"./project/ws/author/src/lib/services/init.service.ts");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/material/snack-bar */"./node_modules/@angular/material/esm2015/snack-bar.js");
    /* harmony import */
    var _angular_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @angular/router */"./node_modules/@angular/router/fesm2015/router.js");
    /* harmony import */
    var _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @ws/author/src/lib/constants/constant */"./project/ws/author/src/lib/constants/constant.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @ws/author/src/lib/constants/notificationMessage */"./project/ws/author/src/lib/constants/notificationMessage.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/components/notification/notification.component */"./project/ws/author/src/lib/modules/shared/components/notification/notification.component.ts");
    /* harmony import */
    var _ws_author_src_lib_routing_modules_editor_services_editor_content_v2_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @ws/author/src/lib/routing/modules/editor/services/editor-content-v2.service */"./project/ws/author/src/lib/routing/modules/editor/services/editor-content-v2.service.ts");
    /* harmony import */
    var _ws_author_src_lib_routing_modules_editor_services_editor_content_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! @ws/author/src/lib/routing/modules/editor/services/editor-content.service */"./project/ws/author/src/lib/routing/modules/editor/services/editor-content.service.ts");
    /* harmony import */
    var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! rxjs/operators */"./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */
    var _angular_material__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! @angular/material */"./node_modules/@angular/material/esm2015/material.js");
    /* harmony import */
    var _ws_widget_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! @ws-widget/utils */"./library/ws-widget/utils/src/public-api.ts");
    /* harmony import */
    var _modules_shared_components_status_track_status_track_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! ../../../../../modules/shared/components/status-track/status-track.component */"./project/ws/author/src/lib/modules/shared/components/status-track/status-track.component.ts");
    var EditorComponent = /*#__PURE__*/function () {
      function EditorComponent(dialog, valueSvc, router, route, contentService, snackBar, contentV2Service, initSvc) {
        _classCallCheck(this, EditorComponent);
        this.dialog = dialog;
        this.valueSvc = valueSvc;
        this.router = router;
        this.route = route;
        this.contentService = contentService;
        this.snackBar = snackBar;
        this.contentV2Service = contentV2Service;
        this.initSvc = initSvc;
        this.isMobile = false;
        this.routerEventSubscription = this.route.events.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(function (event) {
          return event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_4__["NavigationStart"];
        })).subscribe(function (event) {
          if (event.navigationTrigger === 'popstate') {
            if (event.url.indexOf('author/editor') > -1) {
              window.history.go(-1);
            }
          }
        });
      }
      _createClass(EditorComponent, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.contentService.reset();
          if (this.routerSubscription) {
            this.routerSubscription.unsubscribe();
          }
          if (this.routerEventSubscription) {
            this.routerEventSubscription.unsubscribe();
          }
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var _this2 = this;
            var hasAccess;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  this.valueSvc.isXSmall$.subscribe(function (isMobile) {
                    return _this2.isMobile = isMobile;
                  });
                  hasAccess = false;
                  _context.next = 4;
                  return this.router.data.subscribe(function (data) {
                    if (data.contents && data.contents.length) {
                      var contents = data.contents;
                      hasAccess = _this2.contentService.hasAccess(contents[0].content);
                      if (['Deleted', 'Unpublished', 'Expired', 'MarkedForDeletion'].includes(contents[0].content.status)) {
                        _this2.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                          data: {
                            type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_6__["Notify"].DELETED
                          },
                          duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_5__["NOTIFICATION_TIME"] * 1000
                        });
                        _this2.route.navigateByUrl('/author/home');
                        return;
                      }
                      if (!hasAccess || contents[0].content.isMetaEditingDisabled) {
                        _this2.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                          data: {
                            type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_6__["Notify"].NO_ACCESS
                          },
                          duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_5__["NOTIFICATION_TIME"] * 1000
                        });
                        _this2.route.navigateByUrl('/author/home');
                        return;
                      }
                      contents.map(function (v) {
                        if (_this2.contentService.hasAccess(v.content) && !v.content.isMetaEditingDisabled && !['Deleted', 'Unpublished', 'Expired'].includes(v.content.status)) {
                          _this2.contentService.setOriginalMeta(v.content);
                          _this2.contentV2Service.contentMetaMap.set(v.content.identifier, v.content);
                          _this2.contentV2Service.contentDataMap.set(v.content.identifier, v.data);
                          _this2.contentV2Service.parentContent.push(v.content.identifier);
                        }
                      });
                      if (['InReview', 'Reviewed', 'QualityReview'].includes(contents[0].content.status) && _this2.initSvc.authAdditionalConfig.allowActionHistory) {
                        _this2.dialog.open(_modules_shared_components_status_track_status_track_component__WEBPACK_IMPORTED_MODULE_13__["StatusTrackComponent"], {
                          width: _this2.isMobile ? '90vw' : '800px',
                          height: 'auto',
                          data: contents[0].content
                        });
                      }
                      _this2.contentV2Service.changeActiveCont.next(contents[0].content.identifier);
                      _this2.contentV2Service.changeActiveParentCont.next(contents[0].content.identifier);
                      _this2.contentService.changeActiveCont.next(contents[0].content.identifier);
                      _this2.contentService.currentContent = contents[0].content.identifier;
                      _this2.contentService.parentContent = contents[0].content.identifier;
                      if (['Course', 'Collection', 'Learning Path'].indexOf(contents[0].content.contentType) > -1 && !contents[0].content.isExternal) {
                        _this2.route.navigate(['collection'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.contentType === 'Channel') {
                        _this2.route.navigate(['channel'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.contentType === 'Knowledge Board') {
                        _this2.route.navigate(['knowledge-board'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.contentType === 'Knowledge Artifact') {
                        _this2.route.navigate(['kartifact-pa'], {
                          relativeTo: _this2.router
                        });
                      } else if (['application/pdf', 'application/x-mpegURL', 'audio/mpeg'].indexOf(contents[0].content.mimeType) > -1) {
                        _this2.route.navigate(['upload'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.mimeType === 'application/html' && !contents[0].content.isExternal) {
                        _this2.route.navigate(['upload'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.mimeType === 'application/iap-assessment') {
                        _this2.route.navigate(['iap-assessment'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.mimeType === 'application/quiz' && contents[0].content.categoryType === 'Quiz') {
                        _this2.route.navigate(['quiz'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.mimeType === 'application/quiz' && contents[0].content.categoryType === 'Assessment') {
                        _this2.route.navigate(['assessment'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.mimeType === 'application/web-module') {
                        _this2.route.navigate(['web-module'], {
                          relativeTo: _this2.router
                        });
                      } else if (contents[0].content.mimeType === 'application/class-diagram') {
                        _this2.route.navigate(['class-diagram'], {
                          relativeTo: _this2.router
                        });
                      } else {
                        _this2.route.navigate(['curate'], {
                          relativeTo: _this2.router
                        });
                      }
                    }
                  });
                case 4:
                  this.routerSubscription = _context.sent;
                case 5:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
        }
      }]);
      return EditorComponent;
    }();
    EditorComponent.ctorParameters = function () {
      return [{
        type: _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatDialog"]
      }, {
        type: _ws_widget_utils__WEBPACK_IMPORTED_MODULE_12__["ValueService"]
      }, {
        type: _angular_router__WEBPACK_IMPORTED_MODULE_4__["ActivatedRoute"]
      }, {
        type: _angular_router__WEBPACK_IMPORTED_MODULE_4__["Router"]
      }, {
        type: _ws_author_src_lib_routing_modules_editor_services_editor_content_service__WEBPACK_IMPORTED_MODULE_9__["EditorContentService"]
      }, {
        type: _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_3__["MatSnackBar"]
      }, {
        type: _ws_author_src_lib_routing_modules_editor_services_editor_content_v2_service__WEBPACK_IMPORTED_MODULE_8__["EditorContentV2Service"]
      }, {
        type: _ws_author_src_lib_services_init_service__WEBPACK_IMPORTED_MODULE_1__["AuthInitService"]
      }];
    };
    EditorComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"])({
      selector: 'ws-auth-root-editor',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./editor.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.html"))["default"],
      providers: [_ws_author_src_lib_routing_modules_editor_services_editor_content_service__WEBPACK_IMPORTED_MODULE_9__["EditorContentService"], _ws_author_src_lib_routing_modules_editor_services_editor_content_v2_service__WEBPACK_IMPORTED_MODULE_8__["EditorContentV2Service"]],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./editor.component.scss */"./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.scss"))["default"]]
    })], EditorComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/editor-routing.module.ts":
  /*!***********************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/editor-routing.module.ts ***!
    \***********************************************************************************/
  /*! exports provided: EditorRoutingModule */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorEditorRoutingModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditorRoutingModule", function () {
      return EditorRoutingModule;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/router */"./node_modules/@angular/router/fesm2015/router.js");
    /* harmony import */
    var _ws_author_src_lib_services_init_resolve_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @ws/author/src/lib/services/init-resolve.service */"./project/ws/author/src/lib/services/init-resolve.service.ts");
    /* harmony import */
    var _components_editor_editor_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./components/editor/editor.component */"./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.ts");
    var routes = [{
      path: '',
      component: _components_editor_editor_component__WEBPACK_IMPORTED_MODULE_4__["EditorComponent"],
      children: [{
        path: 'curate',
        loadChildren: function loadChildren() {
          return __webpack_require__.e( /*! import() | routing-modules-curate-curate-module */"default~routing-modules-collection-collection-module~routing-modules-curate-curate-module").then(__webpack_require__.bind(null, /*! ./routing/modules/curate/curate.module */"./project/ws/author/src/lib/routing/modules/editor/routing/modules/curate/curate.module.ts")).then(function (u) {
            return u.CurateModule;
          });
        }
      }, {
        path: 'upload',
        loadChildren: function loadChildren() {
          return __webpack_require__.e( /*! import() | routing-modules-upload-upload-module */"default~routing-modules-collection-collection-module~routing-modules-upload-upload-module").then(__webpack_require__.bind(null, /*! ./routing/modules/upload/upload.module */"./project/ws/author/src/lib/routing/modules/editor/routing/modules/upload/upload.module.ts")).then(function (u) {
            return u.UploadModule;
          });
        }
      }, {
        path: 'collection',
        data: {
          load: ['collection', 'create']
        },
        resolve: {
          script: _ws_author_src_lib_services_init_resolve_service__WEBPACK_IMPORTED_MODULE_3__["InitResolver"]
        },
        loadChildren: function loadChildren() {
          return Promise.all( /*! import() | routing-modules-collection-collection-module */[__webpack_require__.e("default~routing-modules-collection-collection-module~routing-modules-quiz-quiz-module"), __webpack_require__.e("default~routing-modules-collection-collection-module~routing-modules-web-page-web-page-module"), __webpack_require__.e("default~routing-modules-collection-collection-module~routing-modules-curate-curate-module"), __webpack_require__.e("default~routing-modules-collection-collection-module~routing-modules-upload-upload-module"), __webpack_require__.e("routing-modules-collection-collection-module")]).then(__webpack_require__.bind(null, /*! ./routing/modules/collection/collection.module */"./project/ws/author/src/lib/routing/modules/editor/routing/modules/collection/collection.module.ts")).then(function (u) {
            return u.CollectionModule;
          });
        }
      }, {
        path: 'quiz',
        loadChildren: function loadChildren() {
          return __webpack_require__.e( /*! import() | routing-modules-quiz-quiz-module */"default~routing-modules-collection-collection-module~routing-modules-quiz-quiz-module").then(__webpack_require__.bind(null, /*! ./routing/modules/quiz/quiz.module */"./project/ws/author/src/lib/routing/modules/editor/routing/modules/quiz/quiz.module.ts")).then(function (u) {
            return u.QuizModule;
          });
        }
      }, {
        path: 'assessment',
        loadChildren: function loadChildren() {
          return __webpack_require__.e( /*! import() | routing-modules-quiz-quiz-module */"default~routing-modules-collection-collection-module~routing-modules-quiz-quiz-module").then(__webpack_require__.bind(null, /*! ./routing/modules/quiz/quiz.module */"./project/ws/author/src/lib/routing/modules/editor/routing/modules/quiz/quiz.module.ts")).then(function (u) {
            return u.QuizModule;
          });
        }
      }, {
        path: 'web-module',
        loadChildren: function loadChildren() {
          return __webpack_require__.e( /*! import() | routing-modules-web-page-web-page-module */"default~routing-modules-collection-collection-module~routing-modules-web-page-web-page-module").then(__webpack_require__.bind(null, /*! ./routing/modules/web-page/web-page.module */"./project/ws/author/src/lib/routing/modules/editor/routing/modules/web-page/web-page.module.ts")).then(function (u) {
            return u.WebPageModule;
          });
        }
      }]
    }];
    var EditorRoutingModule = /*#__PURE__*/_createClass(function EditorRoutingModule() {
      _classCallCheck(this, EditorRoutingModule);
    });
    EditorRoutingModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"].forChild(routes)],
      exports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"]]
    })], EditorRoutingModule);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/editor.module.ts":
  /*!***************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/editor.module.ts ***!
    \***************************************************************************/
  /*! exports provided: EditorModule */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorEditorModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditorModule", function () {
      return EditorModule;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _services_create_content_resolver_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./services/create-content-resolver.service */"./project/ws/author/src/lib/routing/modules/editor/services/create-content-resolver.service.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_viewer_viewer_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @ws/author/src/lib/modules/viewer/viewer.module */"./project/ws/author/src/lib/modules/viewer/viewer.module.ts");
    /* harmony import */
    var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/common */"./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _services_editor_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./services/editor.service */"./project/ws/author/src/lib/routing/modules/editor/services/editor.service.ts");
    /* harmony import */
    var _components_editor_editor_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ./components/editor/editor.component */"./project/ws/author/src/lib/routing/modules/editor/components/editor/editor.component.ts");
    /* harmony import */
    var _editor_routing_module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! ./editor-routing.module */"./project/ws/author/src/lib/routing/modules/editor/editor-routing.module.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_shared_module__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/shared.module */"./project/ws/author/src/lib/modules/shared/shared.module.ts");
    /* harmony import */
    var _shared_shared_module__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! ./shared/shared.module */"./project/ws/author/src/lib/routing/modules/editor/shared/shared.module.ts");
    var EditorModule = /*#__PURE__*/_createClass(function EditorModule() {
      _classCallCheck(this, EditorModule);
    });
    EditorModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__["NgModule"])({
      declarations: [_components_editor_editor_component__WEBPACK_IMPORTED_MODULE_6__["EditorComponent"]],
      imports: [_ws_author_src_lib_modules_viewer_viewer_module__WEBPACK_IMPORTED_MODULE_2__["AuthViewerModule"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _editor_routing_module__WEBPACK_IMPORTED_MODULE_7__["EditorRoutingModule"], _shared_shared_module__WEBPACK_IMPORTED_MODULE_9__["EditorSharedModule"], _ws_author_src_lib_modules_shared_shared_module__WEBPACK_IMPORTED_MODULE_8__["SharedModule"]],
      providers: [_services_editor_service__WEBPACK_IMPORTED_MODULE_5__["EditorService"], _services_create_content_resolver_service__WEBPACK_IMPORTED_MODULE_1__["CreateContentResolverService"]]
    })], EditorModule);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/services/create-content-resolver.service.ts":
  /*!******************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/services/create-content-resolver.service.ts ***!
    \******************************************************************************************************/
  /*! exports provided: CreateContentResolverService */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorServicesCreateContentResolverServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "CreateContentResolverService", function () {
      return CreateContentResolverService;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _editor_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./editor.service */"./project/ws/author/src/lib/routing/modules/editor/services/editor.service.ts");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/router */"./node_modules/@angular/router/fesm2015/router.js");
    /* harmony import */
    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! rxjs */"./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */
    var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! rxjs/operators */"./node_modules/rxjs/_esm2015/operators/index.js");
    var CreateContentResolverService = /*#__PURE__*/function () {
      function CreateContentResolverService(editorService, router) {
        _classCallCheck(this, CreateContentResolverService);
        this.editorService = editorService;
        this.router = router;
      }
      _createClass(CreateContentResolverService, [{
        key: "resolve",
        value: function resolve(route) {
          var _this3 = this;
          var meta = {
            mimeType: 'application/vnd.ekstep.content-collection',
            contentType: 'Knowledge Artifact'
          };
          var id = route.params['id'] || route.parent && route.parent.params.id;
          return id ? Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])(null) : this.editorService.create(meta).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["catchError"])(function (v) {
            _this3.router.navigateByUrl('/error-somethings-wrong');
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])(v);
          }));
        }
      }]);
      return CreateContentResolverService;
    }();
    CreateContentResolverService.ctorParameters = function () {
      return [{
        type: _editor_service__WEBPACK_IMPORTED_MODULE_1__["EditorService"]
      }, {
        type: _angular_router__WEBPACK_IMPORTED_MODULE_3__["Router"]
      }];
    };
    CreateContentResolverService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"])({
      providedIn: 'root'
    })], CreateContentResolverService);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/services/editor-content-v2.service.ts":
  /*!************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/services/editor-content-v2.service.ts ***!
    \************************************************************************************************/
  /*! exports provided: EditorContentV2Service */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorServicesEditorContentV2ServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditorContentV2Service", function () {
      return EditorContentV2Service;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! rxjs/internal/BehaviorSubject */"./node_modules/rxjs/internal/BehaviorSubject.js");
    /* harmony import */
    var rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2__);
    var EditorContentV2Service = /*#__PURE__*/_createClass(function EditorContentV2Service() {
      _classCallCheck(this, EditorContentV2Service);
      this.contentMetaMap = new Map();
      this.updatedHierarchy = {};
      this.contentDataMap = new Map();
      this.updatedMetaMap = new Map();
      this.updatedDataSet = new Set();
      this.parentContent = [];
      this.changeActiveCont = new rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]('');
      this.changeActiveParentCont = new rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]('');
      this.onContentChange = new rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]('');
      this.onDataChange = new rxjs_internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]('');
    });
    EditorContentV2Service = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])()], EditorContentV2Service);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.scss":
  /*!*****************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.scss ***!
    \*****************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAceEditorAceEditorComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "ace-editor {\n  min-height: 40px;\n  min-width: 400px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3NvbmFzaGFqdS9WaWRlb3Mvc3BoZXJlLW1vYmlsZS9wcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYWNlLWVkaXRvci9hY2UtZWRpdG9yLmNvbXBvbmVudC5zY3NzIiwicHJvamVjdC93cy9hdXRob3Ivc3JjL2xpYi9yb3V0aW5nL21vZHVsZXMvZWRpdG9yL3NoYXJlZC9jb21wb25lbnRzL2FjZS1lZGl0b3IvYWNlLWVkaXRvci5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGdCQUFBO0VBQ0EsZ0JBQUE7QUNDRiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYWNlLWVkaXRvci9hY2UtZWRpdG9yLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiYWNlLWVkaXRvciB7XG4gIG1pbi1oZWlnaHQ6IDQwcHg7XG4gIG1pbi13aWR0aDogNDAwcHg7XG59XG4iLCJhY2UtZWRpdG9yIHtcbiAgbWluLWhlaWdodDogNDBweDtcbiAgbWluLXdpZHRoOiA0MDBweDtcbn0iXX0= */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.ts":
  /*!***************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.ts ***!
    \***************************************************************************************************************/
  /*! exports provided: AceEditorComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAceEditorAceEditorComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AceEditorComponent", function () {
      return AceEditorComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var brace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! brace */"./node_modules/brace/index.js");
    /* harmony import */
    var brace__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(brace__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */
    var brace_ext_language_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! brace/ext/language_tools */"./node_modules/brace/ext/language_tools.js");
    /* harmony import */
    var brace_ext_language_tools__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(brace_ext_language_tools__WEBPACK_IMPORTED_MODULE_3__);
    /* harmony import */
    var brace_mode_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! brace/mode/json */"./node_modules/brace/mode/json.js");
    /* harmony import */
    var brace_mode_json__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(brace_mode_json__WEBPACK_IMPORTED_MODULE_4__);
    /* harmony import */
    var brace_snippets_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! brace/snippets/json */"./node_modules/brace/snippets/json.js");
    /* harmony import */
    var brace_snippets_json__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(brace_snippets_json__WEBPACK_IMPORTED_MODULE_5__);
    /* harmony import */
    var brace_theme_textmate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! brace/theme/textmate */"./node_modules/brace/theme/textmate.js");
    /* harmony import */
    var brace_theme_textmate__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(brace_theme_textmate__WEBPACK_IMPORTED_MODULE_6__);
    var AceEditorComponent = /*#__PURE__*/function () {
      function AceEditorComponent() {
        _classCallCheck(this, AceEditorComponent);
        this.id = new Date().toISOString();
        this.mode = 'json';
        this.data = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.options = {
          maxLines: 'Infinity',
          printMargin: false,
          enableBasicAutocompletion: true,
          enableSnippets: true,
          enableLiveAutocompletion: true,
          showInvisibles: false,
          showGutter: true,
          showLineNumbers: false
        };
      }
      _createClass(AceEditorComponent, [{
        key: "content",
        set: function set(data) {
          this.text = JSON.stringify(data, null, '\t');
        }
      }, {
        key: "onChange",
        value: function onChange(data) {
          try {
            this.data.emit(JSON.parse(data || {}));
          } catch (ex) {}
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);
      return AceEditorComponent;
    }();
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], AceEditorComponent.prototype, "mode", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], AceEditorComponent.prototype, "content", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], AceEditorComponent.prototype, "data", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('editor', {
      "static": false
    })], AceEditorComponent.prototype, "editor", void 0);
    AceEditorComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-ace-editor',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./ace-editor.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./ace-editor.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.scss"))["default"]]
    })], AceEditorComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.scss":
  /*!*************************************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.scss ***!
    \*************************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthEditorActionButtonsAuthEditorActionButtonsComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = ".buttons {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n  position: absolute;\n  right: 0px;\n  top: 35px;\n  z-index: 50;\n}\n@media screen and (max-width: 600px) {\n  .buttons {\n    top: -25px;\n  }\n}\n.small-button {\n  height: 32px;\n  width: 32px;\n  transition: 0.5s;\n  margin-right: 4px;\n}\n.small-icon {\n  font-size: 18px;\n  display: flex;\n  justify-content: center;\n  padding: 0;\n  margin: 0;\n  height: auto;\n  width: auto;\n  transition: 0.5s;\n}\n.button-grid {\n  display: grid;\n  width: 140px;\n  grid-template-columns: 0.2fr auto;\n}\n.button-text {\n  align-self: center;\n  padding-top: 17px;\n  padding-left: 4px;\n}\n.margin-right-xxs {\n  margin-right: 4px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3NvbmFzaGFqdS9WaWRlb3Mvc3BoZXJlLW1vYmlsZS9wcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYXV0aC1lZGl0b3ItYWN0aW9uLWJ1dHRvbnMvYXV0aC1lZGl0b3ItYWN0aW9uLWJ1dHRvbnMuY29tcG9uZW50LnNjc3MiLCJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYXV0aC1lZGl0b3ItYWN0aW9uLWJ1dHRvbnMvYXV0aC1lZGl0b3ItYWN0aW9uLWJ1dHRvbnMuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxxQkFBQTtFQUNBLGtCQUFBO0VBQ0EsVUFBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0FDQ0Y7QURDRTtFQVRGO0lBVUksVUFBQTtFQ0VGO0FBQ0Y7QURDQTtFQUNFLFlBQUE7RUFDQSxXQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtBQ0VGO0FEQ0E7RUFDRSxlQUFBO0VBQ0EsYUFBQTtFQUNBLHVCQUFBO0VBQ0EsVUFBQTtFQUNBLFNBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtFQUNBLGdCQUFBO0FDRUY7QURDQTtFQUNFLGFBQUE7RUFDQSxZQUFBO0VBQ0EsaUNBQUE7QUNFRjtBRENBO0VBQ0Usa0JBQUE7RUFDQSxpQkFBQTtFQUNBLGlCQUFBO0FDRUY7QURDQTtFQUNFLGlCQUFBO0FDRUYiLCJmaWxlIjoicHJvamVjdC93cy9hdXRob3Ivc3JjL2xpYi9yb3V0aW5nL21vZHVsZXMvZWRpdG9yL3NoYXJlZC9jb21wb25lbnRzL2F1dGgtZWRpdG9yLWFjdGlvbi1idXR0b25zL2F1dGgtZWRpdG9yLWFjdGlvbi1idXR0b25zLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmJ1dHRvbnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDBweDtcbiAgdG9wOiAzNXB4O1xuICB6LWluZGV4OiA1MDtcblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2MDBweCkge1xuICAgIHRvcDogLTI1cHg7XG4gIH1cbn1cblxuLnNtYWxsLWJ1dHRvbiB7XG4gIGhlaWdodDogMzJweDtcbiAgd2lkdGg6IDMycHg7XG4gIHRyYW5zaXRpb246IDAuNXM7XG4gIG1hcmdpbi1yaWdodDogNHB4O1xufVxuXG4uc21hbGwtaWNvbiB7XG4gIGZvbnQtc2l6ZTogMThweDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBhZGRpbmc6IDA7XG4gIG1hcmdpbjogMDtcbiAgaGVpZ2h0OiBhdXRvO1xuICB3aWR0aDogYXV0bztcbiAgdHJhbnNpdGlvbjogMC41cztcbn1cblxuLmJ1dHRvbi1ncmlkIHtcbiAgZGlzcGxheTogZ3JpZDtcbiAgd2lkdGg6IDE0MHB4O1xuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDAuMmZyIGF1dG87XG59XG5cbi5idXR0b24tdGV4dCB7XG4gIGFsaWduLXNlbGY6IGNlbnRlcjtcbiAgcGFkZGluZy10b3A6IDE3cHg7XG4gIHBhZGRpbmctbGVmdDogNHB4O1xufVxuXG4ubWFyZ2luLXJpZ2h0LXh4cyB7XG4gIG1hcmdpbi1yaWdodDogNHB4O1xufVxuIiwiLmJ1dHRvbnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDBweDtcbiAgdG9wOiAzNXB4O1xuICB6LWluZGV4OiA1MDtcbn1cbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYwMHB4KSB7XG4gIC5idXR0b25zIHtcbiAgICB0b3A6IC0yNXB4O1xuICB9XG59XG5cbi5zbWFsbC1idXR0b24ge1xuICBoZWlnaHQ6IDMycHg7XG4gIHdpZHRoOiAzMnB4O1xuICB0cmFuc2l0aW9uOiAwLjVzO1xuICBtYXJnaW4tcmlnaHQ6IDRweDtcbn1cblxuLnNtYWxsLWljb24ge1xuICBmb250LXNpemU6IDE4cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwYWRkaW5nOiAwO1xuICBtYXJnaW46IDA7XG4gIGhlaWdodDogYXV0bztcbiAgd2lkdGg6IGF1dG87XG4gIHRyYW5zaXRpb246IDAuNXM7XG59XG5cbi5idXR0b24tZ3JpZCB7XG4gIGRpc3BsYXk6IGdyaWQ7XG4gIHdpZHRoOiAxNDBweDtcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAwLjJmciBhdXRvO1xufVxuXG4uYnV0dG9uLXRleHQge1xuICBhbGlnbi1zZWxmOiBjZW50ZXI7XG4gIHBhZGRpbmctdG9wOiAxN3B4O1xuICBwYWRkaW5nLWxlZnQ6IDRweDtcbn1cblxuLm1hcmdpbi1yaWdodC14eHMge1xuICBtYXJnaW4tcmlnaHQ6IDRweDtcbn0iXX0= */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.ts":
  /*!***********************************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.ts ***!
    \***********************************************************************************************************************************************/
  /*! exports provided: AuthEditorActionButtonsComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthEditorActionButtonsAuthEditorActionButtonsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AuthEditorActionButtonsComponent", function () {
      return AuthEditorActionButtonsComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");

    /**
     * @description
     * Display the action buttons in the editor which allows user to click save or send for review or preview and so many other options
     *
     * @export
     * @class AuthEditorActionButtonsComponent
     * @implements {OnInit}
     */
    var AuthEditorActionButtonsComponent = /*#__PURE__*/function () {
      function AuthEditorActionButtonsComponent() {
        _classCallCheck(this, AuthEditorActionButtonsComponent);
        this.buttonConfig = null;
        this.action = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.showSettingButtons = true;
      }
      _createClass(AuthEditorActionButtonsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.showSettingButtons = this.buttonConfig && this.buttonConfig.enabled ? true : false;
        }
      }]);
      return AuthEditorActionButtonsComponent;
    }();
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], AuthEditorActionButtonsComponent.prototype, "buttonConfig", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], AuthEditorActionButtonsComponent.prototype, "action", void 0);
    AuthEditorActionButtonsComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-editor-action-buttons',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./auth-editor-action-buttons.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./auth-editor-action-buttons.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.scss"))["default"]]
    })], AuthEditorActionButtonsComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.scss":
  /*!*********************************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.scss ***!
    \*********************************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthLanguageSelectBarAuthLanguageSelectBarComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYXV0aC1sYW5ndWFnZS1zZWxlY3QtYmFyL2F1dGgtbGFuZ3VhZ2Utc2VsZWN0LWJhci5jb21wb25lbnQuc2NzcyJ9 */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.ts":
  /*!*******************************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.ts ***!
    \*******************************************************************************************************************************************/
  /*! exports provided: AuthLanguageSelectBarComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthLanguageSelectBarAuthLanguageSelectBarComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AuthLanguageSelectBarComponent", function () {
      return AuthLanguageSelectBarComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    var AuthLanguageSelectBarComponent = /*#__PURE__*/function () {
      function AuthLanguageSelectBarComponent() {
        _classCallCheck(this, AuthLanguageSelectBarComponent);
      }
      _createClass(AuthLanguageSelectBarComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);
      return AuthLanguageSelectBarComponent;
    }();
    AuthLanguageSelectBarComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-language-select-bar',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./auth-language-select-bar.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./auth-language-select-bar.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.scss"))["default"]]
    })], AuthLanguageSelectBarComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.scss":
  /*!*******************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.scss ***!
    \*******************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthPickerAuthPickerComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = ".btn-filter {\n  padding-bottom: 1.34375em;\n}\n\n.margin-bottom-xxs {\n  margin-bottom: 4px !important;\n}\n\n.leading-none {\n  line-height: 1 !important;\n}\n\n.resize-none {\n  resize: none;\n}\n\nmat-dialog-content {\n  max-height: 60vh;\n}\n\n.mat-dialog-container {\n  overflow: hidden;\n}\n\n.mat-raised-button {\n  margin-left: 10px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3NvbmFzaGFqdS9WaWRlb3Mvc3BoZXJlLW1vYmlsZS9wcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYXV0aC1waWNrZXIvYXV0aC1waWNrZXIuY29tcG9uZW50LnNjc3MiLCJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvYXV0aC1waWNrZXIvYXV0aC1waWNrZXIuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0E7RUFDRSx5QkFBQTtBQ0ZGOztBREtBO0VBQ0UsNkJBQUE7QUNGRjs7QURLQTtFQUNFLHlCQUFBO0FDRkY7O0FES0E7RUFDRSxZQUFBO0FDRkY7O0FES0E7RUFDRSxnQkFBQTtBQ0ZGOztBREtBO0VBQ0UsZ0JBQUE7QUNGRjs7QURLQTtFQUNFLGlCQUFBO0FDRkYiLCJmaWxlIjoicHJvamVjdC93cy9hdXRob3Ivc3JjL2xpYi9yb3V0aW5nL21vZHVsZXMvZWRpdG9yL3NoYXJlZC9jb21wb25lbnRzL2F1dGgtcGlja2VyL2F1dGgtcGlja2VyLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGltcG9ydCAnc3R5bGVzL193cy1jb21tb24uc2Nzcyc7XG5AaW1wb3J0ICdzdHlsZXMvX3dzLXZhcnMuc2Nzcyc7XG5cbi5idG4tZmlsdGVyIHtcbiAgcGFkZGluZy1ib3R0b206IDEuMzQzNzVlbTtcbn1cblxuLm1hcmdpbi1ib3R0b20teHhzIHtcbiAgbWFyZ2luLWJvdHRvbTogJHNpemUteHMgLyAyICFpbXBvcnRhbnQ7XG59XG5cbi5sZWFkaW5nLW5vbmUge1xuICBsaW5lLWhlaWdodDogMSAhaW1wb3J0YW50O1xufVxuXG4ucmVzaXplLW5vbmUge1xuICByZXNpemU6IG5vbmU7XG59XG5cbm1hdC1kaWFsb2ctY29udGVudCB7XG4gIG1heC1oZWlnaHQ6IDYwdmg7XG59XG5cbi5tYXQtZGlhbG9nLWNvbnRhaW5lciB7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5tYXQtcmFpc2VkLWJ1dHRvbiB7XG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xufVxuIiwiLmJ0bi1maWx0ZXIge1xuICBwYWRkaW5nLWJvdHRvbTogMS4zNDM3NWVtO1xufVxuXG4ubWFyZ2luLWJvdHRvbS14eHMge1xuICBtYXJnaW4tYm90dG9tOiA0cHggIWltcG9ydGFudDtcbn1cblxuLmxlYWRpbmctbm9uZSB7XG4gIGxpbmUtaGVpZ2h0OiAxICFpbXBvcnRhbnQ7XG59XG5cbi5yZXNpemUtbm9uZSB7XG4gIHJlc2l6ZTogbm9uZTtcbn1cblxubWF0LWRpYWxvZy1jb250ZW50IHtcbiAgbWF4LWhlaWdodDogNjB2aDtcbn1cblxuLm1hdC1kaWFsb2ctY29udGFpbmVyIHtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuLm1hdC1yYWlzZWQtYnV0dG9uIHtcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XG59Il19 */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.ts":
  /*!*****************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.ts ***!
    \*****************************************************************************************************************/
  /*! exports provided: AuthPickerComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsAuthPickerAuthPickerComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "AuthPickerComponent", function () {
      return AuthPickerComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/material */"./node_modules/@angular/material/esm2015/material.js");
    /* harmony import */
    var _ws_widget_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @ws-widget/utils */"./library/ws-widget/utils/src/public-api.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @ws/author/src/lib/constants/apiEndpoints */"./project/ws/author/src/lib/constants/apiEndpoints.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/services/access-control.service */"./project/ws/author/src/lib/modules/shared/services/access-control.service.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_services_api_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/services/api.service */"./project/ws/author/src/lib/modules/shared/services/api.service.ts");
    /* harmony import */
    var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! rxjs */"./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */
    var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! rxjs/operators */"./node_modules/rxjs/_esm2015/operators/index.js");
    var AuthPickerComponent = /*#__PURE__*/function () {
      function AuthPickerComponent(configSvc, apiService, dialogRef, accessService, data) {
        _classCallCheck(this, AuthPickerComponent);
        this.configSvc = configSvc;
        this.apiService = apiService;
        this.dialogRef = dialogRef;
        this.accessService = accessService;
        this.data = data;
        this.query = '';
        this.selectedContents = [];
        this.selectedContentIds = new Set();
        this.searchFetchStatus = 'none';
        this.searchResults = [];
        this.debounceSubject = new rxjs__WEBPACK_IMPORTED_MODULE_7__["BehaviorSubject"](false);
        this.debounceSubscription = null;
        this.defaultThumbnail = '';
        this.preSelected = new Set();
        this.showMine = true;
        var instanceConfig = this.configSvc.instanceConfig;
        if (instanceConfig) {
          this.defaultThumbnail = instanceConfig.logos.defaultContent;
        }
      }
      _createClass(AuthPickerComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.initializeSearchSubject();
          this.preSelected = new Set(Array.from(this.data.selectedIds || new Set()));
        }
      }, {
        key: "initializeSearchSubject",
        value: function initializeSearchSubject() {
          return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            var _this4 = this;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  this.debounceSubscription = this.debounceSubject.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["debounce"])(function (shouldDebounce) {
                    return shouldDebounce ? Object(rxjs__WEBPACK_IMPORTED_MODULE_7__["timer"])(500) : rxjs__WEBPACK_IMPORTED_MODULE_7__["EMPTY"];
                  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["mergeMap"])(function () {
                    _this4.searchFetchStatus = 'fetching';
                    _this4.searchResults = [];
                    var searchQuery = {
                      query: _this4.query || '',
                      rootOrg: _this4.accessService.rootOrg,
                      filters: [{
                        andFilters: [Object.assign({}, _this4.data.filter, {
                          creatorContacts: _this4.showMine ? [_this4.accessService.userId] : undefined
                        })]
                      }],
                      pageSize: 24,
                      sort: _this4.query ? undefined : [{
                        lastUpdatedOn: 'desc'
                      }],
                      uuid: _this4.accessService.userId,
                      pageNo: 0
                    };
                    if (_this4.showMine && _this4.configSvc.userProfile) {
                      searchQuery.filters[0].andFilters[0].status = searchQuery.filters[0].andFilters[0].status ? searchQuery.filters[0].andFilters[0].status : ['Draft', 'InReview', 'QualityReview', 'Reviewed', 'Live'];
                    }
                    return _this4.apiService.post(_ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_4__["SEARCH_V6_AUTH"], searchQuery);
                  })).subscribe(function (search) {
                    _this4.searchFetchStatus = 'done';
                    if (search && search.result) {
                      _this4.searchResults = search.result;
                    }
                  }, function () {
                    _this4.searchFetchStatus = 'error';
                  });
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
        }
      }, {
        key: "selectedContentChanged",
        value: function selectedContentChanged(content, checked) {
          if (checked) {
            this.selectedContents.push(content);
            this.selectedContentIds.add(content.identifier);
          } else {
            this.selectedContentIds["delete"](content.identifier);
            this.selectedContents = this.selectedContents.filter(function (v) {
              return v.identifier !== content.identifier;
            });
          }
        }
      }, {
        key: "close",
        value: function close() {
          this.dialogRef.close(this.selectedContents.map(function (v) {
            return v.identifier;
          }));
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.debounceSubscription) {
            this.debounceSubscription.unsubscribe();
          }
        }
      }]);
      return AuthPickerComponent;
    }();
    AuthPickerComponent.ctorParameters = function () {
      return [{
        type: _ws_widget_utils__WEBPACK_IMPORTED_MODULE_3__["ConfigurationsService"]
      }, {
        type: _ws_author_src_lib_modules_shared_services_api_service__WEBPACK_IMPORTED_MODULE_6__["ApiService"]
      }, {
        type: _angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogRef"]
      }, {
        type: _ws_author_src_lib_modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_5__["AccessControlService"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MAT_DIALOG_DATA"]]
        }]
      }];
    };
    AuthPickerComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-picker',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./auth-picker.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.html"))["default"],
      // tslint:disable-next-line: use-component-view-encapsulation
      encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./auth-picker.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.scss"))["default"]]
    }), tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](4, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"])(_angular_material__WEBPACK_IMPORTED_MODULE_2__["MAT_DIALOG_DATA"]))], AuthPickerComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.scss":
  /*!***************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.scss ***!
    \***************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditMetaEditMetaComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = ".font-weight-300 {\n  font-weight: 300;\n}\n\n.space-around {\n  justify-content: space-around;\n}\n\n.image-border {\n  border: 2px solid;\n  border-radius: 5px;\n}\n\n.width-90 {\n  width: 90%;\n}\n\n.disable {\n  opacity: 0.3;\n  pointer-events: none;\n  cursor: none;\n}\n\n.not-disable {\n  opacity: 0.7;\n}\n\ninput {\n  line-height: 1px;\n}\n\n.required::after {\n  color: red;\n  content: \" *\";\n}\n\n.max-width {\n  max-width: 256px;\n  max-height: 150px;\n}\n\n.buttons {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n  position: absolute;\n  top: 110px;\n  right: 60px;\n  z-index: 3;\n}\n\n.small-button {\n  height: 32px;\n  width: 32px;\n  transition: 0.5s;\n  margin-right: 4px;\n}\n\n.small-icon {\n  font-size: 18px;\n  display: flex;\n  justify-content: center;\n  padding: 0;\n  margin: 0;\n  height: auto;\n  width: auto;\n  transition: 0.5s;\n}\n\n.normal-button {\n  border-radius: 50%;\n  height: 40px;\n  display: flex;\n  width: 40px;\n  z-index: 3;\n  justify-content: center;\n}\n\n.photo {\n  height: 48px;\n  width: 48px;\n  background: #f2f2f2;\n  border-radius: 50%;\n  display: inline-block;\n  position: relative;\n  left: -30px;\n  bottom: 13px;\n  cursor: pointer;\n}\n\n.photo-icon {\n  position: relative;\n  top: 10px;\n  left: 9px;\n  width: 30px;\n  height: 30px;\n  font-size: 30px;\n}\n\n.mat-form-field {\n  display: flex;\n  flex-direction: column;\n}\n\n.resize-none {\n  resize: none;\n}\n\n.margin-left-40 {\n  margin-left: 66px;\n}\n\n.custom-form-control {\n  margin: 0.25em 25px;\n}\n\n.info {\n  opacity: 0.8;\n}\n\n.margin-l-l {\n  margin-left: 32px;\n}\n\n@media only screen and (max-width: 585px) {\n  .margin-l-l {\n    margin-left: 0px;\n  }\n}\n\n.margin-r-l {\n  margin-right: 32px;\n}\n\n@media only screen and (max-width: 585px) {\n  .margin-r-l {\n    margin-left: 0px;\n  }\n}\n\n.op30 {\n  opacity: 0.3;\n}\n\n.op100 {\n  opacity: 1;\n}\n\n.margin-top-60 {\n  margin-top: 60px;\n}\n\n.grid {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n}\n\n.flex-grow80 {\n  flex-grow: 0.8;\n}\n\n.transform {\n  transform: rotate(45deg);\n  transition: 0.3s;\n}\n\n.conceptsField {\n  transform: translateX(0);\n  opacity: 1;\n  transition: 0.3s;\n}\n\n.conceptsFieldInitial {\n  transform: translateX(-100px);\n  opacity: 0;\n  transition: 0.3s;\n}\n\ntextarea {\n  line-height: 1.5;\n}\n\n.op100 {\n  opacity: 1;\n}\n\n.upload-box {\n  border: 2px dashed rgba(28, 28, 28, 0.6);\n  border-radius: 2%;\n  width: 235px;\n}\n\n.text-white {\n  color: #fff;\n}\n\nul li {\n  margin: 20px 0;\n}\n\n.inputfile {\n  width: 0.1px;\n  height: 0.1px;\n  opacity: 0;\n  overflow: hidden;\n  position: absolute;\n  z-index: -1;\n}\n\n.inputfile + label {\n  font-size: 1.25em;\n  color: white;\n  display: inline-block;\n  cursor: pointer;\n}\n\n.pointer {\n  cursor: pointer;\n}\n\n.duration-width {\n  width: 55px;\n}\n\n.padding-small {\n  padding: 5px;\n}\n\n.numberInput::-webkit-inner-spin-button,\n.numberInput::-webkit-outer-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n.mat-button-size {\n  height: 37.5px !important;\n  cursor: pointer;\n  margin: auto;\n}\n\n.row-wise {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n}\n\n.mobile-break {\n  display: flex;\n  flex-direction: row;\n}\n\n.new-mobile {\n  display: flex;\n  flex-direction: column;\n}\n\n@media only screen and (max-width: 960px) {\n  .mobile-break {\n    flex-direction: column;\n  }\n}\n\n@media (min-width: 961px) {\n  .width-300 {\n    width: 300;\n  }\n}\n\n.cross-btn {\n  margin-left: auto;\n  order: 2;\n  padding-right: 15px;\n}\n\n.inner-section {\n  display: block;\n  margin: 0 -12px;\n  max-height: 78vh;\n  overflow: auto;\n}\n\n.header-bg {\n  background-color: #edf1e5;\n  margin: -12px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3NvbmFzaGFqdS9WaWRlb3Mvc3BoZXJlLW1vYmlsZS9wcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvZWRpdC1tZXRhL2VkaXQtbWV0YS5jb21wb25lbnQuc2NzcyIsInByb2plY3Qvd3MvYXV0aG9yL3NyYy9saWIvcm91dGluZy9tb2R1bGVzL2VkaXRvci9zaGFyZWQvY29tcG9uZW50cy9lZGl0LW1ldGEvZWRpdC1tZXRhLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsZ0JBQUE7QUNDRjs7QURFQTtFQUNFLDZCQUFBO0FDQ0Y7O0FET0E7RUFDRSxpQkFBQTtFQUNBLGtCQUFBO0FDSkY7O0FET0E7RUFDRSxVQUFBO0FDSkY7O0FET0E7RUFDRSxZQUFBO0VBQ0Esb0JBQUE7RUFDQSxZQUFBO0FDSkY7O0FET0E7RUFDRSxZQUFBO0FDSkY7O0FET0E7RUFDRSxnQkFBQTtBQ0pGOztBRFFFO0VBQ0UsVUFBQTtFQUNBLGFBQUE7QUNMSjs7QURTQTtFQUNFLGdCQUFBO0VBQ0EsaUJBQUE7QUNORjs7QURTQTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLHFCQUFBO0VBQ0Esa0JBQUE7RUFDQSxVQUFBO0VBQ0EsV0FBQTtFQUNBLFVBQUE7QUNORjs7QURTQTtFQUNFLFlBQUE7RUFDQSxXQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtBQ05GOztBRFNBO0VBQ0UsZUFBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtFQUNBLFVBQUE7RUFDQSxTQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSxnQkFBQTtBQ05GOztBRFNBO0VBQ0Usa0JBQUE7RUFDQSxZQUFBO0VBQ0EsYUFBQTtFQUNBLFdBQUE7RUFDQSxVQUFBO0VBQ0EsdUJBQUE7QUNORjs7QURXQTtFQUNFLFlBQUE7RUFDQSxXQUFBO0VBQ0EsbUJBQUE7RUFDQSxrQkFBQTtFQUNBLHFCQUFBO0VBQ0Esa0JBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7QUNSRjs7QURXQTtFQUNFLGtCQUFBO0VBQ0EsU0FBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7QUNSRjs7QURXQTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtBQ1JGOztBRFdBO0VBQ0UsWUFBQTtBQ1JGOztBRFdBO0VBQ0UsaUJBQUE7QUNSRjs7QURXQTtFQUNFLG1CQUFBO0FDUkY7O0FEV0E7RUFDRSxZQUFBO0FDUkY7O0FEV0E7RUFDRSxpQkFBQTtBQ1JGOztBRFVFO0VBSEY7SUFJSSxnQkFBQTtFQ1BGO0FBQ0Y7O0FEVUE7RUFDRSxrQkFBQTtBQ1BGOztBRFNFO0VBSEY7SUFJSSxnQkFBQTtFQ05GO0FBQ0Y7O0FEU0E7RUFDRSxZQUFBO0FDTkY7O0FEU0E7RUFDRSxVQUFBO0FDTkY7O0FEU0E7RUFDRSxnQkFBQTtBQ05GOztBRFNBO0VBQ0UsYUFBQTtFQUNBLDhCQUFBO0FDTkY7O0FEU0E7RUFDRSxjQUFBO0FDTkY7O0FEU0E7RUFDRSx3QkFBQTtFQUNBLGdCQUFBO0FDTkY7O0FEU0E7RUFDRSx3QkFBQTtFQUNBLFVBQUE7RUFDQSxnQkFBQTtBQ05GOztBRFNBO0VBQ0UsNkJBQUE7RUFDQSxVQUFBO0VBQ0EsZ0JBQUE7QUNORjs7QURTQTtFQUNFLGdCQUFBO0FDTkY7O0FEV0E7RUFDRSxVQUFBO0FDUkY7O0FEV0E7RUFDRSx3Q0FBQTtFQUNBLGlCQUFBO0VBQ0EsWUFBQTtBQ1JGOztBRFdBO0VBQ0UsV0FBQTtBQ1JGOztBRFdBO0VBQ0UsY0FBQTtBQ1JGOztBRFdBO0VBQ0UsWUFBQTtFQUNBLGFBQUE7RUFDQSxVQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtFQUNBLFdBQUE7QUNSRjs7QURXQTtFQUNFLGlCQUFBO0VBQ0EsWUFBQTtFQUNBLHFCQUFBO0VBQ0EsZUFBQTtBQ1JGOztBRFdBO0VBQ0UsZUFBQTtBQ1JGOztBRFdBO0VBQ0UsV0FBQTtBQ1JGOztBRFdBO0VBQ0UsWUFBQTtBQ1JGOztBRFdBOztFQUVFLHdCQUFBO0VBQ0EsU0FBQTtBQ1JGOztBRFdBO0VBQ0UseUJBQUE7RUFDQSxlQUFBO0VBQ0EsWUFBQTtBQ1JGOztBRFdBO0VBQ0UsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsNkJBQUE7QUNSRjs7QURVQTtFQUNFLGFBQUE7RUFDQSxtQkFBQTtBQ1BGOztBRFNBO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0FDTkY7O0FEU0E7RUFDRTtJQUNFLHNCQUFBO0VDTkY7QUFDRjs7QURTQTtFQUNFO0lBQ0UsVUFBQTtFQ1BGO0FBQ0Y7O0FEU0E7RUFDRSxpQkFBQTtFQUNBLFFBQUE7RUFDQSxtQkFBQTtBQ1BGOztBRFVBO0VBQ0UsY0FBQTtFQUNFLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGNBQUE7QUNQSjs7QURTQTtFQUNFLHlCQUFBO0VBQ0EsYUFBQTtBQ05GIiwiZmlsZSI6InByb2plY3Qvd3MvYXV0aG9yL3NyYy9saWIvcm91dGluZy9tb2R1bGVzL2VkaXRvci9zaGFyZWQvY29tcG9uZW50cy9lZGl0LW1ldGEvZWRpdC1tZXRhLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmZvbnQtd2VpZ2h0LTMwMCB7XG4gIGZvbnQtd2VpZ2h0OiAzMDA7XG59XG5cbi5zcGFjZS1hcm91bmQge1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbn1cblxuLy8gLnRhYnN7XG4vLyAgIGRpc3BsYXk6IGZsZXg7XG4vLyAgIC8vIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuLy8gfVxuXG4uaW1hZ2UtYm9yZGVyIHtcbiAgYm9yZGVyOiAycHggc29saWQ7XG4gIGJvcmRlci1yYWRpdXM6IDVweDtcbn1cblxuLndpZHRoLTkwIHtcbiAgd2lkdGg6IDkwJTtcbn1cblxuLmRpc2FibGUge1xuICBvcGFjaXR5OiAwLjM7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBjdXJzb3I6IG5vbmU7XG59XG5cbi5ub3QtZGlzYWJsZSB7XG4gIG9wYWNpdHk6IDAuNztcbn1cblxuaW5wdXQge1xuICBsaW5lLWhlaWdodDogMXB4O1xufVxuXG4ucmVxdWlyZWQge1xuICAmOjphZnRlciB7XG4gICAgY29sb3I6IHJlZDtcbiAgICBjb250ZW50OiAnIConO1xuICB9XG59XG5cbi5tYXgtd2lkdGgge1xuICBtYXgtd2lkdGg6IDI1NnB4O1xuICBtYXgtaGVpZ2h0OiAxNTBweDtcbn1cblxuLmJ1dHRvbnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAxMTBweDtcbiAgcmlnaHQ6IDYwcHg7XG4gIHotaW5kZXg6IDM7XG59XG5cbi5zbWFsbC1idXR0b24ge1xuICBoZWlnaHQ6IDMycHg7XG4gIHdpZHRoOiAzMnB4O1xuICB0cmFuc2l0aW9uOiAwLjVzO1xuICBtYXJnaW4tcmlnaHQ6IDRweDtcbn1cblxuLnNtYWxsLWljb24ge1xuICBmb250LXNpemU6IDE4cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwYWRkaW5nOiAwO1xuICBtYXJnaW46IDA7XG4gIGhlaWdodDogYXV0bztcbiAgd2lkdGg6IGF1dG87XG4gIHRyYW5zaXRpb246IDAuNXM7XG59XG5cbi5ub3JtYWwtYnV0dG9uIHtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBoZWlnaHQ6IDQwcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHdpZHRoOiA0MHB4O1xuICB6LWluZGV4OiAzO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cblxuLy8gZm9ybXNcblxuLnBob3RvIHtcbiAgaGVpZ2h0OiA0OHB4O1xuICB3aWR0aDogNDhweDtcbiAgYmFja2dyb3VuZDogI2YyZjJmMjtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgbGVmdDogLTMwcHg7XG4gIGJvdHRvbTogMTNweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ucGhvdG8taWNvbiB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdG9wOiAxMHB4O1xuICBsZWZ0OiA5cHg7XG4gIHdpZHRoOiAzMHB4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIGZvbnQtc2l6ZTogMzBweDtcbn1cblxuLm1hdC1mb3JtLWZpZWxkIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLnJlc2l6ZS1ub25lIHtcbiAgcmVzaXplOiBub25lO1xufVxuXG4ubWFyZ2luLWxlZnQtNDAge1xuICBtYXJnaW4tbGVmdDogNjZweDtcbn1cblxuLmN1c3RvbS1mb3JtLWNvbnRyb2wge1xuICBtYXJnaW46IDAuMjVlbSAyNXB4O1xufVxuXG4uaW5mbyB7XG4gIG9wYWNpdHk6IDAuODtcbn1cblxuLm1hcmdpbi1sLWwge1xuICBtYXJnaW4tbGVmdDogMzJweDtcblxuICBAbWVkaWEgb25seSBzY3JlZW4gYW5kKG1heC13aWR0aDogNTg1cHgpIHtcbiAgICBtYXJnaW4tbGVmdDogMHB4O1xuICB9XG59XG5cbi5tYXJnaW4tci1sIHtcbiAgbWFyZ2luLXJpZ2h0OiAzMnB4O1xuXG4gIEBtZWRpYSBvbmx5IHNjcmVlbiBhbmQobWF4LXdpZHRoOiA1ODVweCkge1xuICAgIG1hcmdpbi1sZWZ0OiAwcHg7XG4gIH1cbn1cblxuLm9wMzAge1xuICBvcGFjaXR5OiAwLjM7XG59XG5cbi5vcDEwMCB7XG4gIG9wYWNpdHk6IDE7XG59XG5cbi5tYXJnaW4tdG9wLTYwIHtcbiAgbWFyZ2luLXRvcDogNjBweDtcbn1cblxuLmdyaWQge1xuICBkaXNwbGF5OiBncmlkO1xuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XG59XG5cbi5mbGV4LWdyb3c4MCB7XG4gIGZsZXgtZ3JvdzogMC44O1xufVxuXG4udHJhbnNmb3JtIHtcbiAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuICB0cmFuc2l0aW9uOiAwLjNzO1xufVxuXG4uY29uY2VwdHNGaWVsZCB7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcbiAgb3BhY2l0eTogMTtcbiAgdHJhbnNpdGlvbjogMC4zcztcbn1cblxuLmNvbmNlcHRzRmllbGRJbml0aWFsIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDBweCk7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuM3M7XG59XG5cbnRleHRhcmVhIHtcbiAgbGluZS1oZWlnaHQ6IDEuNTtcbn1cblxuLy91cGxvYWQgYm94XG5cbi5vcDEwMCB7XG4gIG9wYWNpdHk6IDE7XG59XG5cbi51cGxvYWQtYm94IHtcbiAgYm9yZGVyOiAycHggZGFzaGVkIHJnYmEoMjgsIDI4LCAyOCwgMC42KTtcbiAgYm9yZGVyLXJhZGl1czogMiU7XG4gIHdpZHRoOiAyMzVweDtcbn1cblxuLnRleHQtd2hpdGUge1xuICBjb2xvcjogI2ZmZjtcbn1cblxudWwgbGkge1xuICBtYXJnaW46IDIwcHggMDtcbn1cblxuLmlucHV0ZmlsZSB7XG4gIHdpZHRoOiAwLjFweDtcbiAgaGVpZ2h0OiAwLjFweDtcbiAgb3BhY2l0eTogMDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB6LWluZGV4OiAtMTtcbn1cblxuLmlucHV0ZmlsZStsYWJlbCB7XG4gIGZvbnQtc2l6ZTogMS4yNWVtO1xuICBjb2xvcjogd2hpdGU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ucG9pbnRlciB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLmR1cmF0aW9uLXdpZHRoIHtcbiAgd2lkdGg6IDU1cHg7XG59XG5cbi5wYWRkaW5nLXNtYWxsIHtcbiAgcGFkZGluZzogNXB4O1xufVxuXG4ubnVtYmVySW5wdXQ6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXG4ubnVtYmVySW5wdXQ6Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gIG1hcmdpbjogMDtcbn1cblxuLm1hdC1idXR0b24tc2l6ZSB7XG4gIGhlaWdodDogMzcuNXB4ICFpbXBvcnRhbnQ7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgbWFyZ2luOiBhdXRvO1xufVxuXG4ucm93LXdpc2Uge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbn1cbi5tb2JpbGUtYnJlYWt7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG59XG4ubmV3LW1vYmlsZXtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi8vIDk2MFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjk2MHB4KSB7XG4gIC5tb2JpbGUtYnJlYWsge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIH1cbn1cblxuQG1lZGlhIChtaW4td2lkdGg6IDk2MXB4KSB7XG4gIC53aWR0aC0zMDAge1xuICAgIHdpZHRoOiAzMDBcbiAgfVxufVxuLmNyb3NzLWJ0biB7XG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICBvcmRlcjogMjtcbiAgcGFkZGluZy1yaWdodDogMTVweDtcbn1cblxuLmlubmVyLXNlY3Rpb24ge1xuICBkaXNwbGF5OiBibG9jaztcbiAgICBtYXJnaW46IDAgLTEycHg7XG4gICAgbWF4LWhlaWdodDogNzh2aDtcbiAgICBvdmVyZmxvdzogYXV0bztcbn1cbi5oZWFkZXItYmcge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWRmMWU1O1xuICBtYXJnaW46IC0xMnB4O1xufSIsIi5mb250LXdlaWdodC0zMDAge1xuICBmb250LXdlaWdodDogMzAwO1xufVxuXG4uc3BhY2UtYXJvdW5kIHtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG59XG5cbi5pbWFnZS1ib3JkZXIge1xuICBib3JkZXI6IDJweCBzb2xpZDtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xufVxuXG4ud2lkdGgtOTAge1xuICB3aWR0aDogOTAlO1xufVxuXG4uZGlzYWJsZSB7XG4gIG9wYWNpdHk6IDAuMztcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIGN1cnNvcjogbm9uZTtcbn1cblxuLm5vdC1kaXNhYmxlIHtcbiAgb3BhY2l0eTogMC43O1xufVxuXG5pbnB1dCB7XG4gIGxpbmUtaGVpZ2h0OiAxcHg7XG59XG5cbi5yZXF1aXJlZDo6YWZ0ZXIge1xuICBjb2xvcjogcmVkO1xuICBjb250ZW50OiBcIiAqXCI7XG59XG5cbi5tYXgtd2lkdGgge1xuICBtYXgtd2lkdGg6IDI1NnB4O1xuICBtYXgtaGVpZ2h0OiAxNTBweDtcbn1cblxuLmJ1dHRvbnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAxMTBweDtcbiAgcmlnaHQ6IDYwcHg7XG4gIHotaW5kZXg6IDM7XG59XG5cbi5zbWFsbC1idXR0b24ge1xuICBoZWlnaHQ6IDMycHg7XG4gIHdpZHRoOiAzMnB4O1xuICB0cmFuc2l0aW9uOiAwLjVzO1xuICBtYXJnaW4tcmlnaHQ6IDRweDtcbn1cblxuLnNtYWxsLWljb24ge1xuICBmb250LXNpemU6IDE4cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwYWRkaW5nOiAwO1xuICBtYXJnaW46IDA7XG4gIGhlaWdodDogYXV0bztcbiAgd2lkdGg6IGF1dG87XG4gIHRyYW5zaXRpb246IDAuNXM7XG59XG5cbi5ub3JtYWwtYnV0dG9uIHtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBoZWlnaHQ6IDQwcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHdpZHRoOiA0MHB4O1xuICB6LWluZGV4OiAzO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cblxuLnBob3RvIHtcbiAgaGVpZ2h0OiA0OHB4O1xuICB3aWR0aDogNDhweDtcbiAgYmFja2dyb3VuZDogI2YyZjJmMjtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgbGVmdDogLTMwcHg7XG4gIGJvdHRvbTogMTNweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ucGhvdG8taWNvbiB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdG9wOiAxMHB4O1xuICBsZWZ0OiA5cHg7XG4gIHdpZHRoOiAzMHB4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIGZvbnQtc2l6ZTogMzBweDtcbn1cblxuLm1hdC1mb3JtLWZpZWxkIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLnJlc2l6ZS1ub25lIHtcbiAgcmVzaXplOiBub25lO1xufVxuXG4ubWFyZ2luLWxlZnQtNDAge1xuICBtYXJnaW4tbGVmdDogNjZweDtcbn1cblxuLmN1c3RvbS1mb3JtLWNvbnRyb2wge1xuICBtYXJnaW46IDAuMjVlbSAyNXB4O1xufVxuXG4uaW5mbyB7XG4gIG9wYWNpdHk6IDAuODtcbn1cblxuLm1hcmdpbi1sLWwge1xuICBtYXJnaW4tbGVmdDogMzJweDtcbn1cbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNTg1cHgpIHtcbiAgLm1hcmdpbi1sLWwge1xuICAgIG1hcmdpbi1sZWZ0OiAwcHg7XG4gIH1cbn1cblxuLm1hcmdpbi1yLWwge1xuICBtYXJnaW4tcmlnaHQ6IDMycHg7XG59XG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDU4NXB4KSB7XG4gIC5tYXJnaW4tci1sIHtcbiAgICBtYXJnaW4tbGVmdDogMHB4O1xuICB9XG59XG5cbi5vcDMwIHtcbiAgb3BhY2l0eTogMC4zO1xufVxuXG4ub3AxMDAge1xuICBvcGFjaXR5OiAxO1xufVxuXG4ubWFyZ2luLXRvcC02MCB7XG4gIG1hcmdpbi10b3A6IDYwcHg7XG59XG5cbi5ncmlkIHtcbiAgZGlzcGxheTogZ3JpZDtcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyO1xufVxuXG4uZmxleC1ncm93ODAge1xuICBmbGV4LWdyb3c6IDAuODtcbn1cblxuLnRyYW5zZm9ybSB7XG4gIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgdHJhbnNpdGlvbjogMC4zcztcbn1cblxuLmNvbmNlcHRzRmllbGQge1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XG4gIG9wYWNpdHk6IDE7XG4gIHRyYW5zaXRpb246IDAuM3M7XG59XG5cbi5jb25jZXB0c0ZpZWxkSW5pdGlhbCB7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAwcHgpO1xuICBvcGFjaXR5OiAwO1xuICB0cmFuc2l0aW9uOiAwLjNzO1xufVxuXG50ZXh0YXJlYSB7XG4gIGxpbmUtaGVpZ2h0OiAxLjU7XG59XG5cbi5vcDEwMCB7XG4gIG9wYWNpdHk6IDE7XG59XG5cbi51cGxvYWQtYm94IHtcbiAgYm9yZGVyOiAycHggZGFzaGVkIHJnYmEoMjgsIDI4LCAyOCwgMC42KTtcbiAgYm9yZGVyLXJhZGl1czogMiU7XG4gIHdpZHRoOiAyMzVweDtcbn1cblxuLnRleHQtd2hpdGUge1xuICBjb2xvcjogI2ZmZjtcbn1cblxudWwgbGkge1xuICBtYXJnaW46IDIwcHggMDtcbn1cblxuLmlucHV0ZmlsZSB7XG4gIHdpZHRoOiAwLjFweDtcbiAgaGVpZ2h0OiAwLjFweDtcbiAgb3BhY2l0eTogMDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB6LWluZGV4OiAtMTtcbn1cblxuLmlucHV0ZmlsZSArIGxhYmVsIHtcbiAgZm9udC1zaXplOiAxLjI1ZW07XG4gIGNvbG9yOiB3aGl0ZTtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi5wb2ludGVyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4uZHVyYXRpb24td2lkdGgge1xuICB3aWR0aDogNTVweDtcbn1cblxuLnBhZGRpbmctc21hbGwge1xuICBwYWRkaW5nOiA1cHg7XG59XG5cbi5udW1iZXJJbnB1dDo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcbi5udW1iZXJJbnB1dDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4ubWF0LWJ1dHRvbi1zaXplIHtcbiAgaGVpZ2h0OiAzNy41cHggIWltcG9ydGFudDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBtYXJnaW46IGF1dG87XG59XG5cbi5yb3ctd2lzZSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xufVxuXG4ubW9iaWxlLWJyZWFrIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbn1cblxuLm5ldy1tb2JpbGUge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk2MHB4KSB7XG4gIC5tb2JpbGUtYnJlYWsge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIH1cbn1cbkBtZWRpYSAobWluLXdpZHRoOiA5NjFweCkge1xuICAud2lkdGgtMzAwIHtcbiAgICB3aWR0aDogMzAwO1xuICB9XG59XG4uY3Jvc3MtYnRuIHtcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gIG9yZGVyOiAyO1xuICBwYWRkaW5nLXJpZ2h0OiAxNXB4O1xufVxuXG4uaW5uZXItc2VjdGlvbiB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtYXJnaW46IDAgLTEycHg7XG4gIG1heC1oZWlnaHQ6IDc4dmg7XG4gIG92ZXJmbG93OiBhdXRvO1xufVxuXG4uaGVhZGVyLWJnIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VkZjFlNTtcbiAgbWFyZ2luOiAtMTJweDtcbn0iXX0= */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.ts":
  /*!*************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.ts ***!
    \*************************************************************************************************************/
  /*! exports provided: EditMetaComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditMetaEditMetaComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditMetaComponent", function () {
      return EditMetaComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/cdk/keycodes */"./node_modules/@angular/cdk/esm2015/keycodes.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/forms */"./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */
    var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @angular/material/dialog */"./node_modules/@angular/material/esm2015/dialog.js");
    /* harmony import */
    var _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @angular/material/snack-bar */"./node_modules/@angular/material/esm2015/snack-bar.js");
    /* harmony import */
    var _ws_widget_collection_src_public_api__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @ws-widget/collection/src/public-api */"./library/ws-widget/collection/src/public-api.ts");
    /* harmony import */
    var _ws_widget_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @ws-widget/utils */"./library/ws-widget/utils/src/public-api.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @ws/author/src/lib/constants/apiEndpoints */"./project/ws/author/src/lib/constants/apiEndpoints.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! @ws/author/src/lib/constants/constant */"./project/ws/author/src/lib/constants/constant.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @ws/author/src/lib/constants/notificationMessage */"./project/ws/author/src/lib/constants/notificationMessage.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! @ws/author/src/lib/constants/upload */"./project/ws/author/src/lib/constants/upload.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/components/notification/notification.component */"./project/ws/author/src/lib/modules/shared/components/notification/notification.component.ts");
    /* harmony import */
    var _ws_author_src_lib_routing_modules_editor_services_editor_content_service__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! @ws/author/src/lib/routing/modules/editor/services/editor-content.service */"./project/ws/author/src/lib/routing/modules/editor/services/editor-content.service.ts");
    /* harmony import */
    var _ws_author_src_lib_routing_modules_editor_services_editor_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__( /*! @ws/author/src/lib/routing/modules/editor/services/editor.service */"./project/ws/author/src/lib/routing/modules/editor/services/editor.service.ts");
    /* harmony import */
    var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__( /*! rxjs */"./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */
    var _app_src_lib_routes_profile_routes_interest_services_interest_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__( /*! ../../../../../../../../../app/src/lib/routes/profile/routes/interest/services/interest.service */"./project/ws/app/src/lib/routes/profile/routes/interest/services/interest.service.ts");
    /* harmony import */
    var _services_upload_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__( /*! ../../services/upload.service */"./project/ws/author/src/lib/routing/modules/editor/shared/services/upload.service.ts");
    /* harmony import */
    var _catalog_select_catalog_select_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__( /*! ../catalog-select/catalog-select.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/catalog-select/catalog-select.component.ts");
    /* harmony import */
    var _modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__( /*! ./../../../../../../modules/shared/services/access-control.service */"./project/ws/author/src/lib/modules/shared/services/access-control.service.ts");
    /* harmony import */
    var _services_init_service__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__( /*! ./../../../../../../services/init.service */"./project/ws/author/src/lib/services/init.service.ts");
    /* harmony import */
    var _services_loader_service__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__( /*! ./../../../../../../services/loader.service */"./project/ws/author/src/lib/services/loader.service.ts");
    /* harmony import */
    var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__( /*! rxjs/operators */"./node_modules/rxjs/_esm2015/operators/index.js");

    // import { CollectionStoreService } from './../../../routing/modules/collection/services/store.service'

    var EditMetaComponent = /*#__PURE__*/function () {
      function EditMetaComponent(formBuilder, uploadService, snackBar, dialog, editorService, contentService, configSvc, ref, interestSvc, loader, authInitService, accessService) {
        _classCallCheck(this, EditMetaComponent);
        this.formBuilder = formBuilder;
        this.uploadService = uploadService;
        this.snackBar = snackBar;
        this.dialog = dialog;
        this.editorService = editorService;
        this.contentService = contentService;
        this.configSvc = configSvc;
        this.ref = ref;
        this.interestSvc = interestSvc;
        this.loader = loader;
        this.authInitService = authInitService;
        this.accessService = accessService;
        this.data = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.isSubmitPressed = false;
        this.nextAction = 'done';
        this.stage = 1;
        this.type = '';
        this.location = _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_8__["CONTENT_BASE_STATIC"];
        this.selectable = true;
        this.removable = true;
        this.addOnBlur = true;
        this.addConcepts = false;
        this.isFileUploaded = false;
        this.selectedSkills = [];
        this.canUpdate = true;
        this.resourceTypes = [];
        this.employeeList = [];
        this.audienceList = [];
        this.jobProfileList = [];
        this.regionList = [];
        this.accessPathList = [];
        this.infoType = '';
        this.isSiemens = false;
        this.fetchTagsStatus = null;
        this.separatorKeysCodes = [_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["ENTER"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["COMMA"]];
        this.selectedIndex = 0;
        this.hours = 0;
        this.minutes = 1;
        this.seconds = 0;
        this.parentContent = null;
        this.imageTypes = _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_11__["IMAGE_SUPPORT_TYPES"];
        this.canExpiry = true;
        this.showMoreGlance = false;
        this.complexityLevelList = [];
        this.isEditEnabled = false;
        this.sideNavBarOpened = false;
        this.filteredOptions$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])([]);
        this.licenseTypes = [];
        this.orgNames = [];
      }
      _createClass(EditMetaComponent, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this5 = this;
          this.ref.detach();
          this.timer = setInterval(function () {
            _this5.ref.detectChanges();
            // tslint:disable-next-line: align
          }, 100);
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this6 = this;
          this.isSiemens = this.accessService.rootOrg.toLowerCase() === 'siemens';
          this.ordinals = this.authInitService.ordinals;
          this.audienceList = this.ordinals.audience;
          this.jobProfileList = this.ordinals.jobProfile;
          this.complexityLevelList = this.ordinals.audience;
          this.creatorContactsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.trackContactsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.publisherDetailsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.editorsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.creatorDetailsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.keywordsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]('');
          this.audienceCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.jobProfileCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.regionCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.accessPathsCtrl = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"]();
          this.accessPathsCtrl.disable();
          this.creatorContactsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (val) {
            return typeof val === 'string';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["switchMap"])(function (value) {
            if (typeof value === 'string' && value) {
              _this6.employeeList = [];
              _this6.fetchTagsStatus = 'fetching';
              return _this6.editorService.fetchEmployeeList(value);
            }
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])([]);
          })).subscribe(function (users) {
            _this6.employeeList = users || [];
            _this6.fetchTagsStatus = 'done';
          }, function () {
            _this6.fetchTagsStatus = 'done';
          });
          this.trackContactsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (val) {
            return typeof val === 'string';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["switchMap"])(function (value) {
            if (typeof value === 'string' && value) {
              _this6.employeeList = [];
              _this6.fetchTagsStatus = 'fetching';
              return _this6.editorService.fetchEmployeeList(value);
            }
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])([]);
          })).subscribe(function (users) {
            _this6.employeeList = users || [];
            _this6.fetchTagsStatus = 'done';
          }, function () {
            _this6.fetchTagsStatus = 'done';
          });
          this.publisherDetailsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (val) {
            return typeof val === 'string';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["switchMap"])(function (value) {
            if (typeof value === 'string' && value) {
              _this6.employeeList = [];
              _this6.fetchTagsStatus = 'fetching';
              return _this6.editorService.fetchEmployeeList(value);
            }
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])([]);
          })).subscribe(function (users) {
            _this6.employeeList = users || [];
            _this6.fetchTagsStatus = 'done';
          }, function () {
            _this6.fetchTagsStatus = 'done';
          });
          this.editorsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (val) {
            return typeof val === 'string';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["switchMap"])(function (value) {
            if (typeof value === 'string' && value) {
              _this6.employeeList = [];
              _this6.fetchTagsStatus = 'fetching';
              return _this6.editorService.fetchEmployeeList(value);
            }
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])([]);
          })).subscribe(function (users) {
            _this6.employeeList = users || [];
            _this6.fetchTagsStatus = 'done';
          }, function () {
            _this6.fetchTagsStatus = 'done';
          });
          this.creatorDetailsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (val) {
            return typeof val === 'string';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["switchMap"])(function (value) {
            if (typeof value === 'string' && value) {
              _this6.employeeList = [];
              _this6.fetchTagsStatus = 'fetching';
              return _this6.editorService.fetchEmployeeList(value);
            }
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])([]);
          })).subscribe(function (users) {
            _this6.employeeList = users || [];
            _this6.fetchTagsStatus = 'done';
          }, function () {
            _this6.fetchTagsStatus = 'done';
          });
          this.audienceCtrl.valueChanges.subscribe(function () {
            return _this6.fetchAudience();
          });
          this.jobProfileCtrl.valueChanges.subscribe(function () {
            return _this6.fetchJobProfile();
          });
          this.regionCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(400), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (v) {
            return v;
          })).subscribe(function () {
            return _this6.fetchRegion();
          });
          this.accessPathsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(400), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["filter"])(function (v) {
            return v;
          })).subscribe(function () {
            return _this6.fetchAccessRestrictions();
          });
          this.contentService.changeActiveCont.subscribe(function (data) {
            if (_this6.contentMeta && _this6.canUpdate) {
              _this6.storeData();
            }
            _this6.content = _this6.contentService.getUpdatedMeta(data);
          });
          this.filteredOptions$ = this.keywordsCtrl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["startWith"])(this.keywordsCtrl.value), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["switchMap"])(function (value) {
            return _this6.interestSvc.fetchAutocompleteInterestsV2(value);
          }));
          this.getLicenses();
        }
      }, {
        key: "getLicenses",
        value: function getLicenses() {
          var _this7 = this;
          this.editorService.fetchConfig().subscribe(function (data) {
            if (data && data.licenses && data.licenses.length > 0) {
              data.licenses.filter(function (item) {
                if (item.licenseName) {
                  _this7.licenseTypes.push(item.licenseName);
                }
              });
            }
          }, function (err) {
            if (err) {
              _this7.getLicenses();
            }
          });
        }
      }, {
        key: "getOrgMeta",
        value: function getOrgMeta() {
          var _this8 = this;
          this.editorService.fetchOrgMeta().subscribe(function (data) {
            if (data && data.sources && data.sources.length > 0) {
              data.sources.filter(function (org) {
                if (org.sourceName) {
                  _this8.orgNames.push(org.sourceName);
                }
              });
            }
          });
        }
      }, {
        key: "optionSelected",
        value: function optionSelected(keyword) {
          this.keywordsCtrl.setValue(' ');
          // this.keywordsSearch.nativeElement.blur()
          if (keyword && keyword.length) {
            var value = this.contentForm.controls.keywords.value || [];
            if (value.indexOf(keyword) === -1) {
              value.push(keyword);
              this.contentForm.controls.keywords.setValue(value);
            }
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.routerSubscription) {
            this.routerSubscription.unsubscribe();
          }
          this.loader.changeLoad.next(false);
          this.ref.detach();
          clearInterval(this.timer);
        }
      }, {
        key: "content",
        set: function set(contentMeta) {
          this.contentMeta = contentMeta;
          this.isEditEnabled = this.contentService.hasAccess(contentMeta, false, this.parentContent ? this.contentService.getUpdatedMeta(this.parentContent) : undefined);
          this.contentMeta.name = contentMeta.name === 'Untitled Content' ? '' : contentMeta.name;
          this.canExpiry = this.contentMeta.expiryDate !== '99991231T235959+0000';
          if (this.canExpiry) {
            this.contentMeta.expiryDate = contentMeta.expiryDate && contentMeta.expiryDate.indexOf('+') === 15 ? this.convertToISODate(contentMeta.expiryDate) : '';
          }
          this.assignFields();
          this.setDuration(contentMeta.duration || 0);
          this.filterOrdinals();
          this.changeResourceType();
        }
      }, {
        key: "filterOrdinals",
        value: function filterOrdinals() {
          var _this9 = this;
          this.complexityLevelList = [];
          this.ordinals.complexityLevel.map(function (v) {
            if (v.condition) {
              var canAdd = false;
              (v.condition.showFor || []).map(function (con) {
                var innerCondition = false;
                Object.keys(con).map(function (meta) {
                  if (con[meta].indexOf(_this9.contentForm.controls[meta] && _this9.contentForm.controls[meta].value || _this9.contentMeta[meta]) > -1) {
                    innerCondition = true;
                  }
                });
                if (innerCondition) {
                  canAdd = true;
                }
              });
              if (canAdd) {
                // tslint:disable-next-line: semicolon // tslint:disable-next-line: whitespace
                ;
                (v.condition.nowShowFor || []).map(function (con) {
                  var innerCondition = false;
                  Object.keys(con).map(function (meta) {
                    if (con[meta].indexOf(_this9.contentForm.controls[meta] && _this9.contentForm.controls[meta].value || _this9.contentMeta[meta]) < 0) {
                      innerCondition = true;
                    }
                  });
                  if (innerCondition) {
                    canAdd = false;
                  }
                });
              }
              if (canAdd) {
                _this9.complexityLevelList.push(v.value);
              }
            } else {
              if (typeof v === 'string') {
                _this9.complexityLevelList.push(v);
              } else {
                _this9.complexityLevelList.push(v.value);
              }
            }
          });
        }
      }, {
        key: "assignExpiryDate",
        value: function assignExpiryDate() {
          this.canExpiry = !this.canExpiry;
          this.contentForm.controls.expiryDate.setValue(this.canExpiry ? new Date(new Date().setMonth(new Date().getMonth() + 6)) : '99991231T235959+0000');
        }
      }, {
        key: "assignFields",
        value: function assignFields() {
          var _this10 = this;
          if (!this.contentForm) {
            this.createForm();
          }
          this.canUpdate = false;
          Object.keys(this.contentForm.controls).map(function (v) {
            try {
              if (_this10.contentMeta[v] || _this10.authInitService.authConfig[v].type === 'boolean' && _this10.contentMeta[v] === false) {
                _this10.contentForm.controls[v].setValue(_this10.contentMeta[v]);
              } else {
                if (v === 'expiryDate') {
                  _this10.contentForm.controls[v].setValue(new Date(new Date().setMonth(new Date().getMonth() + 60)));
                } else {
                  _this10.contentForm.controls[v].setValue(JSON.parse(JSON.stringify(_this10.authInitService.authConfig[v].defaultValue[_this10.contentMeta.contentType
                  // tslint:disable-next-line: ter-computed-property-spacing
                  ][0].value)));
                }
              }
              if (_this10.isSubmitPressed) {
                _this10.contentForm.controls[v].markAsDirty();
                _this10.contentForm.controls[v].markAsTouched();
              } else {
                _this10.contentForm.controls[v].markAsPristine();
                _this10.contentForm.controls[v].markAsUntouched();
              }
            } catch (ex) {}
          });
          this.canUpdate = true;
          this.storeData();
          if (this.isSubmitPressed) {
            this.contentForm.markAsDirty();
            this.contentForm.markAsTouched();
          } else {
            this.contentForm.markAsPristine();
            this.contentForm.markAsUntouched();
          }
        }
      }, {
        key: "convertToISODate",
        value: function convertToISODate() {
          var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          try {
            return new Date("".concat(date.substring(0, 4), "-").concat(date.substring(4, 6), "-").concat(date.substring(6, 8)).concat(date.substring(8, 11), ":").concat(date.substring(11, 13), ":").concat(date.substring(13, 15), ".000Z"));
          } catch (ex) {
            return new Date(new Date().setMonth(new Date().getMonth() + 6));
          }
        }
      }, {
        key: "changeMimeType",
        value: function changeMimeType() {
          var _this11 = this;
          var artifactUrl = this.contentForm.controls.artifactUrl ? this.contentForm.controls.artifactUrl.value : '';
          if (this.contentForm.controls.contentType.value === 'Course') {
            this.contentForm.controls.mimeType.setValue('application/vnd.ekstep.content-collection');
          } else {
            this.contentForm.controls.mimeType.setValue('application/html');
            if (this.configSvc.instanceConfig && this.configSvc.instanceConfig.authoring && this.configSvc.instanceConfig.authoring.urlPatternMatching) {
              this.configSvc.instanceConfig.authoring.urlPatternMatching.map(function (v) {
                if (artifactUrl.match(v.pattern) && v.allowIframe && v.source === 'youtube') {
                  _this11.contentForm.controls.mimeType.setValue('video/x-youtube');
                }
              });
            }
          }
        }
      }, {
        key: "changeResourceType",
        value: function changeResourceType() {
          if (this.contentForm.controls.contentType.value === 'Resource') {
            this.resourceTypes = this.ordinals.resourceType || this.ordinals.categoryType || [];
          } else {
            this.resourceTypes = this.ordinals['Offering Mode'] || this.ordinals.categoryType || [];
          }
          if (this.resourceTypes.indexOf(this.contentForm.controls.categoryType.value) < 0) {
            this.contentForm.controls.resourceType.setValue('');
          }
        }
      }, {
        key: "setDuration",
        value: function setDuration(seconds) {
          var minutes = seconds > 59 ? Math.floor(seconds / 60) : 0;
          var second = seconds % 60;
          this.hours = minutes ? minutes > 59 ? Math.floor(minutes / 60) : 0 : 0;
          this.minutes = minutes ? minutes % 60 : 0;
          this.seconds = second || 0;
        }
      }, {
        key: "timeToSeconds",
        value: function timeToSeconds() {
          var total = 0;
          total += this.seconds ? this.seconds < 60 ? this.seconds : 59 : 0;
          total += this.minutes ? (this.minutes < 60 ? this.minutes : 59) * 60 : 0;
          total += this.hours ? this.hours * 60 * 60 : 0;
          this.contentForm.controls.duration.setValue(total);
        }
      }, {
        key: "showInfo",
        value: function showInfo(type) {
          this.infoType = this.infoType === type ? '' : type;
        }
      }, {
        key: "storeData",
        value: function storeData() {
          var _this12 = this;
          try {
            var originalMeta = this.contentService.getOriginalMeta(this.contentMeta.identifier);
            if (originalMeta && this.isEditEnabled) {
              var expiryDate = this.contentForm.value.expiryDate;
              var currentMeta = JSON.parse(JSON.stringify(this.contentForm.value));
              var exemptArray = ['application/quiz', 'application/x-mpegURL', 'audio/mpeg'];
              if (exemptArray.includes(originalMeta.mimeType)) {
                currentMeta.artifactUrl = originalMeta.artifactUrl;
                currentMeta.mimeType = originalMeta.mimeType;
              }
              if (!currentMeta.duration && originalMeta.duration) {
                currentMeta.duration = originalMeta.duration;
              }
              if (!currentMeta.appIcon && originalMeta.appIcon) {
                currentMeta.appIcon = originalMeta.appIcon;
                currentMeta.thumbnail = originalMeta.thumbnail;
              }
              // currentMeta.resourceType=currentMeta.categoryType;
              if (currentMeta.status === 'Draft') {
                var parentData = this.contentService.parentUpdatedMeta();
                if (parentData && currentMeta.identifier !== parentData.identifier) {
                  //   currentMeta.thumbnail = parentData.thumbnail !== '' ? parentData.thumbnail : currentMeta.thumbnail
                  // currentMeta.appIcon = parentData.appIcon !== '' ? parentData.appIcon : currentMeta.appIcon
                  //  if (!currentMeta.posterImage) {
                  //   currentMeta.posterImage = parentData.posterImage !== '' ? parentData.posterImage : currentMeta.posterImage
                  //  }
                  if (!currentMeta.subTitle) {
                    currentMeta.subTitle = parentData.subTitle !== '' ? parentData.subTitle : currentMeta.subTitle;
                  }
                  if (!currentMeta.body) {
                    currentMeta.body = parentData.body !== '' ? parentData.body : currentMeta.body;
                  }
                  if (!currentMeta.categoryType) {
                    currentMeta.categoryType = parentData.categoryType !== '' ? parentData.categoryType : currentMeta.categoryType;
                  }
                  if (!currentMeta.resourceType) {
                    currentMeta.resourceType = parentData.resourceType !== '' ? parentData.resourceType : currentMeta.resourceType;
                  }
                  if (!currentMeta.sourceName) {
                    currentMeta.sourceName = parentData.sourceName !== '' ? parentData.sourceName : currentMeta.sourceName;
                  }
                }
              }
              // if(currentMeta.categoryType && !currentMeta.resourceType){
              //   currentMeta.resourceType = currentMeta.categoryType
              // }
              // if(currentMeta.resourceType && !currentMeta.categoryType){
              //   currentMeta.categoryType = currentMeta.resourceType
              // }
              var meta = {};
              if (this.canExpiry) {
                currentMeta.expiryDate = "".concat(expiryDate.toISOString().replace(/-/g, '').replace(/:/g, '').split('.')[0], "+0000");
              }
              Object.keys(currentMeta).map(function (v) {
                if (JSON.stringify(currentMeta[v]) !== JSON.stringify(originalMeta[v]) && v !== 'jobProfile') {
                  if (currentMeta[v] || _this12.authInitService.authConfig[v].type === 'boolean' && currentMeta[v] === false) {
                    meta[v] = currentMeta[v];
                  } else {
                    meta[v] = JSON.parse(JSON.stringify(_this12.authInitService.authConfig[v].defaultValue[originalMeta.contentType
                    // tslint:disable-next-line: ter-computed-property-spacing
                    ][0].value));
                  }
                }
              });
              if (this.stage >= 1 && !this.type) {
                delete meta.artifactUrl;
              }
              this.contentService.setUpdatedMeta(meta, this.contentMeta.identifier);
            }
          } catch (ex) {
            this.snackBar.open('Please Save Parent first and refresh page.');
            if (ex) {
              // this.saveParent = true
              // this.emitSaveData(true)
            }
            // this.contentService.parentContent
          }
        }
        // emitSaveData(flag: boolean) {
        //   if (flag) {
        //     this.saveParent = 1
        //     if (this.saveParent === 1) {
        //       this.data.emit('save')
        //     }
        //     this.saveParent = 2
        //   }
        // }
      }, {
        key: "updateContentService",
        value: function updateContentService(meta, value) {
          var event = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          this.contentForm.controls[meta].setValue(value, {
            events: event
          });
          this.contentService.setUpdatedMeta(_defineProperty({}, meta, value), this.contentMeta.identifier);
        }
      }, {
        key: "formNext",
        value: function formNext(index) {
          this.selectedIndex = index;
        }
      }, {
        key: "addKeyword",
        value: function addKeyword(event) {
          var _this13 = this;
          var input = event.input;
          event.value.split(/[,]+/).map(function (val) {
            return val.trim();
          }).forEach(function (value) {
            return _this13.optionSelected(value);
          });
          input.value = '';
        }
      }, {
        key: "addReferences",
        value: function addReferences(event) {
          var input = event.input;
          var value = event.value;
          // Add our fruit
          if ((value || '').trim().length) {
            var oldArray = this.contentForm.controls.references.value || [];
            oldArray.push({
              title: '',
              url: value
            });
            this.contentForm.controls.references.setValue(oldArray);
          }
          // Reset the input value
          if (input) {
            input.value = '';
          }
        }
      }, {
        key: "removeKeyword",
        value: function removeKeyword(keyword) {
          var index = this.contentForm.controls.keywords.value.indexOf(keyword);
          this.contentForm.controls.keywords.value.splice(index, 1);
          this.contentForm.controls.keywords.setValue(this.contentForm.controls.keywords.value);
        }
      }, {
        key: "removeReferences",
        value: function removeReferences(index) {
          this.contentForm.controls.references.value.splice(index, 1);
          this.contentForm.controls.references.setValue(this.contentForm.controls.references.value);
        }
      }, {
        key: "compareSkillFn",
        value: function compareSkillFn(value1, value2) {
          return value1 && value2 ? value1.identifier === value2.identifier : value1 === value2;
        }
      }, {
        key: "addCreatorDetails",
        value: function addCreatorDetails(event) {
          var input = event.input;
          var value = (event.value || '').trim();
          if (value) {
            this.contentForm.controls.creatorDetails.value.push({
              id: '',
              name: value
            });
            this.contentForm.controls.creatorDetails.setValue(this.contentForm.controls.creatorDetails.value);
          }
          // Reset the input value
          if (input) {
            input.value = '';
          }
        }
      }, {
        key: "removeCreatorDetails",
        value: function removeCreatorDetails(keyword) {
          var index = this.contentForm.controls.creatorDetails.value.indexOf(keyword);
          this.contentForm.controls.creatorDetails.value.splice(index, 1);
          this.contentForm.controls.creatorDetails.setValue(this.contentForm.controls.creatorDetails.value);
        }
      }, {
        key: "addToFormControl",
        value: function addToFormControl(event, fieldName) {
          var value = (event.option.value || '').trim();
          if (value && this.contentForm.controls[fieldName].value.indexOf(value) === -1) {
            this.contentForm.controls[fieldName].value.push(value);
            this.contentForm.controls[fieldName].setValue(this.contentForm.controls[fieldName].value);
          }
          this["".concat(fieldName, "View")].nativeElement.value = '';
          this["".concat(fieldName, "Ctrl")].setValue(null);
        }
      }, {
        key: "removeFromFormControl",
        value: function removeFromFormControl(keyword, fieldName) {
          var index = this.contentForm.controls[fieldName].value.indexOf(keyword);
          this.contentForm.controls[fieldName].value.splice(index, 1);
          this.contentForm.controls[fieldName].setValue(this.contentForm.controls[fieldName].value);
        }
      }, {
        key: "conceptToggle",
        value: function conceptToggle() {
          this.addConcepts = !this.addConcepts;
        }
      }, {
        key: "uploadAppIcon",
        value: function uploadAppIcon(file) {
          var _this14 = this;
          var formdata = new FormData();
          var fileName = file.name.replace(/[^A-Za-z0-9.]/g, '');
          if (!(_ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_11__["IMAGE_SUPPORT_TYPES"].indexOf(".".concat(fileName.toLowerCase().split('.').pop())) > -1)) {
            this.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
              data: {
                type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].INVALID_FORMAT
              },
              duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
            });
            return;
          }
          if (file.size > _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_11__["IMAGE_MAX_SIZE"]) {
            this.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
              data: {
                type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].SIZE_ERROR
              },
              duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
            });
            return;
          }
          var dialogRef = this.dialog.open(_ws_widget_utils__WEBPACK_IMPORTED_MODULE_7__["ImageCropComponent"], {
            width: '70%',
            data: {
              isRoundCrop: false,
              imageFile: file,
              width: 265,
              height: 150,
              isThumbnail: true,
              imageFileName: fileName
            }
          });
          dialogRef.afterClosed().subscribe({
            next: function next(result) {
              if (result) {
                formdata.append('content', result, fileName);
                _this14.loader.changeLoad.next(true);
                _this14.uploadService.upload(formdata, {
                  contentId: _this14.contentMeta.identifier,
                  contentType: _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_8__["CONTENT_BASE_STATIC"]
                }).subscribe(function (data) {
                  if (data.code) {
                    _this14.loader.changeLoad.next(false);
                    _this14.canUpdate = false;
                    _this14.contentForm.controls.appIcon.setValue(data.artifactURL);
                    _this14.contentForm.controls.thumbnail.setValue(data.artifactURL);
                    _this14.contentForm.controls.posterImage.setValue(data.artifactURL);
                    _this14.canUpdate = true;
                    _this14.storeData();
                    _this14.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
                      data: {
                        type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].UPLOAD_SUCCESS
                      },
                      duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
                    });
                  }
                }, function () {
                  _this14.loader.changeLoad.next(false);
                  _this14.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
                    data: {
                      type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].UPLOAD_FAIL
                    },
                    duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
                  });
                });
              }
            }
          });
        }
      }, {
        key: "uploadSourceIcon",
        value: function uploadSourceIcon(file) {
          var _this15 = this;
          var formdata = new FormData();
          var fileName = file.name.replace(/[^A-Za-z0-9.]/g, '');
          if (!(_ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_11__["IMAGE_SUPPORT_TYPES"].indexOf(".".concat(fileName.toLowerCase().split('.').pop())) > -1)) {
            this.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
              data: {
                type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].INVALID_FORMAT
              },
              duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
            });
            return;
          }
          if (file.size > _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_11__["IMAGE_MAX_SIZE"]) {
            this.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
              data: {
                type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].SIZE_ERROR
              },
              duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
            });
            return;
          }
          var dialogRef = this.dialog.open(_ws_widget_utils__WEBPACK_IMPORTED_MODULE_7__["ImageCropComponent"], {
            width: '70%',
            data: {
              isRoundCrop: false,
              imageFile: file,
              width: 72,
              height: 72,
              isThumbnail: true,
              imageFileName: fileName
            }
          });
          dialogRef.afterClosed().subscribe({
            next: function next(result) {
              if (result) {
                formdata.append('content', result, fileName);
                _this15.loader.changeLoad.next(true);
                _this15.uploadService.upload(formdata, {
                  contentId: _this15.contentMeta.identifier,
                  contentType: _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_8__["CONTENT_BASE_STATIC"]
                }).subscribe(function (data) {
                  if (data.code) {
                    _this15.loader.changeLoad.next(false);
                    _this15.canUpdate = false;
                    _this15.contentForm.controls.creatorLogo.setValue(data.artifactURL);
                    _this15.contentForm.controls.creatorThumbnail.setValue(data.artifactURL);
                    _this15.contentForm.controls.creatorPosterImage.setValue(data.artifactURL);
                    _this15.canUpdate = true;
                    _this15.storeData();
                    _this15.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
                      data: {
                        type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].UPLOAD_SUCCESS
                      },
                      duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
                    });
                  }
                }, function () {
                  _this15.loader.changeLoad.next(false);
                  _this15.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
                    data: {
                      type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].UPLOAD_FAIL
                    },
                    duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
                  });
                });
              }
            }
          });
        }
      }, {
        key: "changeToDefaultImg",
        value: function changeToDefaultImg($event) {
          $event.target.src = this.configSvc.instanceConfig ? this.configSvc.instanceConfig.logos.defaultContent : '';
        }
      }, {
        key: "showError",
        value: function showError(meta) {
          if (this.contentService.checkCondition(this.contentMeta.identifier, meta, 'required') && !this.contentService.isPresent(meta, this.contentMeta.identifier)) {
            if (this.isSubmitPressed) {
              return true;
            }
            if (this.contentForm.controls[meta] && this.contentForm.controls[meta].touched) {
              return true;
            }
            return false;
          }
          return false;
        }
      }, {
        key: "removeEmployee",
        value: function removeEmployee(employee, field) {
          var index = this.contentForm.controls[field].value.indexOf(employee);
          this.contentForm.controls[field].value.splice(index, 1);
          this.contentForm.controls[field].setValue(this.contentForm.controls[field].value);
        }
      }, {
        key: "addEmployee",
        value: function addEmployee(event, field) {
          var _this16 = this;
          if (event.option.value && event.option.value.id) {
            this.loader.changeLoad.next(true);
            var observable = ['trackContacts', 'publisherDetails'].includes(field) && this.accessService.authoringConfig.doUniqueCheck ? this.editorService.checkRole(event.option.value.id).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["map"])(function (v) {
              return v.includes('admin') || v.includes('editor') || field === 'trackContacts' && v.includes('reviewer') || field === 'publisherDetails' && v.includes('publisher') || field === 'publisherDetails' && event.option.value.id === _this16.accessService.userId;
            })) : Object(rxjs__WEBPACK_IMPORTED_MODULE_15__["of"])(true);
            observable.subscribe(function (data) {
              if (data) {
                _this16.contentForm.controls[field].value.push({
                  id: event.option.value.id,
                  name: event.option.value.displayName
                });
                _this16.contentForm.controls[field].setValue(_this16.contentForm.controls[field].value);
              } else {
                _this16.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
                  data: {
                    type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].NO_ROLE
                  },
                  duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
                });
              }
              _this16["".concat(field, "View")].nativeElement.value = '';
              _this16["".concat(field, "Ctrl")].setValue(null);
            }, function () {
              _this16.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
                data: {
                  type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].FAIL
                },
                duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
              });
            }, function () {
              _this16.loader.changeLoad.next(false);
              _this16["".concat(field, "View")].nativeElement.value = '';
              _this16["".concat(field, "Ctrl")].setValue(null);
            });
          }
        }
      }, {
        key: "removeField",
        value: function removeField(event) {
          // Reset the input value
          if (event.input) {
            event.input.value = '';
          }
        }
      }, {
        key: "fetchAudience",
        value: function fetchAudience() {
          var _this17 = this;
          if ((this.audienceCtrl.value || '').trim()) {
            this.audienceList = this.ordinals.audience.filter(function (v) {
              return v.toLowerCase().indexOf(_this17.audienceCtrl.value.toLowerCase()) > -1;
            });
          } else {
            this.audienceList = this.ordinals.audience.slice();
          }
        }
      }, {
        key: "fetchJobProfile",
        value: function fetchJobProfile() {
          var _this18 = this;
          if ((this.jobProfileCtrl.value || '').trim()) {
            this.jobProfileList = this.ordinals.jobProfile.filter(function (v) {
              return v.toLowerCase().indexOf(_this18.jobProfileCtrl.value.toLowerCase()) > -1;
            });
          } else {
            this.jobProfileList = this.ordinals.jobProfile.slice();
          }
        }
      }, {
        key: "fetchRegion",
        value: function fetchRegion() {
          var _this19 = this;
          if ((this.regionCtrl.value || '').trim()) {
            this.regionList = this.ordinals.region.filter(function (v) {
              return v.toLowerCase().indexOf(_this19.regionCtrl.value.toLowerCase()) > -1;
            });
          } else {
            this.regionList = [];
          }
        }
      }, {
        key: "fetchAccessRestrictions",
        value: function fetchAccessRestrictions() {
          var _this20 = this;
          if (this.accessPathsCtrl.value.trim()) {
            this.accessPathList = this.ordinals.accessPaths.filter(function (v) {
              return v.toLowerCase().indexOf(_this20.accessPathsCtrl.value.toLowerCase()) === 0;
            });
          } else {
            this.accessPathList = this.ordinals.accessPaths.slice();
          }
        }
      }, {
        key: "checkCondition",
        value: function checkCondition(meta, type) {
          if (type === 'disabled' && !this.isEditEnabled) {
            return true;
          }
          return this.contentService.checkCondition(this.contentMeta.identifier, meta, type);
        }
      }, {
        key: "createForm",
        value: function createForm() {
          var _this21 = this;
          this.contentForm = this.formBuilder.group({
            accessPaths: [],
            accessibility: [],
            appIcon: [],
            artifactUrl: [],
            audience: [],
            body: [],
            catalogPaths: [],
            category: [],
            categoryType: [],
            certificationList: [],
            certificationUrl: [],
            clients: [],
            complexityLevel: [],
            concepts: [],
            contentIdAtSource: [],
            contentType: [],
            creatorContacts: [],
            customClassifiers: [],
            description: [],
            dimension: [],
            duration: [],
            editors: [],
            equivalentCertifications: [],
            expiryDate: [],
            exclusiveContent: [],
            idealScreenSize: [],
            identifier: [],
            introductoryVideo: [],
            introductoryVideoIcon: [],
            isExternal: [],
            isIframeSupported: [],
            isRejected: [],
            fileType: [],
            jobProfile: [],
            kArtifacts: [],
            keywords: [],
            learningMode: [],
            learningObjective: [],
            learningTrack: [],
            locale: [],
            mimeType: [],
            name: [],
            nodeType: [],
            org: [],
            creatorDetails: [],
            passPercentage: [],
            plagScan: [],
            playgroundInstructions: [],
            playgroundResources: [],
            postContents: [],
            posterImage: [],
            preContents: [],
            preRequisites: [],
            projectCode: [],
            publicationId: [],
            publisherDetails: [],
            references: [],
            region: [],
            registrationInstructions: [],
            resourceCategory: [],
            resourceType: [],
            sampleCertificates: [],
            skills: [],
            softwareRequirements: [],
            sourceName: [],
            creatorLogo: [],
            creatorPosterImage: [],
            creatorThumbnail: [],
            status: [],
            studyDuration: [],
            studyMaterials: [],
            subTitle: [],
            subTitles: [],
            systemRequirements: [],
            thumbnail: [],
            trackContacts: [],
            transcoding: [],
            unit: [],
            verifiers: [],
            visibility: []
          });
          this.contentForm.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__["debounceTime"])(500)).subscribe(function () {
            if (_this21.canUpdate) {
              _this21.storeData();
            }
          });
          this.contentForm.controls.contentType.valueChanges.subscribe(function () {
            _this21.changeResourceType();
            _this21.filterOrdinals();
            _this21.changeMimeType();
            _this21.contentForm.controls.category.setValue(_this21.contentForm.controls.contentType.value);
          });
          if (this.stage === 1) {
            this.contentForm.controls.creatorContacts.valueChanges.subscribe(function () {
              _this21.contentForm.controls.publisherDetails.setValue(_this21.contentForm.controls.creatorContacts.value || []);
            });
          }
          // resourceType
          this.contentForm.controls.resourceType.valueChanges.subscribe(function () {
            _this21.contentForm.controls.categoryType.setValue(_this21.contentForm.controls.resourceType.value);
            // this.contentForm.controls.resourceType.setValue(this.contentForm.controls.resourceType.value)
          });

          this.contentForm.controls.resourceCategory.valueChanges.subscribe(function () {
            _this21.contentForm.controls.customClassifiers.setValue(_this21.contentForm.controls.resourceCategory.value);
          });
        }
      }, {
        key: "openCatalogSelector",
        value: function openCatalogSelector() {
          var _this22 = this;
          var oldCatalogs = this.addCommonToCatalog(this.contentForm.controls.catalogPaths.value);
          var dialogRef = this.dialog.open(_catalog_select_catalog_select_component__WEBPACK_IMPORTED_MODULE_18__["CatalogSelectComponent"], {
            width: '70%',
            maxHeight: '90vh',
            data: JSON.parse(JSON.stringify(oldCatalogs))
          });
          dialogRef.afterClosed().subscribe(function (response) {
            // const catalogs = this.removeCommonFromCatalog(response)
            _this22.contentForm.controls.catalogPaths.setValue(response);
          });
        }
      }, {
        key: "removeSkill",
        value: function removeSkill(skill) {
          var index = this.selectedSkills.indexOf(skill);
          this.selectedSkills.splice(index, 1);
        }
        // removeCatalog(index: number) {
        //   const catalogs = this.contentForm.controls.catalogPaths.value
        //   catalogs.splice(index, 1)
        //   this.contentForm.controls.catalogPaths.setValue(catalogs)
        // }
        // removeCommonFromCatalog(catalogs: string[]): string[] {
        //   const newCatalog: any[] = []
        //   catalogs.forEach(catalog => {
        //     let start = 0
        //     let end = 0
        //     start = catalog.indexOf('>')
        //     end = catalog.length
        //     newCatalog.push(catalog.slice(start + 1, end))
        //   })
        //   return newCatalog
        // }
      }, {
        key: "copyData",
        value: function copyData(type) {
          var selBox = document.createElement('textarea');
          selBox.style.position = 'fixed';
          selBox.style.left = '0';
          selBox.style.top = '0';
          selBox.style.opacity = '0';
          if (type === 'keyword') {
            selBox.value = this.contentForm.controls.keywords.value;
          } else if (type === 'previewUrl') {
            selBox.value = // tslint:disable-next-line: max-line-length
            "".concat(window.location.origin, "/viewer/").concat(Object(_ws_widget_collection_src_public_api__WEBPACK_IMPORTED_MODULE_6__["VIEWER_ROUTE_FROM_MIME"])(this.contentForm.controls.mimeType.value), "/").concat(this.contentMeta.identifier, "?preview=true");
          }
          document.body.appendChild(selBox);
          selBox.focus();
          selBox.select();
          document.execCommand('copy');
          document.body.removeChild(selBox);
          this.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_12__["NotificationComponent"], {
            data: {
              type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_10__["Notify"].COPY
            },
            duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_9__["NOTIFICATION_TIME"] * 1000
          });
        }
      }, {
        key: "addCommonToCatalog",
        value: function addCommonToCatalog(catalogs) {
          var newCatalog = [];
          catalogs.forEach(function (catalog) {
            var prefix = 'Common>';
            if (catalog.indexOf(prefix) > -1) {
              newCatalog.push(catalog);
            } else {
              newCatalog.push(prefix.concat(catalog));
            }
          });
          return newCatalog;
        }
      }]);
      return EditMetaComponent;
    }();
    EditMetaComponent.ctorParameters = function () {
      return [{
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"]
      }, {
        type: _services_upload_service__WEBPACK_IMPORTED_MODULE_17__["UploadService"]
      }, {
        type: _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_5__["MatSnackBar"]
      }, {
        type: _angular_material_dialog__WEBPACK_IMPORTED_MODULE_4__["MatDialog"]
      }, {
        type: _ws_author_src_lib_routing_modules_editor_services_editor_service__WEBPACK_IMPORTED_MODULE_14__["EditorService"]
      }, {
        type: _ws_author_src_lib_routing_modules_editor_services_editor_content_service__WEBPACK_IMPORTED_MODULE_13__["EditorContentService"]
      }, {
        type: _ws_widget_utils__WEBPACK_IMPORTED_MODULE_7__["ConfigurationsService"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"]
      }, {
        type: _app_src_lib_routes_profile_routes_interest_services_interest_service__WEBPACK_IMPORTED_MODULE_16__["InterestService"]
      }, {
        type: _services_loader_service__WEBPACK_IMPORTED_MODULE_21__["LoaderService"]
      }, {
        type: _services_init_service__WEBPACK_IMPORTED_MODULE_20__["AuthInitService"]
      }, {
        type: _modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_19__["AccessControlService"]
      }];
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])()], EditMetaComponent.prototype, "data", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], EditMetaComponent.prototype, "isSubmitPressed", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], EditMetaComponent.prototype, "nextAction", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], EditMetaComponent.prototype, "stage", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], EditMetaComponent.prototype, "type", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])()], EditMetaComponent.prototype, "parentContent", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('creatorContactsView', {
      "static": false
    })], EditMetaComponent.prototype, "creatorContactsView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('trackContactsView', {
      "static": false
    })], EditMetaComponent.prototype, "trackContactsView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('publisherDetailsView', {
      "static": false
    })], EditMetaComponent.prototype, "publisherDetailsView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('editorsView', {
      "static": false
    })], EditMetaComponent.prototype, "editorsView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('creatorDetailsView', {
      "static": false
    })], EditMetaComponent.prototype, "creatorDetailsView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('audienceView', {
      "static": false
    })], EditMetaComponent.prototype, "audienceView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('jobProfileView', {
      "static": false
    })], EditMetaComponent.prototype, "jobProfileView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('regionView', {
      "static": false
    })], EditMetaComponent.prototype, "regionView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('accessPathsView', {
      "static": false
    })], EditMetaComponent.prototype, "accessPathsView", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('keywordsSearch', {
      "static": true
    })], EditMetaComponent.prototype, "keywordsSearch", void 0);
    EditMetaComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"])({
      selector: 'ws-auth-edit-meta',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./edit-meta.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./edit-meta.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.scss"))["default"]]
    })], EditMetaComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.scss":
  /*!************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.scss ***!
    \************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditorBaseBaseComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvZWRpdG9yL2Jhc2UvYmFzZS5jb21wb25lbnQuc2NzcyJ9 */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.ts":
  /*!**********************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.ts ***!
    \**********************************************************************************************************/
  /*! exports provided: BaseComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditorBaseBaseComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "BaseComponent", function () {
      return BaseComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");

    // import { FormGroup } from '@angular/forms'
    // import { MatDialog, MatSnackBar } from '@angular/material'
    // import { ActivatedRoute, Router } from '@angular/router'
    // import { NOTIFICATION_TIME } from '@ws/author/src/lib/constants/constant'
    // import { Notify } from '@ws/author/src/lib/constants/notificationMessage'
    // import { IActionButton, IActionButtonConfig } from '@ws/author/src/lib/interface/action-button'
    // import { NSApiRequest } from '@ws/author/src/lib/interface/apiRequest'
    // import { IAuthSteps } from '@ws/author/src/lib/interface/auth-stepper'
    // import { NSContent } from '@ws/author/src/lib/interface/content'
    // import { CommentsDialogComponent } from '@ws/author/src/lib/modules/shared/components/comments-dialog/comments-dialog.component'
    // import { ConfirmDialogComponent } from '@ws/author/src/lib/modules/shared/components/confirm-dialog/confirm-dialog.component'
    // import { ErrorParserComponent } from '@ws/author/src/lib/modules/shared/components/error-parser/error-parser.component'
    // import { NotificationComponent } from '@ws/author/src/lib/modules/shared/components/notification/notification.component'
    // import { EditorContentService } from '@ws/author/src/lib/routing/modules/editor/services/editor-content.service'
    // import { EditorService } from '@ws/author/src/lib/routing/modules/editor/services/editor.service'
    // import { AuthInitService } from '@ws/author/src/lib/services/init.service'
    // import { LoaderService } from '@ws/author/src/lib/services/loader.service'
    // import { of, Subscription } from 'rxjs'
    // import { mergeMap, tap } from 'rxjs/operators'
    // import { VIEWER_ROUTE_FROM_MIME } from '../../../../../../../../../../../../library/ws-widget/collection/src/public-api'
    var BaseComponent = /*#__PURE__*/function () {
      function BaseComponent() {
        _classCallCheck(this, BaseComponent);
      }
      _createClass(BaseComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {}
      }]);
      return BaseComponent;
    }();
    BaseComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-base',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./base.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./base.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.scss"))["default"]]
    })], BaseComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.scss":
  /*!****************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.scss ***!
    \****************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditorEditMetaV2EditMetaV2ComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvZWRpdG9yL2VkaXQtbWV0YS12Mi9lZGl0LW1ldGEtdjIuY29tcG9uZW50LnNjc3MifQ== */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.ts":
  /*!**************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.ts ***!
    \**************************************************************************************************************************/
  /*! exports provided: EditMetaV2Component */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsEditorEditMetaV2EditMetaV2ComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditMetaV2Component", function () {
      return EditMetaV2Component;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    var EditMetaV2Component = /*#__PURE__*/function () {
      function EditMetaV2Component() {
        _classCallCheck(this, EditMetaV2Component);
      }
      _createClass(EditMetaV2Component, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);
      return EditMetaV2Component;
    }();
    EditMetaV2Component = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-edit-meta-v2',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./edit-meta-v2.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./edit-meta-v2.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.scss"))["default"]]
    })], EditMetaV2Component);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.scss":
  /*!*************************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.scss ***!
    \*************************************************************************************************************************/
  /*! exports provided: default */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsPlainCkeditorPlainCkeditorComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */
    __webpack_exports__["default"] = "::ng-deep .cke_button__uploadimage_icon {\n  background-position: 0 -672px !important;\n}\n\n::ng-deep .cke_button__uploadfile_icon {\n  background-position: 0 -1176px !important;\n}\n\n::ng-deep .cke_button__blank_icon {\n  background-position: 0 -782px !important;\n}\n\n::ng-deep #cke_1_contents {\n  min-height: 100px !important;\n}\n\n::ng-deep.cke_dialog_container {\n  z-index: 10010 !important;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3NvbmFzaGFqdS9WaWRlb3Mvc3BoZXJlLW1vYmlsZS9wcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvcGxhaW4tY2tlZGl0b3IvcGxhaW4tY2tlZGl0b3IuY29tcG9uZW50LnNjc3MiLCJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvcGxhaW4tY2tlZGl0b3IvcGxhaW4tY2tlZGl0b3IuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUE7RUFDRSx3Q0FBQTtBQ0RGOztBRElBO0VBQ0UseUNBQUE7QUNERjs7QURJQTtFQUNFLHdDQUFBO0FDREY7O0FESUE7RUFDRSw0QkFBQTtBQ0RGOztBRElBO0VBQ0UseUJBQUE7QUNERiIsImZpbGUiOiJwcm9qZWN0L3dzL2F1dGhvci9zcmMvbGliL3JvdXRpbmcvbW9kdWxlcy9lZGl0b3Ivc2hhcmVkL2NvbXBvbmVudHMvcGxhaW4tY2tlZGl0b3IvcGxhaW4tY2tlZGl0b3IuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyJAaW1wb3J0ICdzdHlsZXMvX3dzLW1peGlucy5zY3NzJztcblxuOjpuZy1kZWVwIC5ja2VfYnV0dG9uX191cGxvYWRpbWFnZV9pY29uIHtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtNjcycHggIWltcG9ydGFudDtcbn1cblxuOjpuZy1kZWVwIC5ja2VfYnV0dG9uX191cGxvYWRmaWxlX2ljb24ge1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIC0xMTc2cHggIWltcG9ydGFudDtcbn1cblxuOjpuZy1kZWVwIC5ja2VfYnV0dG9uX19ibGFua19pY29uIHtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtNzgycHggIWltcG9ydGFudDtcbn1cblxuOjpuZy1kZWVwICNja2VfMV9jb250ZW50cyB7XG4gIG1pbi1oZWlnaHQ6IDEwMHB4ICFpbXBvcnRhbnQ7XG59XG5cbjo6bmctZGVlcC5ja2VfZGlhbG9nX2NvbnRhaW5lciB7XG4gIHotaW5kZXg6IDEwMDEwICFpbXBvcnRhbnQ7XG59XG4iLCI6Om5nLWRlZXAgLmNrZV9idXR0b25fX3VwbG9hZGltYWdlX2ljb24ge1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIC02NzJweCAhaW1wb3J0YW50O1xufVxuXG46Om5nLWRlZXAgLmNrZV9idXR0b25fX3VwbG9hZGZpbGVfaWNvbiB7XG4gIGJhY2tncm91bmQtcG9zaXRpb246IDAgLTExNzZweCAhaW1wb3J0YW50O1xufVxuXG46Om5nLWRlZXAgLmNrZV9idXR0b25fX2JsYW5rX2ljb24ge1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIC03ODJweCAhaW1wb3J0YW50O1xufVxuXG46Om5nLWRlZXAgI2NrZV8xX2NvbnRlbnRzIHtcbiAgbWluLWhlaWdodDogMTAwcHggIWltcG9ydGFudDtcbn1cblxuOjpuZy1kZWVwLmNrZV9kaWFsb2dfY29udGFpbmVyIHtcbiAgei1pbmRleDogMTAwMTAgIWltcG9ydGFudDtcbn0iXX0= */";

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.ts":
  /*!***********************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.ts ***!
    \***********************************************************************************************************************/
  /*! exports provided: PlainCKEditorComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsPlainCkeditorPlainCkeditorComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "PlainCKEditorComponent", function () {
      return PlainCKEditorComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/material/snack-bar */"./node_modules/@angular/material/esm2015/snack-bar.js");
    /* harmony import */
    var _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @ws/author/src/lib/constants/apiEndpoints */"./project/ws/author/src/lib/constants/apiEndpoints.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @ws/author/src/lib/constants/constant */"./project/ws/author/src/lib/constants/constant.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @ws/author/src/lib/constants/notificationMessage */"./project/ws/author/src/lib/constants/notificationMessage.ts");
    /* harmony import */
    var _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @ws/author/src/lib/constants/upload */"./project/ws/author/src/lib/constants/upload.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/components/notification/notification.component */"./project/ws/author/src/lib/modules/shared/components/notification/notification.component.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/services/access-control.service */"./project/ws/author/src/lib/modules/shared/services/access-control.service.ts");
    /* harmony import */
    var _ws_author_src_lib_routing_modules_editor_shared_services_upload_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! @ws/author/src/lib/routing/modules/editor/shared/services/upload.service */"./project/ws/author/src/lib/routing/modules/editor/shared/services/upload.service.ts");
    /* harmony import */
    var _ws_author_src_lib_services_loader_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @ws/author/src/lib/services/loader.service */"./project/ws/author/src/lib/services/loader.service.ts");
    /* harmony import */
    var library_ws_widget_utils_src_lib_services_configurations_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! library/ws-widget/utils/src/lib/services/configurations.service */"./library/ws-widget/utils/src/lib/services/configurations.service.ts");

    // tslint:disable-next-line: max-line-length

    var PlainCKEditorComponent = /*#__PURE__*/function () {
      function PlainCKEditorComponent(snackBar, uploadService, configurationSvc, accessControlSvc, loaderService, cdr) {
        _classCallCheck(this, PlainCKEditorComponent);
        this.snackBar = snackBar;
        this.uploadService = uploadService;
        this.configurationSvc = configurationSvc;
        this.accessControlSvc = accessControlSvc;
        this.loaderService = loaderService;
        this.cdr = cdr;
        this.downloadRegex = new RegExp("(https://.*?/content-store/.*?)(\\)?\\\\?['\"])", 'gm');
        this.uploadRegex = new RegExp("".concat(_ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_3__["AUTHORING_CONTENT_BASE"], "(.*?)(\\)?\\\\?['\"])"), 'gm');
        this.downloadPartialImgRegex = RegExp(" src=s*['\"](.*?)['\"]", 'gm');
        this.downloadPartialAncRegex = RegExp(" href=s*['\"](.*?)['\"]", 'gm');
        this.doRegex = true;
        this.doPartialRegex = false;
        this.html = '';
        this.id = '';
        this.location = _ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_3__["CONTENT_BASE_WEBHOST_ASSETS"];
        this.value = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.imageName = 'Insert Image';
        this.fileName = 'Upload File';
        this.blankName = 'Add Blank';
      }
      _createClass(PlainCKEditorComponent, [{
        key: "content",
        set: function set(value) {
          if (this.doPartialRegex) {
            var reg = "".concat(document.location.origin, "/content-store/\n              ").concat(this.accessControlSvc.rootOrg, "/").concat(this.accessControlSvc.org, "/Public/\n              ").concat(this.id, "/web-hosted/assets");
            this.html = value.replace(this.downloadPartialImgRegex, " src=\"".concat(reg, "$1\"")).replace(this.downloadPartialAncRegex, " href=\"".concat(reg, "$1\"")).replace(this.downloadRegex, this.regexDownloadReplace);
          } else if (this.doRegex) {
            this.html = value.replace(this.downloadRegex, this.regexDownloadReplace);
          } else {
            this.html = value;
          }
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this23 = this;
          this.initiateConfig();
          this.makeTargetAsBlank();
          this.allowAdditionalContents();
          this.configurationSvc.prefChangeNotifier.subscribe(function () {
            var theme = _this23.theme;
            if (_this23.config && _this23.config.uiColor !== theme) {
              _this23.config.uiColor = theme;
              _this23.editor.instance.setUiColor(_this23.theme);
            }
          });
        }
      }, {
        key: "regexUploadReplace",
        value: function regexUploadReplace() {
          var _str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var group1 = arguments.length > 1 ? arguments[1] : undefined;
          var group2 = arguments.length > 2 ? arguments[2] : undefined;
          return "".concat(decodeURIComponent(group1)).concat(group2);
        }
      }, {
        key: "regexDownloadReplace",
        value: function regexDownloadReplace() {
          var _str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var group1 = arguments.length > 1 ? arguments[1] : undefined;
          var group2 = arguments.length > 2 ? arguments[2] : undefined;
          return "".concat(_ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_3__["AUTHORING_CONTENT_BASE"]).concat(encodeURIComponent(group1)).concat(group2);
        }
      }, {
        key: "initiateConfig",
        value: function initiateConfig() {
          this.config = {
            skin: 'moono',
            uiColor: this.theme,
            language: this.accessControlSvc.locale,
            toolbarGroups: [{
              name: 'basicstyles',
              groups: ['basicstyles', 'cleanup']
            }, {
              name: 'paragraph',
              groups: ['list', 'indent', 'blocks', 'align', 'bidi', 'paragraph']
            }, {
              name: 'clipboard',
              groups: ['clipboard', 'undo']
            }, {
              name: 'document',
              groups: ['mode', 'document', 'doctools']
            }, {
              name: 'editing',
              groups: ['find', 'selection', 'editing']
            }, {
              name: 'links',
              groups: ['links']
            }, {
              name: 'insert',
              groups: ['insert']
            }, '/', {
              name: 'styles',
              groups: ['styles']
            }, {
              name: 'colors',
              groups: ['colors']
            }, {
              name: 'tools',
              groups: ['tools']
            }],
            allowedContent: true,
            extraAllowedContent: 'a[!href,download,document-href,class]',
            removeButtons: 'Cut,Copy,Paste,PasteText,PasteFromWord,Save,NewPage,Preview,Print,' + 'Templates,Scayt,Form,Checkbox,Radio,TextField,Textarea,Select,Button,HiddenField,ImageButton' + ',Smiley,PageBreak,Flash,About,CreateDiv,Anchor,SelectAll,Image',
            disableNativeSpellChecker: true,
            removeDialogTabs: 'image:advanced;link:advanced',
            format_tags: 'p;h1;h2;h3;h4;h5;h6;div',
            forcePasteAsPlainText: false,
            image2_alignClasses: ['image-align-left', 'image-align-center', 'image-align-right'],
            image2_captionedClass: 'image-captioned',
            stylesSet: [{
              name: 'Narrow image',
              type: 'widget',
              widget: 'image',
              attributes: {
                "class": 'image-narrow'
              }
            }, {
              name: 'Wide image',
              type: 'widget',
              widget: 'image',
              attributes: {
                "class": 'image-wide'
              }
            }]
          };
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.subscription) {
            this.subscription.unsubscribe();
          }
          this.cdr.detach();
        }
      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.imageName = this.image.nativeElement.innerHTML;
          this.fileName = this.file.nativeElement.innerHTML;
          this.blankName = this.blank.nativeElement.innerHTML;
          this.cdr.detectChanges();
        }
      }, {
        key: "onContentChanged",
        value: function onContentChanged() {
          if (this.doPartialRegex) {
            this.value.emit(this.html.replace(this.uploadRegex, this.regexUploadReplace).replace(/ src=\s*['"].*?\/content-store\/(.*?)['"]/gm, ' src="$1"').replace(/ href=\s*['"].*?\/content-store\/(.*?)['"]/gm, ' href="$1"'));
          } else if (this.doRegex) {
            this.value.emit(this.html.replace(this.uploadRegex, this.regexUploadReplace));
          } else {
            this.value.emit(this.html);
          }
        }
      }, {
        key: "makeTargetAsBlank",
        value: function makeTargetAsBlank() {
          CKEDITOR.on('dialogDefinition', function (ev) {
            try {
              var dialogName = ev.data.name;
              var dialogDefinition = ev.data.definition;
              if (dialogName === 'link') {
                var informationTab = dialogDefinition.getContents('target');
                var targetField = informationTab.get('linkTargetType');
                targetField['default'] = '_blank';
              }
            } catch (exception) {
              // //console.log('Error ' + ev.message)
            }
          });
        }
      }, {
        key: "allowAdditionalContents",
        value: function allowAdditionalContents() {
          CKEDITOR.dtd['a']['div'] = 1;
          CKEDITOR.dtd['a']['p'] = 1;
          CKEDITOR.dtd['a']['i'] = 1;
          CKEDITOR.dtd['a']['span'] = 1;
        }
      }, {
        key: "addImageUploadBtn",
        value: function addImageUploadBtn() {
          var _this24 = this;
          var input = document.createElement('input');
          input.setAttribute('type', 'file');
          input.setAttribute('accept', _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_6__["IMAGE_SUPPORT_TYPES"].toString());
          input.style.display = 'none';
          input.addEventListener('change', function (e) {
            var file = e.target.files[0];
            if (file) {
              var fileExtension = file.name.toLowerCase().split('.');
              if (_ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_6__["IMAGE_SUPPORT_TYPES"].indexOf(".".concat(fileExtension[fileExtension.length - 1])) > -1) {
                if (file.size > _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_6__["IMAGE_MAX_SIZE"]) {
                  _this24.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                    data: {
                      type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].SIZE_ERROR
                    },
                    duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                  });
                  input.remove();
                  return;
                }
                var form = new FormData();
                form.set('content', file, file.name.replace(/[^A-Za-z0-9.]/g, ''));
                _this24.loaderService.changeLoad.next(true);
                _this24.uploadService.upload(form, {
                  contentId: _this24.id,
                  contentType: _this24.location
                }).subscribe(function (data) {
                  if (data.code) {
                    var url = data.artifactURL;
                    if (!_this24.doRegex) {
                      url = "/".concat(url.split('/').slice(3).join('/'));
                    }
                    _this24.editor.instance.insertHtml("<img alt='' src='".concat(_ws_author_src_lib_constants_apiEndpoints__WEBPACK_IMPORTED_MODULE_3__["AUTHORING_CONTENT_BASE"]).concat(encodeURIComponent(url), "'></img>"));
                    _this24.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                      data: {
                        type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].UPLOAD_SUCCESS
                      },
                      duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                    });
                    input.remove();
                    _this24.loaderService.changeLoad.next(false);
                  }
                }, function () {
                  _this24.loaderService.changeLoad.next(false);
                  _this24.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                    data: {
                      type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].UPLOAD_FAIL
                    },
                    duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                  });
                  input.remove();
                });
              } else {
                _this24.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                  data: {
                    type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].INVALID_FORMAT
                  },
                  duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                });
                input.remove();
                return;
              }
            }
          }, false);
          document.body.appendChild(input);
          input.click();
        }
      }, {
        key: "addFileUploadBtn",
        value: function addFileUploadBtn() {
          var _this25 = this;
          var input = document.createElement('input');
          input.setAttribute('type', 'file');
          input.setAttribute('accept', '.zip');
          input.style.display = 'none';
          input.addEventListener('change', function (e) {
            var file = e.target.files[0];
            if (file) {
              if (file.name.toLowerCase().endsWith('.zip')) {
                if (file.size > _ws_author_src_lib_constants_upload__WEBPACK_IMPORTED_MODULE_6__["FILE_MAX_SIZE"]) {
                  _this25.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                    data: {
                      type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].SIZE_ERROR
                    },
                    duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                  });
                  input.remove();
                  return;
                }
                var form = new FormData();
                form.set('content', file, file.name.replace(/[^A-Za-z0-9.]/g, ''));
                _this25.loaderService.changeLoad.next(true);
                _this25.uploadService.upload(form, {
                  contentId: _this25.id,
                  contentType: _this25.location
                }).subscribe(function (data) {
                  if (data.code) {
                    var url = data.artifactURL;
                    if (_this25.doRegex) {
                      url = "/".concat(url.split('/').slice(3).join('/'));
                    }
                    _this25.editor.instance.insertHtml("<a href='".concat(url, "' download>Click here to download</a>"));
                    _this25.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                      data: {
                        type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].UPLOAD_SUCCESS
                      },
                      duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                    });
                    input.remove();
                    _this25.loaderService.changeLoad.next(false);
                  }
                }, function () {
                  _this25.loaderService.changeLoad.next(false);
                  _this25.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                    data: {
                      type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].UPLOAD_FAIL
                    },
                    duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                  });
                  input.remove();
                });
              } else {
                input.remove();
                _this25.snackBar.openFromComponent(_ws_author_src_lib_modules_shared_components_notification_notification_component__WEBPACK_IMPORTED_MODULE_7__["NotificationComponent"], {
                  data: {
                    type: _ws_author_src_lib_constants_notificationMessage__WEBPACK_IMPORTED_MODULE_5__["Notify"].INVALID_FORMAT
                  },
                  duration: _ws_author_src_lib_constants_constant__WEBPACK_IMPORTED_MODULE_4__["NOTIFICATION_TIME"] * 1000
                });
                return;
              }
            }
          }, false);
          document.body.appendChild(input);
          input.click();
        }
      }, {
        key: "addBlankBtn",
        value: function addBlankBtn() {
          this.editor.instance.insertHtml(' <input style="border-style:none none solid none"> ');
        }
      }, {
        key: "theme",
        get: function get() {
          var color = getComputedStyle(document.body).backgroundColor.replace('rgba', '').replace('rgb', '').replace('(', '').replace(')', '').split(',');
          return (
            // tslint:disable-next-line: prefer-template
            '#' + ('0' + parseInt(color[0], 10).toString(16)).slice(-2) + ('0' + parseInt(color[1], 10).toString(16)).slice(-2) + ('0' + parseInt(color[2], 10).toString(16)).slice(-2)
          );
        }
      }]);
      return PlainCKEditorComponent;
    }();
    PlainCKEditorComponent.ctorParameters = function () {
      return [{
        type: _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_2__["MatSnackBar"]
      }, {
        type: _ws_author_src_lib_routing_modules_editor_shared_services_upload_service__WEBPACK_IMPORTED_MODULE_9__["UploadService"]
      }, {
        type: library_ws_widget_utils_src_lib_services_configurations_service__WEBPACK_IMPORTED_MODULE_11__["ConfigurationsService"]
      }, {
        type: _ws_author_src_lib_modules_shared_services_access_control_service__WEBPACK_IMPORTED_MODULE_8__["AccessControlService"]
      }, {
        type: _ws_author_src_lib_services_loader_service__WEBPACK_IMPORTED_MODULE_10__["LoaderService"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PlainCKEditorComponent.prototype, "doRegex", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PlainCKEditorComponent.prototype, "doPartialRegex", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PlainCKEditorComponent.prototype, "content", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PlainCKEditorComponent.prototype, "id", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PlainCKEditorComponent.prototype, "location", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], PlainCKEditorComponent.prototype, "value", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('editor', {
      "static": false
    })], PlainCKEditorComponent.prototype, "editor", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('uploadImage', {
      "static": false
    })], PlainCKEditorComponent.prototype, "image", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('uploadFile', {
      "static": false
    })], PlainCKEditorComponent.prototype, "file", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('addBlank', {
      "static": false
    })], PlainCKEditorComponent.prototype, "blank", void 0);
    PlainCKEditorComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-plain-ckeditor',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! raw-loader!./plain-ckeditor.component.html */"./node_modules/raw-loader/dist/cjs.js!./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__( /*! ./plain-ckeditor.component.scss */"./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.scss"))["default"]]
    })], PlainCKEditorComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/my-own.component.ts":
  /*!*****************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/my-own.component.ts ***!
    \*****************************************************************************************************************/
  /*! exports provided: MatQuillComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsRichTextEditorMyOwnComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "MatQuillComponent", function () {
      return MatQuillComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/forms */"./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */
    var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/material/core */"./node_modules/@angular/material/esm2015/core.js");
    /* harmony import */
    var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @angular/material/form-field */"./node_modules/@angular/material/esm2015/form-field.js");
    /* harmony import */
    var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! rxjs */"./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */
    var _quill_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ./quill.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/quill.component.ts");
    var MatQuillComponent_1;
    var nextUniqueId = 0;
    var MatQuillComponent = MatQuillComponent_1 = /*#__PURE__*/function (_quill_component__WEB) {
      _inherits(MatQuillComponent, _quill_component__WEB);
      var _super = _createSuper(MatQuillComponent);
      function MatQuillComponent(el, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
        var _this26;
        _classCallCheck(this, MatQuillComponent);
        _this26 = _super.call(this, el);
        _this26._defaultErrorStateMatcher = _defaultErrorStateMatcher;
        _this26._parentForm = _parentForm;
        _this26._parentFormGroup = _parentFormGroup;
        _this26.ngControl = ngControl;
        _this26.placeholder = '';
        _this26.required = false;
        _this26.errorStateMatcher = new _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["ErrorStateMatcher"]();
        _this26.errorState = false;
        _this26.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
        _this26.shouldLabelFloat = true;
        _this26._disabled = false;
        _this26._id = '';
        _this26._uid = "wa-quill-".concat(nextUniqueId + 1);
        if (_this26.ngControl !== null) {
          _this26.ngControl.valueAccessor = _assertThisInitialized(_this26);
        }
        return _this26;
      }
      _createClass(MatQuillComponent, [{
        key: "value",
        get: function get() {
          return this.getValue();
        },
        set: function set(value) {
          if (this.editor) {
            if (value !== this.value) {
              this.editor.setContents(value);
              this.stateChanges.next();
            }
          }
        }
      }, {
        key: "disabled",
        get: function get() {
          if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
          }
          return this._disabled;
        },
        set: function set(disabled) {
          this._disabled = disabled;
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        },
        set: function set(id) {
          this._id = id || this._uid;
        }
      }, {
        key: "empty",
        get: function get() {
          return typeof this.value === 'undefined';
        }
      }, {
        key: "focused",
        get: function get() {
          if (this.editor) {
            return this.editor.hasFocus();
          }
          return false;
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (typeof changes['value'] !== 'undefined' || typeof changes['required'] !== 'undefined') {
            this.stateChanges.next();
          }
        }
      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this.ngControl) {
            this.updateErrorState();
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.stateChanges.complete();
        }
      }, {
        key: "onContainerClick",
        value: function onContainerClick() {
          if (!this.focused) {
            this.focus();
          }
        }
      }, {
        key: "focus",
        value: function focus() {
          if (this.editor) {
            this.editor.focus();
            this.stateChanges.next();
          }
        }
      }, {
        key: "updateErrorState",
        value: function updateErrorState() {
          var oldState = this.errorState;
          var parent = this._parentFormGroup || this._parentForm;
          var matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;
          var control = this.ngControl ? this.ngControl.control : null;
          var newState = matcher.isErrorState(control, parent);
          if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
          }
        }
      }, {
        key: "setDescribedByIds",
        value: function setDescribedByIds() {}
      }]);
      return MatQuillComponent;
    }(_quill_component__WEBPACK_IMPORTED_MODULE_6__["QuillComponent"]);
    MatQuillComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["ErrorStateMatcher"]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgForm"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormGroupDirective"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], MatQuillComponent.prototype, "placeholder", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], MatQuillComponent.prototype, "required", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], MatQuillComponent.prototype, "value", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], MatQuillComponent.prototype, "disabled", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], MatQuillComponent.prototype, "id", null);
    MatQuillComponent = MatQuillComponent_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-root-mat-quill',
      template: '',
      providers: [{
        provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_4__["MatFormFieldControl"],
        useExisting: MatQuillComponent_1
      }]
    }), tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](2, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"])()), tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](3, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"])()), tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](4, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"])()), tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](4, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"])())], MatQuillComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/quill.component.ts":
  /*!****************************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/quill.component.ts ***!
    \****************************************************************************************************************/
  /*! exports provided: QuillComponent */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedComponentsRichTextEditorQuillComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "QuillComponent", function () {
      return QuillComponent;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/forms */"./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */
    var quill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! quill */"./node_modules/quill/dist/quill.js");
    /* harmony import */
    var quill__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(quill__WEBPACK_IMPORTED_MODULE_3__);
    var QuillComponent_1;
    var QuillComponent = QuillComponent_1 = /*#__PURE__*/function () {
      function QuillComponent($el) {
        _classCallCheck(this, QuillComponent);
        this.$el = $el;
        this.theme = 'snow';
        this.options = null;
        this.onTouched = function () {};
        this.onChange = function (_) {};
      }
      _createClass(QuillComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this27 = this;
          var toolbarOptions = [[{
            font: []
          }], [{
            header: [1, 2, 3, 4, 5, 6, false]
          }], ['bold', 'italic', 'underline', 'strike'], ['blockquote', 'code-block'], [{
            align: []
          }], [{
            list: 'ordered'
          }, {
            list: 'bullet'
          }], [{
            script: 'sub'
          }, {
            script: 'super'
          }],
          // [{ 'indent': '-1' }, { 'indent': '+1' }],          // outdent/indent
          [{
            direction: 'rtl'
          }],
          // [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
          [{
            color: []
          }, {
            background: []
          }], ['link', 'image', 'video', 'formula'], ['clean']];
          var options = Object.assign({}, this.options || {}, {
            modules: {
              toolbar: toolbarOptions
            }
          });
          if (typeof options.theme === 'undefined') {
            options.theme = this.theme;
          }
          this.editor = new quill__WEBPACK_IMPORTED_MODULE_3___default.a(this.$el.nativeElement, options);
          if (typeof this.defaultContents !== 'undefined') {
            // this.editor.setContents(this.defaultContents)
            var editor = document.getElementsByClassName('ql-editor');
            if (editor && editor[0]) {
              editor[0].innerHTML = this.defaultContents;
            }
          }
          this.editor.on('text-change', function () {
            _this27.onChange(_this27.getValue());
          });
          this.$el.nativeElement.querySelector('.ql-editor').addEventListener('blur', function () {
            _this27.onTouched();
          });
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {}
      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          if (typeof this.defaultContents !== 'undefined') {
            // this.editor.setContents(this.defaultContents)
            var editor = document.getElementsByClassName('ql-editor');
            if (editor && editor[0]) {
              editor[0].innerHTML = this.defaultContents;
            }
          }
        }
      }, {
        key: "writeValue",
        value: function writeValue(contents) {
          if (this.editor) {
            var editor = document.getElementsByClassName('ql-editor');
            editor[0].innerHTML = contents;
            // this.editor.setContents(contents)
          } else {
            this.defaultContents = contents;
          }
        }
      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this.onChange = fn;
        }
      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this.onTouched = fn;
        }
      }, {
        key: "getValue",
        value: function getValue() {
          if (!this.editor) {
            return undefined;
          }
          // const contents: any = this.editor.getContents()
          var contents;
          var editor = document.getElementsByClassName('ql-editor');
          if (editor) {
            contents = editor[0].innerHTML;
          }
          // if (this.isEmpty(contents)) {
          //   return undefined
          // }
          if (!contents) {
            return undefined;
          }
          return contents;
        }
      }, {
        key: "isEmpty",
        value: function isEmpty(contents) {
          if (contents.ops.length > 1) {
            return false;
          }
          var opsTypes = Object.keys(contents.ops[0]);
          if (opsTypes.length > 1) {
            return false;
          }
          if (opsTypes[0] !== 'insert') {
            return false;
          }
          if (contents.ops[0].insert !== '\n') {
            return false;
          }
          return true;
        }
      }]);
      return QuillComponent;
    }();
    QuillComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], QuillComponent.prototype, "theme", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], QuillComponent.prototype, "options", void 0);
    QuillComponent = QuillComponent_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'ws-auth-root-ws-quill',
      template: '',
      providers: [{
        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
        useExisting: QuillComponent_1,
        multi: true
      }]
    })], QuillComponent);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/directives/drag-drop.directive.ts":
  /*!***************************************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/directives/drag-drop.directive.ts ***!
    \***************************************************************************************************/
  /*! exports provided: DragDropDirective */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedDirectivesDragDropDirectiveTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "DragDropDirective", function () {
      return DragDropDirective;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    var DragDropDirective = /*#__PURE__*/function () {
      function DragDropDirective() {
        _classCallCheck(this, DragDropDirective);
        this.fileDropped = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.opacity = '1';
      }
      // Dragover listener
      _createClass(DragDropDirective, [{
        key: "onDragOver",
        value: function onDragOver(evt) {
          evt.preventDefault();
          evt.stopPropagation();
          this.opacity = '0.4';
        }
        // Dragleave listener
      }, {
        key: "onDragLeave",
        value: function onDragLeave(evt) {
          evt.preventDefault();
          evt.stopPropagation();
          this.opacity = '1.0';
        }
        // Drop listener
      }, {
        key: "ondrop",
        value: function ondrop(evt) {
          evt.preventDefault();
          evt.stopPropagation();
          var files = evt.dataTransfer.files[0];
          this.opacity = '1.0';
          if (files) {
            this.fileDropped.emit(files);
          }
        }
      }]);
      return DragDropDirective;
    }();
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], DragDropDirective.prototype, "fileDropped", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('style.opacity')], DragDropDirective.prototype, "opacity", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('dragover', ['$event'])], DragDropDirective.prototype, "onDragOver", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('dragleave', ['$event'])], DragDropDirective.prototype, "onDragLeave", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('drop', ['$event'])], DragDropDirective.prototype, "ondrop", null);
    DragDropDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
      selector: '[wsAuthDragDrop]'
    })], DragDropDirective);

    /***/
  },

  /***/"./project/ws/author/src/lib/routing/modules/editor/shared/shared.module.ts":
  /*!**********************************************************************************!*\
    !*** ./project/ws/author/src/lib/routing/modules/editor/shared/shared.module.ts ***!
    \**********************************************************************************/
  /*! exports provided: EditorSharedModule */
  /***/
  function projectWsAuthorSrcLibRoutingModulesEditorSharedSharedModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "EditorSharedModule", function () {
      return EditorSharedModule;
    });
    /* harmony import */
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! tslib */"./node_modules/tslib/tslib.es6.js");
    /* harmony import */
    var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/common */"./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */
    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/core */"./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */
    var _ws_widget_collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @ws-widget/collection */"./library/ws-widget/collection/src/public-api.ts");
    /* harmony import */
    var _ws_widget_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @ws-widget/utils */"./library/ws-widget/utils/src/public-api.ts");
    /* harmony import */
    var _ws_author_src_lib_modules_shared_shared_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @ws/author/src/lib/modules/shared/shared.module */"./project/ws/author/src/lib/modules/shared/shared.module.ts");
    /* harmony import */
    var ng2_ace_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ng2-ace-editor */"./node_modules/ng2-ace-editor/index.js");
    /* harmony import */
    var _shared_components_catalog_select_catalog_select_module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! ../shared/components/catalog-select/catalog-select.module */"./project/ws/author/src/lib/routing/modules/editor/shared/components/catalog-select/catalog-select.module.ts");
    /* harmony import */
    var _components_ace_editor_ace_editor_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! ./components/ace-editor/ace-editor.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/ace-editor/ace-editor.component.ts");
    /* harmony import */
    var _components_auth_editor_action_buttons_auth_editor_action_buttons_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! ./components/auth-editor-action-buttons/auth-editor-action-buttons.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-editor-action-buttons/auth-editor-action-buttons.component.ts");
    /* harmony import */
    var _components_auth_language_select_bar_auth_language_select_bar_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! ./components/auth-language-select-bar/auth-language-select-bar.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-language-select-bar/auth-language-select-bar.component.ts");
    /* harmony import */
    var _components_auth_picker_auth_picker_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! ./components/auth-picker/auth-picker.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/auth-picker/auth-picker.component.ts");
    /* harmony import */
    var _components_edit_meta_edit_meta_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! ./components/edit-meta/edit-meta.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/edit-meta/edit-meta.component.ts");
    /* harmony import */
    var _components_plain_ckeditor_plain_ckeditor_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! ./components/plain-ckeditor/plain-ckeditor.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/plain-ckeditor/plain-ckeditor.component.ts");
    /* harmony import */
    var _components_rich_text_editor_my_own_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__( /*! ./components/rich-text-editor/my-own.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/my-own.component.ts");
    /* harmony import */
    var _components_rich_text_editor_quill_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__( /*! ./components/rich-text-editor/quill.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/rich-text-editor/quill.component.ts");
    /* harmony import */
    var _directives_drag_drop_directive__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__( /*! ./directives/drag-drop.directive */"./project/ws/author/src/lib/routing/modules/editor/shared/directives/drag-drop.directive.ts");
    /* harmony import */
    var _services_upload_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__( /*! ./services/upload.service */"./project/ws/author/src/lib/routing/modules/editor/shared/services/upload.service.ts");
    /* harmony import */
    var _components_editor_base_base_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__( /*! ./components/editor/base/base.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/base/base.component.ts");
    /* harmony import */
    var _components_editor_edit_meta_v2_edit_meta_v2_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__( /*! ./components/editor/edit-meta-v2/edit-meta-v2.component */"./project/ws/author/src/lib/routing/modules/editor/shared/components/editor/edit-meta-v2/edit-meta-v2.component.ts");

    // import { CKEditorModule } from 'ng2-ckeditor'

    var EditorSharedModule = /*#__PURE__*/_createClass(function EditorSharedModule() {
      _classCallCheck(this, EditorSharedModule);
    });
    EditorSharedModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"])({
      declarations: [_components_rich_text_editor_my_own_component__WEBPACK_IMPORTED_MODULE_14__["MatQuillComponent"], _components_rich_text_editor_quill_component__WEBPACK_IMPORTED_MODULE_15__["QuillComponent"], _components_plain_ckeditor_plain_ckeditor_component__WEBPACK_IMPORTED_MODULE_13__["PlainCKEditorComponent"], _components_edit_meta_edit_meta_component__WEBPACK_IMPORTED_MODULE_12__["EditMetaComponent"], _directives_drag_drop_directive__WEBPACK_IMPORTED_MODULE_16__["DragDropDirective"], _components_ace_editor_ace_editor_component__WEBPACK_IMPORTED_MODULE_8__["AceEditorComponent"], _components_auth_language_select_bar_auth_language_select_bar_component__WEBPACK_IMPORTED_MODULE_10__["AuthLanguageSelectBarComponent"], _components_auth_picker_auth_picker_component__WEBPACK_IMPORTED_MODULE_11__["AuthPickerComponent"], _components_auth_editor_action_buttons_auth_editor_action_buttons_component__WEBPACK_IMPORTED_MODULE_9__["AuthEditorActionButtonsComponent"], _components_editor_base_base_component__WEBPACK_IMPORTED_MODULE_18__["BaseComponent"], _components_editor_edit_meta_v2_edit_meta_v2_component__WEBPACK_IMPORTED_MODULE_19__["EditMetaV2Component"]],
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _ws_widget_utils__WEBPACK_IMPORTED_MODULE_4__["DefaultThumbnailModule"], _ws_widget_utils__WEBPACK_IMPORTED_MODULE_4__["PipeDurationTransformModule"], _ws_widget_collection__WEBPACK_IMPORTED_MODULE_3__["DisplayContentTypeModule"],
      // CKEditorModule,
      _ws_author_src_lib_modules_shared_shared_module__WEBPACK_IMPORTED_MODULE_5__["SharedModule"], ng2_ace_editor__WEBPACK_IMPORTED_MODULE_6__["AceEditorModule"], _shared_components_catalog_select_catalog_select_module__WEBPACK_IMPORTED_MODULE_7__["CatalogSelectModule"]],
      exports: [_components_rich_text_editor_my_own_component__WEBPACK_IMPORTED_MODULE_14__["MatQuillComponent"], _components_rich_text_editor_quill_component__WEBPACK_IMPORTED_MODULE_15__["QuillComponent"], _components_plain_ckeditor_plain_ckeditor_component__WEBPACK_IMPORTED_MODULE_13__["PlainCKEditorComponent"], _components_edit_meta_edit_meta_component__WEBPACK_IMPORTED_MODULE_12__["EditMetaComponent"], _directives_drag_drop_directive__WEBPACK_IMPORTED_MODULE_16__["DragDropDirective"], _components_ace_editor_ace_editor_component__WEBPACK_IMPORTED_MODULE_8__["AceEditorComponent"], _components_auth_editor_action_buttons_auth_editor_action_buttons_component__WEBPACK_IMPORTED_MODULE_9__["AuthEditorActionButtonsComponent"], _components_auth_picker_auth_picker_component__WEBPACK_IMPORTED_MODULE_11__["AuthPickerComponent"]],
      entryComponents: [_components_auth_picker_auth_picker_component__WEBPACK_IMPORTED_MODULE_11__["AuthPickerComponent"]],
      providers: [_services_upload_service__WEBPACK_IMPORTED_MODULE_17__["UploadService"]]
    })], EditorSharedModule);

    /***/
  }
}]);
//# sourceMappingURL=routing-modules-editor-editor-module-es5.js.map